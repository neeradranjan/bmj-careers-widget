<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BMJ Careers - Medical Jobs</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="main-wrapper">
    <div class="job-count-header">
        <div class="job-count-main" id="jobCountDisplay">
            Found 0 jobs
        </div>
        <div class="job-count-subtitle">
            Browse through available medical positions
        </div>
    </div>

    <div class="category-buttons-wrapper">
        <div class="category-buttons">
            <button class="category-btn active" onclick="applyCategoryFilter('all')" id="btn-all">
                <span class="emoji">üè•</span>
                <span>All Jobs</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('consultant')" id="btn-consultant">
                <span class="emoji">üë®‚Äç‚öïÔ∏è</span>
                <span>Consultant</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('gp')" id="btn-gp">
                <span class="emoji">ü©∫</span>
                <span>GP</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('overseas')" id="btn-overseas">
                <span class="emoji">üåç</span>
                <span>Overseas</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('training')" id="btn-training">
                <span class="emoji">üéì</span>
                <span>Academic</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('special')" id="btn-special">
                <span class="emoji">‚ö°</span>
                <span>Special</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('research')" id="btn-research">
                <span class="emoji">üî¨</span>
                <span>Research</span>
            </button>
        </div>
    </div>

    <div class="content-container">
        <div class="sidebar" id="sidebar">
            <div class="search-section">
                <h3 class="search-title">Keyword Search</h3>
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="keywordSearch" placeholder="Enter keywords...">
                    <button class="clear-keyword-btn" id="clearKeywordBtn" onclick="clearKeywordSearch()">√ó</button>
                </div>

                <div class="keywords-section">
                    <label class="keywords-label">Popular Keywords</label>
                    <div class="keywords-list" id="keywordsList">
                    </div>
                </div>
            </div>

            <div class="filters-section">
                <h3 class="filters-title">Filter By Category</h3>
                <div id="filtersContainer">
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="jobs-section">
                <div id="jobsList">
                </div>
            </div>

            <div class="pagination-section">
                <div class="pagination-info">
                    Showing <span id="jobRangeStart">1</span>-<span id="jobRangeEnd">6</span> of <span id="totalJobsCount">0</span> jobs
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" id="firstBtn" onclick="goToPage(1)">First</button>
                    <button class="pagination-btn" id="prevBtn" onclick="goToPage(getCurrentPage() - 1)">‚Äπ</button>
                    <span id="pageNumbers"></span>
                    <button class="pagination-btn" id="nextBtn" onclick="goToPage(getCurrentPage() + 1)">‚Ä∫</button>
                    <button class="pagination-btn" id="lastBtn" onclick="goToPage(Math.ceil(filteredJobs.length / jobsPerPage))">Last</button>
                </div>
            </div>
        </div>
    </div>
</div>

<button class="scroll-to-top" id="scrollToTop" title="Move To Top" onclick="scrollToTop()">
    ‚Üë
</button>

<script>
    // Initialize with empty array - will be populated by API
    let allJobsData = [];
window.allJobsData = allJobsData;

    // Dynamic hierarchy objects that will be populated from data
    let dynamicProfessionHierarchy = {};
    let dynamicLocationHierarchy = {};

    const professionHierarchy = {
        'GP': {
            subcategories: [
                'Digital GP',
                'GP Partner',
                'GP Trainee',
                'Locum GP',
                'Salaried GP'
            ]
        },
        'Specialist Doctor': {
            subcategories: [
                'Acute Internal Medicine',
                'Adult Critical Care',
                'Anaesthesia',
                'Anatomy',
                'Audiological Medicine',
                'BioChemistry',
                'Cardiology',
                'Cardiothoracic Surgery',
                'Cytopathology',
                'Dermatology',
                'Diabetes & Endocrinology',
                'Emergency medicine',
                'ENT/Otolaryngology',
                'Forensic Pathology',
                'Gastroenterology',
                'General Internal Medicine',
                'General Surgery',
                'Genetics',
                'Genitourinary Medicine',
                'Geriatric Medicine',
                'GP in Emergency Medicine',
                'Gynaecological Oncology',
                'Haematology',
                'Hepatology',
                'Histopathology',
                'Immunology',
                'Intensive and Critical Care Medicine',
                'Locum Doctor',
                'Maternal and Foetal Medicine',
                'Metabolic Medicine',
                'Microbiology, Virology and Infectious Diseases',
                'Neonatology',
                'Nephrology/Renal Medicine',
                'Neurology',
                'Neuropathology',
                'Neurophysiology',
                'Neurosurgery',
                'Nuclear Medicine',
                'Obstetrics and Gynaecology',
                'Occupational Medicine',
                'Oncology',
                'Ophthalmology',
                'Oral and Maxillofacial Surgery',
                {
                    name: 'Paediatrics',
                    subcategories: [
                        'Paediatric cardiology',
                        'Paediatric diabetes and endocrinology',
                        'Paediatric emergency medicine',
                        'Paediatric gastroenterology, Hepatology and Nutrition',
                        'Paediatric immunology, infectious diseases and allergy',
                        'Paediatric intensive Care Medicine',
                        'Paediatric nephrology',
                        'Paediatric neurodisability',
                        'Paediatric neurology',
                        'Paediatric oncology',
                        'Paediatric palliative Medicine',
                        'Paediatric pathology',
                        'Paediatric respiratory medicine',
                        'Paediatric rheumatology',
                        'Paediatric surgery'
                    ]
                },
                'Palliative medicine',
                'Pathology',
                'Pharmaceutical medicine',
                'Pharmalogy and Therapeutics',
                'Physiology',
                'Plastic Surgery',
                'Pre Hospital Emergency Medicine',
                {
                    name: 'Psychiatry',
                    subcategories: [
                        'Child and Adolescent Psychiatry',
                        'Community Psychiatry',
                        'Forensic Psychiatry',
                        'General Adult Psychiatry',
                        'Liaison Psychiatry',
                        'Medical Psychotherapy',
                        'Old-age Psychiatry',
                        'Psychiatry of eating disorders',
                        'Psychiatry of learning disablity',
                        'Rehabilition Psychiatry',
                        'Substance Misuse Psychiatry'
                    ]
                },
                'Public Health Medicine and Epidemiology',
                'Radiology',
                'Rahabilitation Medicine',
                'Respiratory Medicine',
                'Rheumatology',
                'RMO',
                'Sexual and Reproductive Health',
                'Spinal Injuries',
                'Sports and Exercise Medicine',
                'Stroke Medicine',
                'Trauma and Orthopaedics',
                'Tropical Medicine',
                'Urogynaecology',
                'Urology',
                'Vascular Surgery'
            ]
        },
        'Other Medical Roles': {
            subcategories: [
                'Armed Forces Doctor',
                'Commissioning',
                'Government and Health Policy',
                'Healthtech',
                'International medical Jobs',
                'Medical Education and Training',
                'Medical Examiner',
                'Medical leadership',
                'Medical training Initiative',
                'Medico-legal',
                'Occupational health',
                'Pharmaceutical',
                'Public Health',
                'Special Appointements'
            ]
        },
        'Nurse': {
            subcategories: [
                {
                    name: 'Adult Nurse',
                    subcategories: [
                        'A&E Nurse',
                        'Acute Nurse',
                        'Anaesthesia Nurse',
                        'Cancer Nurse',
                        'Cardiology Nurse',
                        'Elderly Care Nurse',
                        'Fertility Nurse',
                        'ICU Nurse',
                        'Ophthalmics Nurse',
                        'Palliative Care Nurse',
                        'Renal Nurse',
                        'Respiratory Nurse',
                        'Sexual Health Nurse',
                        'Theatre Nurse',
                        'Trauma Nurse'
                    ]
                },
                {
                    name: 'Community Nurse',
                    subcategories: [
                        'Care Home Nurse',
                        'Community MidWife',
                        'District Nurse',
                        'Health Visitor',
                        'Mental Health Nurse - Community',
                        'School Nurse'
                    ]
                },
                'General Practice Nurse',
                'Learning Disablity Nurse',
                {
                    name: 'Mental Health Nurse',
                    subcategories: [
                        'Adult Mental Health Nurse',
                        'CAMHS Nurse',
                        'Community Mental Health Nurse',
                        'Eating Disorders Nurse',
                        'Forensic Mental Health Nurse',
                        'Mental Health Liaison Nurse',
                        'Mental health Nurse in Primary care',
                        'Old Age Mental Health Care Nurse',
                        'Perinatal Mental Health Nurse',
                        'Rehabilitation Mental Health Nurse',
                        'Substance Misuse Nurse'
                    ]
                },
                'Midwife',
                'Nurse associate',
                {
                    name: 'Paediatric Nurse',
                    subcategories: [
                        'Neonatal Nurse',
                        'Paediatric A&E Nurse'
                    ]
                },
                'Prison Nurse'
            ]
        },
        'Mental Health Professional': {
            subcategories: [
                'CBT Therapist',
                'Counsellor',
                'Mental health Practitioner',
                'Psychologist',
                'Psychotherapist'
            ]
        },
        'Pharmacist': {
            subcategories: [
                'Pharmacy technician'
            ]
        },
        'Physician Associate': {
            subcategories: []
        },
        'Senior Manager': {
            subcategories: []
        },
        'Other Health Profession': {
            subcategories: []
        }
    };

    const locationHierarchy = {
        'London': {
            subcategories: [
                'Central London',
                'North London',
                'South London',
                'East London',
                'West London',
                'Greater London'
            ]
        },
        'South East England': {
            subcategories: [
                'Brighton',
                'Canterbury',
                'Oxford',
                'Reading',
                'Southampton',
                'Portsmouth',
                'Guildford',
                'Maidstone',
                'Crawley',
                'Slough',
                'Milton Keynes',
                'Luton',
                'Medway',
                'Ashford',
                'Basingstoke',
                'Eastbourne',
                'Hastings',
                'Worthing',
                'Bracknell',
                'Maidenhead',
                'Windsor',
                'Berkshire',
                'Buckinghamshire',
                'East Sussex',
                'Hampshire',
                'Isle of Wight',
                'Kent',
                'Oxfordshire',
                'Surrey',
                'West Sussex'
            ]
        },
        'South West England': {
            subcategories: [
                'Bristol',
                'Plymouth',
                'Bournemouth',
                'Swindon',
                'Gloucester',
                'Exeter',
                'Bath',
                'Cheltenham',
                'Torbay',
                'Poole',
                'Taunton',
                'Salisbury',
                'Truro',
                'Weymouth',
                'Weston-super-Mare',
                'Yeovil',
                'Barnstaple',
                'Bridgwater',
                'Cornwall',
                'Devon',
                'Dorset',
                'Gloucestershire',
                'Somerset',
                'Wiltshire'
            ]
        },
        'East of England': {
            subcategories: [
                'Cambridge',
                'Norwich',
                'Peterborough',
                'Ipswich',
                'Colchester',
                'Southend-on-Sea',
                'Luton',
                'Watford',
                'St Albans',
                'Chelmsford',
                'Basildon',
                'Harlow',
                'Stevenage',
                'Bedford',
                'Bury St Edmunds',
                'Hertford',
                'Huntingdon',
                'Kings Lynn',
                'Lowestoft',
                'Bedfordshire',
                'Cambridgeshire',
                'Essex',
                'Hertfordshire',
                'Norfolk',
                'Suffolk'
            ]
        },
        'East Midlands': {
            subcategories: [
                'Nottingham',
                'Leicester',
                'Derby',
                'Northampton',
                'Lincoln',
                'Mansfield',
                'Chesterfield',
                'Kettering',
                'Loughborough',
                'Boston',
                'Grantham',
                'Corby',
                'Hinckley',
                'Newark',
                'Wellingborough',
                'Derbyshire',
                'Leicestershire',
                'Lincolnshire',
                'Northamptonshire',
                'Nottinghamshire',
                'Rutland'
            ]
        },
        'West Midlands': {
            subcategories: [
                'Birmingham',
                'Coventry',
                'Wolverhampton',
                'Stoke-on-Trent',
                'Solihull',
                'Walsall',
                'Dudley',
                'Sandwell',
                'Worcester',
                'Shrewsbury',
                'Telford',
                'Stafford',
                'Warwick',
                'Hereford',
                'Stratford-upon-Avon',
                'Lichfield',
                'Tamworth',
                'Redditch',
                'Kidderminster',
                'Herefordshire',
                'Shropshire',
                'Staffordshire',
                'Warwickshire',
                'Worcestershire'
            ]
        },
        'Yorkshire and the Humber': {
            subcategories: [
                'Leeds',
                'Sheffield',
                'Bradford',
                'Hull',
                'York',
                'Huddersfield',
                'Middlesbrough',
                'Doncaster',
                'Rotherham',
                'Wakefield',
                'Barnsley',
                'Halifax',
                'Harrogate',
                'Scarborough',
                'Dewsbury',
                'Keighley',
                'Scunthorpe',
                'Grimsby',
                'East Yorkshire',
                'North Yorkshire',
                'South Yorkshire',
                'West Yorkshire'
            ]
        },
        'North West England': {
            subcategories: [
                'Manchester',
                'Liverpool',
                'Warrington',
                'Bolton',
                'Blackpool',
                'Preston',
                'Chester',
                'Stockport',
                'Oldham',
                'Rochdale',
                'Salford',
                'Wigan',
                'Bury',
                'Blackburn',
                'St Helens',
                'Carlisle',
                'Lancaster',
                'Crewe',
                'Burnley',
                'Macclesfield',
                'Barrow-in-Furness',
                'Runcorn',
                'Ellesmere Port',
                'Cheshire',
                'Cumbria',
                'Greater Manchester',
                'Lancashire',
                'Merseyside'
            ]
        },
        'North East England': {
            subcategories: [
                'Newcastle upon Tyne',
                'Sunderland',
                'Durham',
                'Gateshead',
                'Middlesbrough',
                'Stockton-on-Tees',
                'Darlington',
                'Hartlepool',
                'South Shields',
                'Tynemouth',
                'Washington',
                'Ashington',
                'Blyth',
                'Redcar',
                'Bishop Auckland',
                'County Durham',
                'Northumberland',
                'Tyne and Wear',
                'Teesside'
            ]
        },
        'Scotland': {
            subcategories: [
                'Edinburgh',
                'Glasgow',
                'Aberdeen',
                'Dundee',
                'Inverness',
                'Perth',
                'Stirling',
                'Paisley',
                'East Kilbride',
                'Livingston',
                'Hamilton',
                'Cumbernauld',
                'Dunfermline',
                'Kirkcaldy',
                'Ayr',
                'Kilmarnock',
                'Greenock',
                'Coatbridge',
                'Glenrothes',
                'Falkirk'
            ]
        },
        'Wales': {
            subcategories: [
                'Cardiff',
                'Swansea',
                'Newport',
                'Wrexham',
                'Barry',
                'Neath',
                'Cwmbran',
                'Llanelli',
                'Rhondda',
                'Merthyr Tydfil',
                'Bridgend',
                'Caerphilly',
                'Port Talbot',
                'Pontypridd',
                'Aberdare',
                'Colwyn Bay',
                'Rhyl',
                'Flintshire',
                'Gwynedd',
                'Anglesey'
            ]
        },
        'Northern Ireland': {
            subcategories: [
                'Belfast',
                'Derry',
                'Lisburn',
                'Newtownabbey',
                'Bangor',
                'Craigavon',
                'Castlereagh',
                'Ballymena',
                'Newtownards',
                'Newry',
                'Carrickfergus',
                'Coleraine',
                'Omagh',
                'Larne',
                'Banbridge',
                'Armagh',
                'Dungannon',
                'Enniskillen',
                'Strabane',
                'Antrim'
            ]
        },
        'Overseas': {
            subcategories: [
                'Republic of Ireland',
                'Channel Islands',
                'Isle of Man',
                'Europe',
                'Middle East',
                'Asia Pacific',
                'North America',
                'South America',
                'Africa',
                'Australia',
                'New Zealand',
                'Other International'
            ]
        }
    };

    let filterData = {};
    let keywords = [];
    let currentPage = 1;
    const jobsPerPage = 10;
    let filteredJobs = [];
    let activeCategoryFilter = 'all';
    let lastWindowWidth = window.innerWidth;

    // In server.js, find the categoryFilters object and replace it with this updated version:

const categoryFilters = {
    all: {
        name: 'All Jobs',
        keywords: [],
        filter: () => true
    },
    consultant: {
        name: 'Consultant',
        keywords: ['consultant'],
        filter: (job) => {
            const jobTitle = (job.job_title || '').toLowerCase();
            const grade = (job.grade || '').toLowerCase();

            return jobTitle.includes('consultant') || grade.includes('consultant');
        }
    },
    gp: {
        name: 'GP Jobs',
        keywords: ['gp'],
        filter: (job) => {
            const sectors = job.sector || [];
            return sectors.some(sector =>
                sector.toLowerCase().includes('gp')
            );
        }
    },
    overseas: {
        name: 'Overseas',
        keywords: [],
        filter: (job) => {
            const country = (job.location_country || '').toLowerCase().trim();
            const locationDesc = (job.location_description || '').toLowerCase().trim();

            // List of UK countries/variations
            const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales', 'northern ireland',
                               'britain', 'great britain', 'gb', 'u.k.', 'united kindom']; // Include typos

            // If country field exists and is not empty
            if (country && country.length > 0) {
                // Check if country is NOT UK
                const isUK = ukCountries.some(ukVariant => country.includes(ukVariant));
                if (!isUK) {
                    return true; // It's overseas
                }
            }

            // Check location description for overseas indicators
            const overseasIndicators = [
                'australia', 'new zealand', 'canada', 'usa', 'united states', 'america',
                'dubai', 'uae', 'emirates', 'singapore', 'hong kong', 'japan', 'china',
                'india', 'germany', 'france', 'spain', 'italy', 'netherlands', 'belgium',
                'switzerland', 'norway', 'sweden', 'denmark', 'ireland', 'dublin',
                'sydney', 'melbourne', 'brisbane', 'perth', 'adelaide', 'auckland',
                'wellington', 'toronto', 'vancouver', 'montreal'
            ];

            for (const indicator of overseasIndicators) {
                // Special case for Ireland - exclude Northern Ireland
                if (indicator === 'ireland' && (locationDesc.includes('northern') || country.includes('northern'))) {
                    continue;
                }
                if (locationDesc.includes(indicator)) {
                    return true;
                }
            }

            // If location contains common UK regions, it's NOT overseas
            const ukRegions = ['london', 'manchester', 'birmingham', 'leeds', 'glasgow',
                              'edinburgh', 'cardiff', 'belfast', 'liverpool', 'bristol',
                              'sheffield', 'newcastle', 'nottingham', 'southampton', 'oxford',
                              'cambridge', 'brighton', 'leicester', 'coventry', 'hull'];

            const hasUKRegion = ukRegions.some(region => locationDesc.includes(region));
            if (hasUKRegion) {
                return false;
            }

            // Final check - if country exists and doesn't match UK, it's overseas
            if (country && country.length > 0) {
                return !ukCountries.some(ukVariant => country.includes(ukVariant));
            }

            return false; // Default to UK if uncertain
        }
    },
    training: {
        name: 'Academic', // Renamed from 'Training'
        keywords: ['medical education', 'training', 'lecturer', 'professor'],
        filter: (job) => {
            const sectors = job.sector || [];
            const grade = (job.grade || '').toLowerCase();

            // Check if sector contains "Medical education & training"
            const hasEducationSector = sectors.some(sector =>
                sector.toLowerCase().includes('medical education') &&
                sector.toLowerCase().includes('training')
            );

            // Check if grade contains "Lecturer" or "Professor"
            const hasAcademicGrade = grade.includes('lecturer') || grade.includes('professor');

            return hasEducationSector || hasAcademicGrade;
        }
    },
    special: {
        name: 'Special',
        keywords: ['special appointments'],
        filter: (job) => {
            const sectors = job.sector || [];
            return sectors.some(sector =>
                sector.toLowerCase().includes('special appointments')
            );
        }
    },
    research: {
        name: 'Research',
        keywords: ['medical research'],
        filter: (job) => {
            const sectors = job.sector || [];
            return sectors.some(sector =>
                sector.toLowerCase().includes('medical research')
            );
        }
    }
};

    // All function definitions remain the same
    function normalizeLocation(location) {
        return location.toLowerCase().trim()
            .replace(/\s+/g, ' ')
            .replace(/[^\w\s-]/g, '');
    }

    function categorizeLocation(locationStr) {
        const normalized = normalizeLocation(locationStr);

        // First check against dynamic hierarchy
        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            if (normalizeLocation(region) === normalized) {
                return { region: region, isRegion: true };
            }
        }

        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            for (const subcategory of data.subcategories) {
                if (normalizeLocation(subcategory) === normalized) {
                    return { region: region, subcategory: subcategory, isRegion: false };
                }
            }
        }

        const ukCountries = ['england', 'scotland', 'wales', 'northern ireland', 'uk', 'united kingdom', 'britain', 'great britain', 'nationwide', 'homeworking'];

        // Extract country from location string
        const locationLower = locationStr.toLowerCase().trim();

        // Check if it contains any UK indicators
        const isUK = ukCountries.some(country => locationLower.includes(country)) ||
                     // Check for UK regions
                     Object.keys(locationHierarchy).filter(k => k !== 'Overseas').some(region =>
                         locationLower.includes(region.toLowerCase())
                     );

        if (!isUK) {
            // Extract country name for overseas locations
            let countryName = null;

            // Try to extract from the location string
            const parts = locationStr.split(',');
            if (parts.length > 1) {
                const potentialCountry = parts[parts.length - 1].trim();
                countryName = potentialCountry.split(' ').map(word =>
                    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                ).join(' ');
            } else {
                countryName = 'Other International';
            }

            return { region: 'Overseas', subcategory: countryName, isRegion: false };
        }

        if (normalized.includes('london')) {
            return { region: 'London', subcategory: 'Greater London', isRegion: false };
        }

        return { region: 'Other UK', subcategory: locationStr, isRegion: false };
    }

    function getCurrentDate() {
        return new Date();
    }

    function parseDaysFromPublished(publishedString) {
        if (!publishedString) return null;

        const lowerStr = publishedString.toLowerCase();

        if (lowerStr.includes('24 hours') || lowerStr.includes('today')) {
            return 1;
        } else if (lowerStr.includes('yesterday')) {
            return 1;
        } else if (lowerStr.includes('last') && lowerStr.includes('days')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) : null;
        } else if (lowerStr.includes('week')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 7 : 7;
        } else if (lowerStr.includes('month')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 30 : 30;
        }

        return null;
    }

    function categorizePublishedString(publishedString) {
        const days = parseDaysFromPublished(publishedString);

        if (!days) return null;

        if (days <= 3) return "Last 3 Days";
        else if (days <= 7) return "Last 7 Days";
        else if (days <= 14) return "Last 14 Days";
        else if (days <= 28) return "Last 28 Days";
        else return "More than 28 Days";
    }

    function filterActiveJobs(jobs) {
        const currentDate = getCurrentDate();
        return jobs.filter(job => {
            if (job.job_end_date) {
                const endDate = new Date(job.job_end_date);
                return endDate >= currentDate;
            }
            return true;
        });
    }

    window.applyCategoryFilter = function(category) {
    activeCategoryFilter = category;
    updateCategoryButtons();

    // If "All Jobs" is selected, reset everything
    if (category === 'all') {
        // Clear keyword search
        document.getElementById('keywordSearch').value = '';

        // Uncheck all filter checkboxes
        document.querySelectorAll('.filter-checkbox, .profession-parent-checkbox, .profession-sub-checkbox, .location-checkbox, .location-sub-checkbox').forEach(checkbox => {
            checkbox.checked = false;
            checkbox.classList.remove('indeterminate');
        });
    }

    applyFilters();
    scrollToTop();
};

window.clearKeywordSearch = function() {
    document.getElementById('keywordSearch').value = '';
    applyFilters();
    updateCategoryButtons(); // Update button states after clearing search
    scrollToTop();
};


// Add this to the addEventListeners function
keywordSearch.addEventListener('input', function() {
    clearTimeout(this.searchTimeout);
    this.searchTimeout = setTimeout(() => {
        applyFilters();
        scrollToTop();
    }, 100);
});

window.selectKeyword = function(keyword) {
    document.getElementById('keywordSearch').value = keyword;
    applyFilters();
    updateCategoryButtons(); // Update button states after selecting keyword
    scrollToTop();
};


    window.toggleFilterGroup = function(groupName) {
        const arrow = document.getElementById(groupName + 'Arrow');
        const options = document.getElementById(groupName + 'Options');

        if (options.classList.contains('collapsed')) {
            options.classList.remove('collapsed');
            arrow.classList.remove('collapsed');
            arrow.textContent = '‚ñº';
        } else {
            options.classList.add('collapsed');
            arrow.classList.add('collapsed');
            arrow.textContent = '‚ñ∂';
        }
    };

    window.toggleParentCategory = function(category, parentName) {
        const arrow = document.getElementById(`${category}_parent_arrow_${parentName.replace(/\s+/g, '_')}`);
        const subcategories = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);

        if (subcategories.classList.contains('collapsed')) {
            subcategories.classList.remove('collapsed');
            arrow.classList.remove('collapsed');
            arrow.textContent = '‚ñº';
        } else {
            subcategories.classList.add('collapsed');
            arrow.classList.add('collapsed');
            arrow.textContent = '‚ñ∂';
        }
    };

window.handleParentCategoryChange = function(category, parentName) {
    const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
    const isChecked = parentCheckbox.checked;

    const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
    const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

    subCheckboxes.forEach(checkbox => {
        checkbox.checked = isChecked;
    });

    applyFilters();
    updateCategoryButtons(); // Update button states after filter change
    scrollToTop();
};


window.handleSubCategoryChange = function(category, parentName, subName) {
    updateParentCheckboxState(category, parentName);
    applyFilters();
    updateCategoryButtons(); // Update button states after filter change
    scrollToTop();
};

    window.toggleProfessionParent = function(parentName) {
        toggleParentCategory('profession', parentName);
    };

window.handleParentProfessionChange = function(parentName) {
    handleParentCategoryChange('profession', parentName);
};

window.handleSubProfessionChange = function(parentName, subName) {
    handleSubCategoryChange('profession', parentName, subName);

    // Send tracking event
    if (window.self !== window.top) {
        window.parent.postMessage({
            type: 'bmj-careers-filter-change',
            filterType: 'profession',
            filterValue: subName,
            parent: parentName
        }, '*');
    }
};

window.handleFilterChange = function(category, value) {
    // Send tracking event to parent if in iframe
    if (window.self !== window.top) {
        window.parent.postMessage({
            type: 'bmj-careers-filter-change',
            filterType: category,
            filterValue: value,
            checked: document.getElementById(`${category}_${value.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`).checked
        }, '*');
    }

    applyFilters();
    updateCategoryButtons(); // Update button states after filter change
    scrollToTop();
};



    window.applyToJob = function(jobId) {
        const job = allJobsData.find(j => j.id === jobId);
        if (job && job.job_url) {
            window.open(job.job_url, '_blank', 'noopener,noreferrer');
        } else {
            window.open('https://www.bmj.com/careers/jobs/', '_blank', 'noopener,noreferrer');
        }
    };

    window.goToPage = function(page) {
        const totalPages = Math.ceil(filteredJobs.length / jobsPerPage);
        if (page < 1 || page > totalPages) return;

        currentPage = page;
        renderJobsList();
        updatePagination();

        document.querySelector('.jobs-section').scrollIntoView({ behavior: 'smooth' });
    };

    window.getCurrentPage = function() {
        return currentPage;
    };

    window.scrollToTop = function() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    };

    function handleScroll() {
        const scrollToTopBtn = document.getElementById('scrollToTop');
        if (window.pageYOffset > 300) {
            scrollToTopBtn.classList.add('show');
        } else {
            scrollToTopBtn.classList.remove('show');
        }
    }

function updateCategoryButtons() {
    // First, check if there are any active filters
    const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
    const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;
    const hasActiveFilters = searchTerm.length > 0 || hasCheckedFilters;

    document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // Only add active class if it's truly the active category and no other filters are applied
    const activeBtn = document.getElementById(`btn-${activeCategoryFilter}`);
    if (activeBtn) {
        // For 'all' button, only show active if no filters are applied
        if (activeCategoryFilter === 'all' && !hasActiveFilters) {
            activeBtn.classList.add('active');
        } else if (activeCategoryFilter !== 'all') {
            // For other category buttons, always show active when selected
            activeBtn.classList.add('active');
        }
    }
}



    function updateParentCheckboxState(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        const checkedCount = Array.from(subCheckboxes).filter(cb => cb.checked).length;
        const totalCount = subCheckboxes.length;

        if (checkedCount === 0) {
            parentCheckbox.checked = false;
            parentCheckbox.classList.remove('indeterminate');
        } else if (checkedCount === totalCount) {
            parentCheckbox.checked = true;
            parentCheckbox.classList.remove('indeterminate');
        } else {
            parentCheckbox.checked = false;
            parentCheckbox.classList.add('indeterminate');
        }
    }

    // Build dynamic hierarchies from job data
function buildDynamicHierarchies() {
    // Deep copy the base hierarchies
    dynamicProfessionHierarchy = JSON.parse(JSON.stringify(professionHierarchy));
    dynamicLocationHierarchy = JSON.parse(JSON.stringify(locationHierarchy));

    const activeJobs = filterActiveJobs(allJobsData);

    // Clear existing Overseas subcategories
    dynamicLocationHierarchy.Overseas.subcategories = [];

    // Track unique countries
    const overseasCountries = new Set();

    // Process locations for Overseas
    activeJobs.forEach(job => {
        // Use the same filter logic as the category filter
        if (categoryFilters.overseas.filter(job)) {
            const location = job.location_description || '';
            const country = job.location_country || '';

            let countryName = null;

            // Extract country name
            const locationLower = location.toLowerCase();
            const countryLower = country.toLowerCase();

            // Specific country detection
            if (locationLower.includes('australia') || countryLower.includes('australia') ||
                locationLower.includes('sydney') || locationLower.includes('melbourne') ||
                locationLower.includes('brisbane') || locationLower.includes('perth') ||
                locationLower.includes('adelaide')) {
                countryName = 'Australia';
            } else if (locationLower.includes('new zealand') || countryLower.includes('new zealand') ||
                       locationLower.includes('auckland') || locationLower.includes('wellington') ||
                       locationLower.includes('christchurch')) {
                countryName = 'New Zealand';
            } else if (locationLower.includes('canada') || countryLower.includes('canada') ||
                       locationLower.includes('toronto') || locationLower.includes('vancouver') ||
                       locationLower.includes('montreal')) {
                countryName = 'Canada';
            } else if ((locationLower.includes('ireland') || countryLower.includes('ireland') ||
                        locationLower.includes('dublin')) &&
                       !locationLower.includes('northern') && !countryLower.includes('northern')) {
                countryName = 'Republic of Ireland';
            } else if (locationLower.includes('usa') || locationLower.includes('united states') ||
                       countryLower.includes('usa') || countryLower.includes('united states') ||
                       locationLower.includes('america')) {
                countryName = 'United States';
            } else if (locationLower.includes('dubai') || locationLower.includes('uae') ||
                       countryLower.includes('dubai') || countryLower.includes('uae') ||
                       locationLower.includes('emirates')) {
                countryName = 'UAE';
            } else if (locationLower.includes('singapore') || countryLower.includes('singapore')) {
                countryName = 'Singapore';
            } else if (locationLower.includes('hong kong') || countryLower.includes('hong kong')) {
                countryName = 'Hong Kong';
            } else if (locationLower.includes('germany') || countryLower.includes('germany')) {
                countryName = 'Germany';
            } else if (locationLower.includes('france') || countryLower.includes('france')) {
                countryName = 'France';
            } else if (locationLower.includes('spain') || countryLower.includes('spain')) {
                countryName = 'Spain';
            } else if (locationLower.includes('netherlands') || countryLower.includes('netherlands')) {
                countryName = 'Netherlands';
            } else if (locationLower.includes('switzerland') || countryLower.includes('switzerland')) {
                countryName = 'Switzerland';
            } else if (country && country.length > 0) {
                // Clean up country name
                const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales',
                                   'northern ireland', 'britain', 'great britain'];
                const isUK = ukCountries.some(uk => country.toLowerCase().includes(uk));

                if (!isUK) {
                    // Capitalize first letter of each word
                    countryName = country.split(' ').map(word =>
                        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                    ).join(' ');
                }
            }

            if (countryName) {
                overseasCountries.add(countryName);
            }
        }
    });

    // Add all unique countries to the hierarchy and sort
    dynamicLocationHierarchy.Overseas.subcategories = Array.from(overseasCountries).sort();

    // If no overseas countries found, add a default
    if (dynamicLocationHierarchy.Overseas.subcategories.length === 0) {
        dynamicLocationHierarchy.Overseas.subcategories = ['Other International'];
    }

    // Process professions from sectors
    activeJobs.forEach(job => {
        if (job.sector && Array.isArray(job.sector)) {
            job.sector.forEach(sector => {
                // Add new sectors to appropriate categories
                // This is where you would add logic to categorize new professions
                // For now, we'll just ensure existing ones are included
            });
        }
    });
}

    // Updated count functions to work with current filter state
    function countJobsForLocationCategoryWithFilters(categoryName, subcategories, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except location)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply profession filters
        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                return checkedProfessions.some(profession => {
                    return searchText.includes(profession.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Now count for this specific location category
        return jobs.filter(job => {
            const location = job.location_description || '';
            const categorized = categorizeLocation(location);

            if (categorized.region === categoryName) {
                return true;
            }

            return subcategories.some(subcat => {
                const normalizedSubcat = normalizeLocation(subcat);
                const normalizedLocation = normalizeLocation(location);
                return normalizedLocation.includes(normalizedSubcat);
            });
        }).length;
    }

    function countJobsForSpecificLocationWithFilters(locationName, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except location)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply profession filters
        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                return checkedProfessions.some(profession => {
                    return searchText.includes(profession.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Check if this location is Overseas subcategory
        const isOverseasLocation = dynamicLocationHierarchy.Overseas.subcategories.includes(locationName);

        if (isOverseasLocation) {
    // Special handling for overseas locations
    return jobs.filter(job => {
        // First check if it's an overseas job
        if (!categoryFilters.overseas.filter(job)) {
            return false;
        }

        const location = job.location_description || '';
        const country = job.location_country || '';
        const locationLower = location.toLowerCase();
        const countryLower = country.toLowerCase();
        const searchLower = locationName.toLowerCase();

        // Direct country match
        if (countryLower.includes(searchLower) || searchLower.includes(countryLower)) {
            return true;
        }

        // Match specific countries with their cities
        if (locationName === 'Australia') {
            return locationLower.includes('australia') ||
                   locationLower.includes('sydney') || locationLower.includes('melbourne') ||
                   locationLower.includes('brisbane') || locationLower.includes('perth') ||
                   locationLower.includes('adelaide');
        } else if (locationName === 'New Zealand') {
            return locationLower.includes('new zealand') ||
                   locationLower.includes('auckland') || locationLower.includes('wellington') ||
                   locationLower.includes('christchurch');
        } else if (locationName === 'Canada') {
            return locationLower.includes('canada') ||
                   locationLower.includes('toronto') || locationLower.includes('vancouver') ||
                   locationLower.includes('montreal');
        }
        // ... continue with other specific country matches ...

       return false;
    }).length;
} else {
    // Regular location matching
    return jobs.filter(job => {
        const location = job.location_description || '';
        const normalizedLocation = normalizeLocation(location);
        const normalizedSearch = normalizeLocation(locationName);
        return normalizedLocation.includes(normalizedSearch);
    }).length;
}
}

    function buildLocationHierarchy() {
        const locationData = [];

        // Get current filter state
        const currentFilters = {};

        // Check if London has jobs
        const londonCount = countJobsForSpecificLocationWithFilters('London', currentFilters);
        if (londonCount > 0) {
            locationData.push({
                name: 'London',
                count: londonCount,
                subcategories: []
            });
        }

        Object.entries(dynamicLocationHierarchy).forEach(([parentName, parentData]) => {
            if (parentName === 'London') return;

            const parentCount = countJobsForLocationCategoryWithFilters(parentName, parentData.subcategories, currentFilters);

            if (parentCount > 0) {
                const subcategoryData = [];

                parentData.subcategories.forEach(subcategory => {
                    const count = countJobsForSpecificLocationWithFilters(subcategory, currentFilters);
                    if (count > 0) {
                        subcategoryData.push({ name: subcategory, count });
                    }
                });

                locationData.push({
                    name: parentName,
                    count: parentCount,
                    subcategories: subcategoryData
                });
            }
        });

        return locationData;
    }

    function getCheckedLocations() {
        const checkedLocations = [];

        const simpleCheckboxes = document.querySelectorAll('.location-checkbox:checked');
        simpleCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                // Remove the count from the location name
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        const subCheckboxes = document.querySelectorAll('.location-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                // Remove the count from the location name
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        return checkedLocations;
    }

    function countJobsForProfessionCategoryWithFilters(categoryName, subcategories, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except profession)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply location filters
        const checkedLocations = getCheckedLocations();
        if (checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';

                return checkedLocations.some(location => {
                    // Check if this is an Overseas location
                    if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                        // First check if it's an overseas job
                        if (!categoryFilters.overseas.filter(job)) {
                            return false;
                        }

                        const country = job.location_country || '';
                        const locationLower = jobLocation.toLowerCase();
                        const countryLower = country.toLowerCase();

                        // Match specific country
                        if (location === 'Canada') {
                            return locationLower.includes('canada') || countryLower.includes('canada');
                        } else if (location === 'Australia') {
                            return locationLower.includes('australia') || countryLower.includes('australia');
                        } else if (location === 'New Zealand') {
                            return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                        } else if (location === 'Republic of Ireland') {
                            return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                   !locationLower.includes('northern') && !countryLower.includes('northern');
                        } else if (location === 'North America') {
                            return locationLower.includes('usa') || locationLower.includes('united states') ||
                                   countryLower.includes('usa') || countryLower.includes('united states');
                        } else if (location === 'Middle East') {
                            return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                   countryLower.includes('dubai') || countryLower.includes('uae');
                        } else if (location === country) {
                            return true;
                        }

                        return false;
                    } else {
                        // Regular location matching
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    }
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Now count for this specific profession category
        return jobs.filter(job => {
            const sectors = job.sector || [];
            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();

            return subcategories.some(subcat => {
                if (typeof subcat === 'string') {
                    return searchText.includes(subcat.toLowerCase()) || sectors.some(s => s.toLowerCase() === subcat.toLowerCase());
                } else if (typeof subcat === 'object' && subcat.subcategories) {
                    return searchText.includes(subcat.name.toLowerCase()) ||
                           subcat.subcategories.some(nested => searchText.includes(nested.toLowerCase()));
                }
                return false;
            });
        }).length;
    }

    function countJobsForSpecificProfessionWithFilters(professionName, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except profession)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply location filters
        const checkedLocations = getCheckedLocations();
        if (checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';

                return checkedLocations.some(location => {
                    // Check if this is an Overseas location
                    if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                        // First check if it's an overseas job
                        if (!categoryFilters.overseas.filter(job)) {
                            return false;
                        }

                        const country = job.location_country || '';
                        const locationLower = jobLocation.toLowerCase();
                        const countryLower = country.toLowerCase();

                        // Match specific country
                        if (location === 'Canada') {
                            return locationLower.includes('canada') || countryLower.includes('canada');
                        } else if (location === 'Australia') {
                            return locationLower.includes('australia') || countryLower.includes('australia');
                        } else if (location === 'New Zealand') {
                            return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                        } else if (location === 'Republic of Ireland') {
                            return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                   !locationLower.includes('northern') && !countryLower.includes('northern');
                        } else if (location === 'North America') {
                            return locationLower.includes('usa') || locationLower.includes('united states') ||
                                   countryLower.includes('usa') || countryLower.includes('united states');
                        } else if (location === 'Middle East') {
                            return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                   countryLower.includes('dubai') || countryLower.includes('uae');
                        } else if (location === country) {
                            return true;
                        }

                        return false;
                    } else {
                        // Regular location matching
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    }
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
           const checkbox = document.getElementById(checkboxId);
           if (checkbox && checkbox.checked) {
               checkedPublished.push(item.name);
           }
       });
       if (checkedPublished.length > 0) {
           jobs = jobs.filter(job => {
               if (!job.published) return false;
               const jobDays = parseDaysFromPublished(job.published);
               if (!jobDays) return false;
               return checkedPublished.some(selectedCategory => {
                   switch(selectedCategory) {
                       case "Last 3 Days": return jobDays <= 3;
                       case "Last 7 Days": return jobDays <= 7;
                       case "Last 14 Days": return jobDays <= 14;
                       case "Last 28 Days": return jobDays <= 28;
                       case "More than 28 Days": return jobDays > 28;
                       default: return false;
                   }
               });
           });
       }

       // Now count for this specific profession
       return jobs.filter(job => {
           const sectors = job.sector || [];
           const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
           return searchText.includes(professionName.toLowerCase()) || sectors.some(s => s.toLowerCase() === professionName.toLowerCase());
       }).length;
   }

   function buildProfessionHierarchy() {
       const professionData = [];

       Object.entries(dynamicProfessionHierarchy).forEach(([parentName, parentData]) => {
           const parentCount = countJobsForProfessionCategoryWithFilters(parentName, parentData.subcategories, {});

           if (parentCount > 0) {
               const subcategoryData = [];

               parentData.subcategories.forEach(subcategory => {
                   if (typeof subcategory === 'string') {
                       const count = countJobsForSpecificProfessionWithFilters(subcategory, {});
                       if (count > 0) {
                           subcategoryData.push({ name: subcategory, count });
                       }
                   } else if (typeof subcategory === 'object' && subcategory.subcategories) {
                       const nestedCount = countJobsForSpecificProfessionWithFilters(subcategory.name, {});
                       if (nestedCount > 0) {
                           const nestedSubcategories = [];
                           subcategory.subcategories.forEach(nestedSub => {
                               const nestedSubCount = countJobsForSpecificProfessionWithFilters(nestedSub, {});
                               if (nestedSubCount > 0) {
                                   nestedSubcategories.push({ name: nestedSub, count: nestedSubCount });
                               }
                           });

                           subcategoryData.push({
                               name: subcategory.name,
                               count: nestedCount,
                               subcategories: nestedSubcategories
                           });
                       }
                   }
               });

               professionData.push({
                   name: parentName,
                   count: parentCount,
                   subcategories: subcategoryData
               });
           }
       });

       return professionData;
   }

   function getCheckedProfessions() {
       const checkedProfessions = [];

       const subCheckboxes = document.querySelectorAll('.profession-sub-checkbox:checked');
       subCheckboxes.forEach(checkbox => {
           const label = checkbox.nextElementSibling;
           if (label && label.textContent) {
               const professionName = label.textContent.trim();
               // Remove the count from the profession name
               const cleanName = professionName.replace(/\s*\(\d+\)$/, '');
               checkedProfessions.push(cleanName);
           }
       });

       return checkedProfessions;
   }

   function calculateFilterCounts() {
       filterData = {
           published: {},
           profession: {},
           grade: {},
           location: {}
       };

       const activeJobs = filterActiveJobs(allJobsData);

       if (activeJobs.length === 0) return;

       // Build dynamic hierarchies first
       buildDynamicHierarchies();

       // Calculate counts for published and grade
       let publishedCounts = {};
       let gradeCounts = {};

       activeJobs.forEach(job => {
           if (job.published) {
               const category = categorizePublishedString(job.published);
               if (category) {
                   publishedCounts[category] = (publishedCounts[category] || 0) + 1;
               }
           }

           if (job.grade) {
               gradeCounts[job.grade] = (gradeCounts[job.grade] || 0) + 1;
           }
       });

       // Convert to array format
       const publishedOrder = [
          "Last 3 Days",
           "Last 7 Days",
           "Last 14 Days",
           "Last 28 Days",
           "More than 28 Days"
       ];

       filterData.published = publishedOrder
           .filter(category => publishedCounts[category] > 0)
           .map(category => ({
               name: category,
               count: publishedCounts[category]
           }));

       filterData.grade = Object.entries(gradeCounts)
           .map(([name, count]) => ({ name, count }))
           .sort((a, b) => b.count - a.count);

       // Build profession and location hierarchies with dynamic counts
       filterData.profession = buildProfessionHierarchy();
       filterData.location = buildLocationHierarchy();
   }

   function renderLocationFilters(locationData) {
       return `
           <div class="filter-group">
               <div class="filter-header" onclick="toggleFilterGroup('location')">
                   <span class="filter-arrow" id="locationArrow">‚ñº</span>
                   <span>Location</span>
               </div>
               <div class="filter-options" id="locationOptions">
                   ${locationData.map(parent => {
                       const hasSubcategories = parent.subcategories && parent.subcategories.length > 0;

                       if (!hasSubcategories) {
                           return `
                               <div class="filter-item">
                                   <input type="checkbox" class="filter-checkbox location-checkbox" id="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                          onchange="handleFilterChange('location', '${parent.name}')">
                                   <label class="filter-label" for="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${parent.name}</label>
                                   <span class="filter-count">${parent.count}</span>
                               </div>
                           `;
                       } else {
                           return `
                               <div class="profession-parent-group">
                                   <div class="profession-parent-header" onclick="toggleParentCategory('location', '${parent.name}')">
                                       <input type="checkbox" class="profession-parent-checkbox" id="location_parent_${parent.name.replace(/\s+/g, '_')}"
                                              onchange="handleParentCategoryChange('location', '${parent.name}')" onclick="event.stopPropagation()">
                                       <label class="profession-parent-label" for="location_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                                       <span class="filter-count">${parent.count}</span>
                                       <span class="profession-parent-arrow" id="location_parent_arrow_${parent.name.replace(/\s+/g, '_')}">‚ñº</span>
                                   </div>
                                   <div class="profession-subcategories" id="location_subcategories_${parent.name.replace(/\s+/g, '_')}">
                                       ${parent.subcategories.map(sub => `
                                           <div class="profession-sub-item">
                                               <input type="checkbox" class="profession-sub-checkbox location-sub-checkbox" id="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                      onchange="handleSubCategoryChange('location', '${parent.name}', '${sub.name}')">
                                               <label class="profession-sub-label" for="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                                               <span class="filter-count">${sub.count}</span>
                                           </div>
                                       `).join('')}
                                   </div>
                               </div>
                           `;
                       }
                   }).join('')}
               </div>
           </div>
       `;
   }

   function renderProfessionFilters(professionData) {
       return `
           <div class="filter-group">
               <div class="filter-header" onclick="toggleFilterGroup('profession')">
                   <span class="filter-arrow" id="professionArrow">‚ñº</span>
                   <span>Profession</span>
               </div>
               <div class="filter-options" id="professionOptions">
                   ${professionData.map(parent => `
                       <div class="profession-parent-group">
                           <div class="profession-parent-header" onclick="toggleProfessionParent('${parent.name}')">
                               <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${parent.name.replace(/\s+/g, '_')}"
                                      onchange="handleParentProfessionChange('${parent.name}')" onclick="event.stopPropagation()">
                               <label class="profession-parent-label" for="profession_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                               <span class="filter-count">${parent.count}</span>
                               <span class="profession-parent-arrow" id="profession_parent_arrow_${parent.name.replace(/\s+/g, '_')}">‚ñº</span>
                           </div>
                           <div class="profession-subcategories" id="profession_subcategories_${parent.name.replace(/\s+/g, '_')}">
                               ${parent.subcategories.map(sub => {
                                   if (sub.subcategories) {
                                       return `
                                           <div class="profession-parent-group" style="margin-left: 20px; margin-bottom: 10px;">
                                               <div class="profession-parent-header" onclick="toggleProfessionParent('${sub.name}')">
                                                   <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${sub.name.replace(/\s+/g, '_')}"
                                                          onchange="handleParentProfessionChange('${sub.name}')" onclick="event.stopPropagation()">
                                                   <label class="profession-parent-label" for="profession_parent_${sub.name.replace(/\s+/g, '_')}">${sub.name}</label>
                                                   <span class="filter-count">${sub.count}</span>
                                                   <span class="profession-parent-arrow" id="profession_parent_arrow_${sub.name.replace(/\s+/g, '_')}">‚ñº</span>
                                               </div>
                                               <div class="profession-subcategories" id="profession_subcategories_${sub.name.replace(/\s+/g, '_')}">
                                                   ${sub.subcategories.map(nestedSub => `
                                                       <div class="profession-sub-item">
                                                           <input type="checkbox" class="profession-sub-checkbox" id="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                                  onchange="handleSubProfessionChange('${sub.name}', '${nestedSub.name}')">
                                                           <label class="profession-sub-label" for="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${nestedSub.name}</label>
                                                           <span class="filter-count">${nestedSub.count}</span>
                                                       </div>
                                                   `).join('')}
                                               </div>
                                           </div>
                                       `;
                                   } else {
                                       return `
                                           <div class="profession-sub-item">
                                               <input type="checkbox" class="profession-sub-checkbox" id="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                      onchange="handleSubProfessionChange('${parent.name}', '${sub.name}')">
                                               <label class="profession-sub-label" for="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                                               <span class="filter-count">${sub.count}</span>
                                           </div>
                                       `;
                                   }
                               }).join('')}
                           </div>
                       </div>
                   `).join('')}
               </div>
           </div>
       `;
   }

   function renderFilters() {
       const filtersContainer = document.getElementById('filtersContainer');

       const filterHTML = Object.entries(filterData).map(([category, items]) => {
           if (category === 'profession') {
               return renderProfessionFilters(items);
           } else if (category === 'location') {
               return renderLocationFilters(items);
           } else {
               const displayName = category === 'published' ? 'Date Published' : category.charAt(0).toUpperCase() + category.slice(1);
               return `
                   <div class="filter-group">
                       <div class="filter-header" onclick="toggleFilterGroup('${category}')">
                           <span class="filter-arrow" id="${category}Arrow">‚ñº</span>
                           <span>${displayName}</span>
                       </div>
                       <div class="filter-options" id="${category}Options">
                           ${items.map(item => {
                               const checkboxId = `${category}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                               return `
                                   <div class="filter-item">
                                       <input type="checkbox" class="filter-checkbox" id="${checkboxId}" onchange="handleFilterChange('${category}', '${item.name}')">
                                       <label class="filter-label" for="${checkboxId}">${item.name}</label>
                                       <span class="filter-count">${item.count}</span>
                                   </div>
                               `;
                           }).join('')}
                       </div>
                   </div>
               `;
           }
       }).join('');

       filtersContainer.innerHTML = filterHTML;
   }

   function applyFilters() {
    let activeJobs = filterActiveJobs(allJobsData);

    const activeFilters = {};

    Object.keys(filterData).forEach(category => {
        activeFilters[category] = [];
        if (category === 'profession') {
            activeFilters[category] = getCheckedProfessions();
        } else if (category === 'location') {
            activeFilters[category] = getCheckedLocations();
        } else {
            filterData[category].forEach(item => {
                const checkboxId = `${category}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    activeFilters[category].push(item.name);
                }
            });
        }
    });

    const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();

    const hasActiveFilters = searchTerm.length > 0 ||
                            Object.values(activeFilters).some(arr => arr.length > 0);

    // If any filters are active and category is 'all', remove active state
    if (hasActiveFilters && activeCategoryFilter === 'all') {
        document.getElementById('btn-all').classList.remove('active');
    }

    // Send search event if in iframe and search term exists
    if (window.self !== window.top && searchTerm) {
        window.parent.postMessage({
            type: 'bmj-careers-search',
            searchTerm: searchTerm,
            resultsCount: filteredJobs.length
        }, '*');
    }

    filteredJobs = activeJobs.filter(job => {
        if (activeCategoryFilter !== 'all') {
            if (!categoryFilters[activeCategoryFilter].filter(job)) {
                return false;
            }
        }

        if (searchTerm.length > 0) {
            const sectors = job.sector || [];
            const employer = job.alternate_recruiter_name || job.recruiter_name;
            const matchesSearch = job.job_title.toLowerCase().includes(searchTerm) ||
                                job.location_description.toLowerCase().includes(searchTerm) ||
                                employer.toLowerCase().includes(searchTerm) ||
                                job.short_description.toLowerCase().includes(searchTerm) ||
                                sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                                (job.grade && job.grade.toLowerCase().includes(searchTerm));
            if (!matchesSearch) return false;
        }

        for (const [category, selectedValues] of Object.entries(activeFilters)) {
            if (selectedValues.length > 0) {
                if (category === 'profession') {
                    const checkedProfessions = selectedValues;
                    const sectors = job.sector || [];
                    const employer = job.alternate_recruiter_name || job.recruiter_name;
                    const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                    const matchesProfession = checkedProfessions.some(profession => {
                        return searchText.includes(profession.toLowerCase()) ||
                               sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                    });
                    if (!matchesProfession) return false;
                } else if (category === 'location') {
                    const checkedLocations = selectedValues;
                    const jobLocation = job.location_description || '';

                    const matchesLocation = checkedLocations.some(location => {
                        if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                            if (!categoryFilters.overseas.filter(job)) {
                                return false;
                            }

                            const country = job.location_country || '';
                            const locationLower = jobLocation.toLowerCase();
                            const countryLower = country.toLowerCase();

                            if (location === 'Canada') {
                                return locationLower.includes('canada') || countryLower.includes('canada');
                            } else if (location === 'Australia') {
                                return locationLower.includes('australia') || countryLower.includes('australia');
                            } else if (location === 'New Zealand') {
                                return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                            } else if (location === 'Republic of Ireland') {
                                return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                       !locationLower.includes('northern') && !countryLower.includes('northern');
                            } else if (location === 'North America') {
                                return locationLower.includes('usa') || locationLower.includes('united states') ||
                                       countryLower.includes('usa') || countryLower.includes('united states');
                            } else if (location === 'Middle East') {
                                return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                       countryLower.includes('dubai') || countryLower.includes('uae');
                            } else if (location === country) {
                                return true;
                            }

                            return false;
                        } else {
                            const normalizedJobLocation = normalizeLocation(jobLocation);
                            const normalizedSearch = normalizeLocation(location);
                            return normalizedJobLocation.includes(normalizedSearch);
                        }
                    });

                    if (!matchesLocation) return false;
                } else if (category === 'grade') {
                    if (!job.grade || !selectedValues.includes(job.grade)) {
                        return false;
                    }
                } else if (category === 'published') {
                    if (!job.published) return false;

                    const jobDays = parseDaysFromPublished(job.published);
                    if (!jobDays) return false;

                    const matchesPublished = selectedValues.some(selectedCategory => {
                        switch(selectedCategory) {
                            case "Last 3 Days":
                                return jobDays <= 3;
                            case "Last 7 Days":
                                return jobDays <= 7;
                            case "Last 14 Days":
                                return jobDays <= 14;
                            case "Last 28 Days":
                                return jobDays <= 28;
                            case "More than 28 Days":
                                return jobDays > 28;
                            default:
                                return false;
                        }
                    });

                    if (!matchesPublished) return false;
                }
            }
        }

        return true;
    });

    currentPage = 1;

    renderJobsList();
    updatePagination();
    updateJobCount();

    // DON'T recalculate all filter counts - just update the display counts
    updateFilterCounts();
    restoreFilterStates();
}

function updateFilterCounts() {
    // For each filter option, we need to count how many jobs would show
    // if that filter was applied IN ADDITION to currently active filters

    // Get current active filters
    const activeFilters = {
        profession: getCheckedProfessions(),
        location: getCheckedLocations(),
        grade: [],
        published: [],
        searchTerm: document.getElementById('keywordSearch').value.toLowerCase().trim()
    };

    // Get active grade filters
    filterData.grade?.forEach(item => {
        const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
        const checkbox = document.getElementById(checkboxId);
        if (checkbox && checkbox.checked) {
            activeFilters.grade.push(item.name);
        }
    });

    // Get active published filters
    filterData.published?.forEach(item => {
        const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
        const checkbox = document.getElementById(checkboxId);
        if (checkbox && checkbox.checked) {
            activeFilters.published.push(item.name);
        }
    });

    // Helper function to test if a job matches all active filters EXCEPT the one being tested
    function jobMatchesOtherFilters(job, excludeCategory, excludeValue) {
        // Check category filter
        if (activeCategoryFilter !== 'all' && !categoryFilters[activeCategoryFilter].filter(job)) {
            return false;
        }

        // Check search term
        if (activeFilters.searchTerm && excludeCategory !== 'search') {
            const sectors = job.sector || [];
            const employer = job.alternate_recruiter_name || job.recruiter_name;
            const matchesSearch = job.job_title.toLowerCase().includes(activeFilters.searchTerm) ||
                                job.location_description.toLowerCase().includes(activeFilters.searchTerm) ||
                                employer.toLowerCase().includes(activeFilters.searchTerm) ||
                                job.short_description.toLowerCase().includes(activeFilters.searchTerm) ||
                                sectors.some(s => s.toLowerCase().includes(activeFilters.searchTerm)) ||
                                (job.grade && job.grade.toLowerCase().includes(activeFilters.searchTerm));
            if (!matchesSearch) return false;
        }

        // Check profession filters
        if (excludeCategory !== 'profession' && activeFilters.profession.length > 0) {
            const sectors = job.sector || [];
            const employer = job.alternate_recruiter_name || job.recruiter_name;
            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
            const matchesProfession = activeFilters.profession.some(profession => {
                return searchText.includes(profession.toLowerCase()) ||
                       sectors.some(s => s.toLowerCase() === profession.toLowerCase());
            });
            if (!matchesProfession) return false;
        }

        // Check location filters
        if (excludeCategory !== 'location' && activeFilters.location.length > 0) {
            const jobLocation = job.location_description || '';
            const matchesLocation = activeFilters.location.some(location => {
                if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                    if (!categoryFilters.overseas.filter(job)) return false;
                    const country = job.location_country || '';
                    const locationLower = jobLocation.toLowerCase();
                    const countryLower = country.toLowerCase();

                    if (location === 'Canada') {
                        return locationLower.includes('canada') || countryLower.includes('canada');
                    } else if (location === 'Australia') {
                        return locationLower.includes('australia') || countryLower.includes('australia');
                    } else if (location === 'New Zealand') {
                        return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                    } else if (location === 'Republic of Ireland') {
                        return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                               !locationLower.includes('northern') && !countryLower.includes('northern');
                    }
                    return countryLower.includes(location.toLowerCase());
                } else {
                    const normalizedJobLocation = normalizeLocation(jobLocation);
                    const normalizedSearch = normalizeLocation(location);
                    return normalizedJobLocation.includes(normalizedSearch);
                }
            });
            if (!matchesLocation) return false;
        }

        // Check grade filters
        if (excludeCategory !== 'grade' && activeFilters.grade.length > 0) {
            if (!job.grade || !activeFilters.grade.includes(job.grade)) {
                return false;
            }
        }

        // Check published filters
        if (excludeCategory !== 'published' && activeFilters.published.length > 0) {
            if (!job.published) return false;
            const jobDays = parseDaysFromPublished(job.published);
            if (!jobDays) return false;
            const matchesPublished = activeFilters.published.some(selectedCategory => {
                switch(selectedCategory) {
                    case "Last 3 Days": return jobDays <= 3;
                    case "Last 7 Days": return jobDays <= 7;
                    case "Last 14 Days": return jobDays <= 14;
                    case "Last 28 Days": return jobDays <= 28;
                    case "More than 28 Days": return jobDays > 28;
                    default: return false;
                }
            });
            if (!matchesPublished) return false;
        }

        return true;
    }

    const activeJobs = filterActiveJobs(allJobsData);

    // Update published counts
    document.querySelectorAll('[id^="published_"]').forEach(checkbox => {
        const label = checkbox.nextElementSibling;
        const countSpan = label.nextElementSibling;
        if (countSpan && countSpan.classList.contains('filter-count')) {
            const filterName = label.textContent.trim();
            const count = activeJobs.filter(job => {
                // First check if job matches all OTHER active filters
                if (!jobMatchesOtherFilters(job, 'published', filterName)) return false;

                // Then check if it would match THIS filter
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                switch(filterName) {
                    case "Last 3 Days": return jobDays <= 3;
                    case "Last 7 Days": return jobDays <= 7;
                    case "Last 14 Days": return jobDays <= 14;
                    case "Last 28 Days": return jobDays <= 28;
                    case "More than 28 Days": return jobDays > 28;
                    default: return false;
                }
            }).length;
            countSpan.textContent = count;
        }
    });

    // Update grade counts
    document.querySelectorAll('[id^="grade_"]').forEach(checkbox => {
        const label = checkbox.nextElementSibling;
        const countSpan = label.nextElementSibling;
        if (countSpan && countSpan.classList.contains('filter-count')) {
            const filterName = label.textContent.trim();
            const count = activeJobs.filter(job => {
                if (!jobMatchesOtherFilters(job, 'grade', filterName)) return false;
                return job.grade === filterName;
            }).length;
            countSpan.textContent = count;
        }
    });

    // Update profession counts
    document.querySelectorAll('.profession-sub-checkbox').forEach(checkbox => {
        const label = checkbox.nextElementSibling;
        const countSpan = label.nextElementSibling;
        if (countSpan && countSpan.classList.contains('filter-count')) {
            const professionName = label.textContent.trim();
            const count = activeJobs.filter(job => {
                if (!jobMatchesOtherFilters(job, 'profession', professionName)) return false;
                const sectors = job.sector || [];
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                return searchText.includes(professionName.toLowerCase()) ||
                       sectors.some(s => s.toLowerCase() === professionName.toLowerCase());
            }).length;
            countSpan.textContent = count;
        }
    });

    // Update location counts
    document.querySelectorAll('.location-checkbox, .location-sub-checkbox').forEach(checkbox => {
        const label = checkbox.nextElementSibling;
        const countSpan = label.nextElementSibling;
        if (countSpan && countSpan.classList.contains('filter-count')) {
            const locationName = label.textContent.trim();
            const count = activeJobs.filter(job => {
                if (!jobMatchesOtherFilters(job, 'location', locationName)) return false;

                if (dynamicLocationHierarchy.Overseas.subcategories.includes(locationName)) {
                    if (!categoryFilters.overseas.filter(job)) return false;
                    const country = job.location_country || '';
                    const location = job.location_description || '';
                    const locationLower = location.toLowerCase();
                    const countryLower = country.toLowerCase();

                    if (locationName === 'Canada') {
                        return locationLower.includes('canada') || countryLower.includes('canada');
                    } else if (locationName === 'Australia') {
                        return locationLower.includes('australia') || countryLower.includes('australia');
                    } else if (locationName === 'New Zealand') {
                        return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                    } else if (locationName === 'Republic of Ireland') {
                        return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                               !locationLower.includes('northern') && !countryLower.includes('northern');
                    }
                    return countryLower.includes(locationName.toLowerCase());
                } else {
                    const jobLocation = job.location_description || '';
                    const normalizedJobLocation = normalizeLocation(jobLocation);
                    const normalizedSearch = normalizeLocation(locationName);
                    return normalizedJobLocation.includes(normalizedSearch);
                }
            }).length;
            countSpan.textContent = count;
        }
    });

    // Update parent profession counts
    document.querySelectorAll('.profession-parent-checkbox').forEach(checkbox => {
        const label = checkbox.nextElementSibling;
        const countSpan = Array.from(checkbox.parentElement.children).find(el =>
            el.classList.contains('filter-count')
        );
        if (countSpan) {
            const parentName = label.textContent.trim();
            const parentData = dynamicProfessionHierarchy[parentName];
            if (parentData) {
                const count = activeJobs.filter(job => {
                    if (!jobMatchesOtherFilters(job, 'profession', parentName)) return false;
                    const sectors = job.sector || [];
                    const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                    return parentData.subcategories.some(subcat => {
                        if (typeof subcat === 'string') {
                            return searchText.includes(subcat.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === subcat.toLowerCase());
                        } else if (typeof subcat === 'object' && subcat.name) {
                            return searchText.includes(subcat.name.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === subcat.name.toLowerCase());
                        }
                        return false;
                    });
                }).length;
                countSpan.textContent = count;
            }
        }
    });
}

function restoreFilterStates() {
    // Store current states before re-render
    const checkedFilters = {};

    // Store profession states
    document.querySelectorAll('.profession-parent-checkbox:checked, .profession-sub-checkbox:checked').forEach(cb => {
        checkedFilters[cb.id] = true;
    });

    // Store location states
    document.querySelectorAll('.location-checkbox:checked, .location-sub-checkbox:checked').forEach(cb => {
        checkedFilters[cb.id] = true;
    });

    // Store other filter states
    document.querySelectorAll('.filter-checkbox:checked').forEach(cb => {
        checkedFilters[cb.id] = true;
    });

    // Restore states after a brief delay to ensure DOM is updated
    setTimeout(() => {
        Object.keys(checkedFilters).forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.checked = true;
            }
        });

        // Update parent checkbox states for hierarchical filters
        document.querySelectorAll('.profession-parent-group').forEach(group => {
            const parentId = group.querySelector('.profession-parent-checkbox').id;
            const parentName = parentId.replace('profession_parent_', '').replace(/_/g, ' ');
            updateParentCheckboxState('profession', parentName);
        });
    }, 10);
}

   function generateDynamicKeywords() {
       const keywordSet = new Set();
       const maxKeywords = 6;

       const activeJobs = filterActiveJobs(allJobsData);

       const professions = [];
       const grades = [];

       activeJobs.forEach(job => {
           if (job.sector && Array.isArray(job.sector)) {
               job.sector.forEach(s => {
                   if (!professions.includes(s)) {
                       professions.push(s);
                   }
               });
           }
           if (job.grade && !grades.includes(job.grade)) {
               grades.push(job.grade);
           }
       });

       const shuffleArray = (array) => {
           const arr = [...array];
           for (let i = arr.length - 1; i > 0; i--) {
               const j = Math.floor(Math.random() * (i + 1));
               [arr[i], arr[j]] = [arr[j], arr[i]];
           }
           return arr;
       };

       const shuffledProfessions = shuffleArray(professions);
       const shuffledGrades = shuffleArray(grades);

       for (let i = 0; i < Math.min(3, shuffledProfessions.length); i++) {
           keywordSet.add(shuffledProfessions[i]);
       }

       for (let i = 0; i < Math.min(3, shuffledGrades.length); i++) {
           keywordSet.add(shuffledGrades[i]);
       }

       keywords = Array.from(keywordSet).slice(0, maxKeywords);
   }

   function initApp() {

   syncJobsData();

    // If still no data, wait for it
    if (!allJobsData || allJobsData.length === 0) {
        if (window.allJobsData && window.allJobsData.length > 0) {
            allJobsData = window.allJobsData;
        } else {
            console.log('No jobs data available yet');
            return;
        }
    }

    filteredJobs = filterActiveJobs(allJobsData);

       calculateFilterCounts();
       generateDynamicKeywords();
       renderKeywords();
       renderFilters();
       renderJobsList();
       updatePagination();
       updateJobCount();
       updateCategoryButtons();
       addEventListeners();
   }

   // Sync global and local allJobsData
function syncJobsData() {
    if (window.allJobsData && window.allJobsData.length > 0) {
        allJobsData = window.allJobsData;
    }
}

   function updateJobCount() {
       const jobCountDisplay = document.getElementById('jobCountDisplay');
       const count = filteredJobs.length;
       jobCountDisplay.textContent = `Found ${count} job${count !== 1 ? 's' : ''}`;
   }

   function renderKeywords() {
       const keywordsList = document.getElementById('keywordsList');
       keywordsList.innerHTML = keywords.map(keyword =>
           `<span class="keyword-tag" onclick="selectKeyword('${keyword}')">${keyword}</span>`
       ).join('');
   }

   function getCurrentPageJobs() {
       const startIndex = (currentPage - 1) * jobsPerPage;
       const endIndex = startIndex + jobsPerPage;
       return filteredJobs.slice(startIndex, endIndex);
   }

   function updatePagination() {
       const totalJobs = filteredJobs.length;
       const totalPages = Math.ceil(totalJobs / jobsPerPage);
       const startJob = totalJobs > 0 ? (currentPage - 1) * jobsPerPage + 1 : 0;
       const endJob = Math.min(currentPage * jobsPerPage, totalJobs);

       document.getElementById('jobRangeStart').textContent = startJob;
       document.getElementById('jobRangeEnd').textContent = endJob;
       document.getElementById('totalJobsCount').textContent = totalJobs;

       const pageNumbersContainer = document.getElementById('pageNumbers');
       let startPage = Math.max(1, currentPage - 3);
       let endPage = Math.min(totalPages, startPage + 6);

       if (endPage - startPage < 6) {
           startPage = Math.max(1, endPage - 6);
       }

       let pageNumbersHTML = '';
       for (let i = startPage; i <= endPage; i++) {
           pageNumbersHTML += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i}</button>`;
       }
       pageNumbersContainer.innerHTML = pageNumbersHTML;

       document.getElementById('firstBtn').disabled = currentPage === 1;
       document.getElementById('prevBtn').disabled = currentPage === 1;
       document.getElementById('nextBtn').disabled = currentPage === totalPages || totalPages === 0;
       document.getElementById('lastBtn').disabled = currentPage === totalPages || totalPages === 0;
   }

   // FIXED renderJobsList function
   function renderJobsList() {
       const jobsList = document.getElementById('jobsList');
       const pageJobs = getCurrentPageJobs();

       if (pageJobs.length === 0) {
           jobsList.innerHTML = '<div class="no-jobs-message">No jobs found matching your criteria.</div>';
           return;
       }

       jobsList.innerHTML = pageJobs.map(job => {
           const employer = job.alternate_recruiter_name || job.recruiter_name || 'Unknown Employer';
           return `
               <div class="job-card">
                   <div class="job-header">${job.job_title}</div>
                   <div class="job-body">
                       ${job.logo_url ? `<img src="${job.logo_url}" alt="${employer} Logo" class="nhs-logo">` : ''}
                       <div class="job-details">
                           <ul>
                               <li><strong>Location:</strong> ${job.location_description}</li>
                               <li><strong>Salary:</strong> ${job.salary || 'Competitive'}</li>
                               <li><strong>Employer:</strong> ${employer}</li>
                           </ul>
                       </div>
                       <div class="job-description">${job.short_description}</div>
                       <button class="apply-btn" onclick="applyToJob(${job.id})">View Details on BMJ Careers</button>
                   </div>
               </div>
           `;
       }).join('');
   }

   // Auto-close dropdowns on window resize
   function handleResize() {
       const currentWidth = window.innerWidth;

       // Close all dropdowns on resize
       const filterGroups = ['published', 'profession', 'grade', 'location'];
       filterGroups.forEach(groupName => {
           const arrow = document.getElementById(groupName + 'Arrow');
           const options = document.getElementById(groupName + 'Options');

           if (arrow && options && !options.classList.contains('collapsed')) {
               options.classList.add('collapsed');
               arrow.classList.add('collapsed');
               arrow.textContent = '‚ñ∂';
           }
       });

       lastWindowWidth = currentWidth;
   }

function addEventListeners() {
    const keywordSearch = document.getElementById('keywordSearch');
    keywordSearch.addEventListener('input', function() {
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            applyFilters();
            updateCategoryButtons(); // Update button states after keyword change
            scrollToTop();
        }, 100);
    });

    keywordSearch.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            clearTimeout(this.searchTimeout);
            applyFilters();
            updateCategoryButtons(); // Update button states after keyword change
            scrollToTop();
        }
    });

    window.addEventListener('scroll', handleScroll);

    // Add resize event listener
    window.addEventListener('resize', handleResize);
}

   // Make initApp globally accessible for API integration
   window.initApp = initApp;

   // Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Only initialize if we already have data
    if (window.allJobsData && window.allJobsData.length > 0) {
        initApp();
        initializeButtonStates(); // Add this line
    }
});


   // Listen for data updates from the API
   window.addEventListener('jobsDataUpdated', function() {
       initApp();
   });

    // Listen for data updates from the server
window.addEventListener('jobsDataLoaded', function() {
    console.log('Jobs data loaded event received');
    syncJobsData();
    initApp();
    initializeButtonStates(); // Add this line
});


// Also check periodically if data is available
let dataCheckInterval = setInterval(function() {
    if (window.allJobsData && window.allJobsData.length > 0) {
        console.log('Jobs data detected:', window.allJobsData.length, 'jobs');
        clearInterval(dataCheckInterval);
        syncJobsData();
        initApp();
    }
}, 500);

// Clear interval after 30 seconds to prevent infinite checking
setTimeout(function() {
    clearInterval(dataCheckInterval);
}, 30000);

</script>
<!-- Cross-Origin Style Communication Script -->
<!-- Add this enhanced section to your existing Cross-Origin Style Communication Script -->
<!-- Replace the existing script section starting at line ~3000 with this enhanced version -->

<script>
    (function() {
        'use strict';

        // Widget configuration
        const WIDGET_CONFIG = {
            widgetId: 'bmj-careers-widget',
            version: '2.0.0' // Updated version for enhanced tracking
        };

        // Detect if running in iframe
        const isInIframe = window.self !== window.top;

        // Security: Configure allowed origins (update for production)
        const ALLOWED_ORIGINS = '*'; // Change to specific domains in production

        // Store custom category configuration from client
        let customCategoryConfig = null;
        let clientTrackingConfig = null;

        // Enhanced tracking data
        const trackingData = {
            sessionId: null,
            clientId: null,
            interactions: [],
            scrollDepth: 0,
            timeOnPage: 0,
            searches: [],
            filterChanges: [],
            jobClicks: []
        };

        // Apply custom categories if provided
        function applyCustomCategories(categories) {
            if (!categories || typeof categories !== 'object') return;

            console.log('Applying custom categories:', categories);
            customCategoryConfig = categories;

            // Update the category buttons
            const categoryButtons = document.querySelectorAll('.category-btn');

            categoryButtons.forEach(btn => {
                const btnId = btn.id;
                const categoryKey = btnId.replace('btn-', '');

                if (categories[categoryKey]) {
                    const config = categories[categoryKey];

                    // Hide or show button
                    if (config.enabled === false) {
                        btn.style.display = 'none';
                    } else {
                        btn.style.display = '';

                        // Update label if provided
                        if (config.label) {
                            const textSpan = btn.querySelector('span:last-child');
                            if (textSpan) {
                                textSpan.textContent = config.label;
                            }
                        }

                        // Update icon if provided
                        if (config.icon) {
                            const emojiSpan = btn.querySelector('.emoji');
                            if (emojiSpan) {
                                emojiSpan.textContent = config.icon;
                            }
                        }
                    }
                }
            });

            // Override the category filters
            if (window.categoryFilters) {
                Object.keys(categories).forEach(key => {
                    const config = categories[key];
                    if (config.enabled !== false && window.categoryFilters[key]) {
                        // Create custom filter function
                        const originalFilter = window.categoryFilters[key].filter;

                        window.categoryFilters[key] = {
                            name: config.label || window.categoryFilters[key].name,
                            keywords: config.keywords || [],
                            filter: function(job) {
                                // If no custom keywords, use original filter
                                if (!config.keywords || config.keywords.length === 0) {
                                    return originalFilter ? originalFilter(job) : true;
                                }

                                // Build search text based on searchIn configuration
                                let searchText = '';
                                const searchIn = config.searchIn || ['title', 'description', 'sector', 'grade'];

                                searchIn.forEach(field => {
                                    switch(field) {
                                        case 'title':
                                            searchText += ' ' + (job.job_title || '');
                                            break;
                                        case 'description':
                                            searchText += ' ' + (job.short_description || '');
                                            break;
                                        case 'sector':
                                            if (job.sector && Array.isArray(job.sector)) {
                                                searchText += ' ' + job.sector.join(' ');
                                            }
                                            break;
                                        case 'grade':
                                            searchText += ' ' + (job.grade || '');
                                            break;
                                        case 'location':
                                            searchText += ' ' + (job.location_description || '');
                                            break;
                                        case 'employer':
                                            searchText += ' ' + (job.recruiter_name || '') + ' ' + (job.alternate_recruiter_name || '');
                                            break;
                                    }
                                });

                                searchText = searchText.toLowerCase();

                                // Check if any keyword matches
                                return config.keywords.some(keyword =>
                                    searchText.includes(keyword.toLowerCase())
                                );
                            }
                        };
                    }
                });
            }
        }

function initializeButtonStates() {
    // Check if we have any active filters on load
    const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
    const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;

    // If no filters are active and category is 'all', ensure button is active
    if (!searchTerm && !hasCheckedFilters && activeCategoryFilter === 'all') {
        document.getElementById('btn-all').classList.add('active');
    } else if (activeCategoryFilter === 'all') {
        // If filters exist but category is 'all', remove active state
        document.getElementById('btn-all').classList.remove('active');
    }

    updateCategoryButtons();
}

        // Enhanced tracking functions
        function initializeTracking(config) {
            if (!config || !config.tracking) return;

            trackingData.sessionId = config.tracking.sessionId;
            trackingData.clientId = config.tracking.clientId;
            clientTrackingConfig = config.tracking.features || {};

            console.log('Tracking initialized:', trackingData.sessionId);

            // Start tracking various events
            if (clientTrackingConfig.trackInteractions) {
                trackInteractions();
            }

            if (clientTrackingConfig.trackScrollDepth) {
                trackScrollDepth();
            }

            if (clientTrackingConfig.trackSearches) {
                trackSearches();
            }

            if (clientTrackingConfig.trackFilters) {
                trackFilterChanges();
            }
        }

        function trackInteractions() {
            document.addEventListener('click', function(e) {
                const target = e.target;
                const data = {
                    element: target.tagName,
                    className: target.className,
                    id: target.id,
                    text: target.innerText?.substring(0, 50)
                };

                trackingData.interactions.push(data);
                sendTrackingEvent('interaction', data);
            });
        }

        function trackScrollDepth() {
            let maxScroll = 0;
            window.addEventListener('scroll', debounce(function() {
                const scrollPercentage = Math.round((window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100);
                if (scrollPercentage > maxScroll) {
                    maxScroll = scrollPercentage;
                    trackingData.scrollDepth = maxScroll;
                    sendTrackingEvent('scroll', { depth: maxScroll });
                }
            }, 500));
        }

        function trackSearches() {
            const searchInput = document.getElementById('keywordSearch');
            if (searchInput) {
                searchInput.addEventListener('change', function() {
                    const searchTerm = this.value;
                    trackingData.searches.push({
                        term: searchTerm,
                        timestamp: Date.now()
                    });
                    sendTrackingEvent('search', { searchTerm });
                });
            }
        }

        function trackFilterChanges() {
            // Track category button clicks
            document.addEventListener('click', function(e) {
                if (e.target.closest('.category-btn')) {
                    const btn = e.target.closest('.category-btn');
                    const categoryId = btn.id.replace('btn-', '');
                    sendTrackingEvent('filter_change', {
                        filterType: 'category',
                        filterValue: categoryId
                    });
                }

                // Track other filter changes
                if (e.target.matches('.filter-checkbox, .profession-sub-checkbox, .location-sub-checkbox')) {
                    sendTrackingEvent('filter_change', {
                        filterType: e.target.className,
                        filterValue: e.target.id,
                        checked: e.target.checked
                    });
                }
            });
        }

        function sendTrackingEvent(eventType, data) {
            if (!isInIframe) return;

            window.parent.postMessage({
                type: 'bmj-careers-event',
                eventType: eventType,
                data: data,
                timestamp: Date.now()
            }, '*');
        }

        // Override the applyToJob function to track job clicks
        const originalApplyToJob = window.applyToJob;
window.applyToJob = function(jobId) {
    const job = allJobsData.find(j => j.id === jobId);

    // Send tracking event to parent if in iframe
    if (window.self !== window.top) {
        window.parent.postMessage({
            type: 'bmj-careers-job-click',
            jobId: jobId,
            jobTitle: job?.job_title || 'Unknown',
            employer: job?.recruiter_name || job?.alternate_recruiter_name || 'Unknown'
        }, '*');
    }

    if (job && job.job_url) {
        window.open(job.job_url, '_blank', 'noopener,noreferrer');
    } else {
        window.open('https://www.bmj.com/careers/jobs/', '_blank', 'noopener,noreferrer');
    }
};

        // Override applyCategoryFilter to use custom configuration
        const originalApplyCategoryFilter = window.applyCategoryFilter;
window.applyCategoryFilter = function(category) {
    activeCategoryFilter = category;

    // Send tracking event to parent if in iframe
    if (window.self !== window.top) {
        window.parent.postMessage({
            type: 'bmj-careers-filter-change',
            filterType: 'category',
            filterValue: category
        }, '*');
    }

    updateCategoryButtons();

    // If "All Jobs" is selected, reset everything
    if (category === 'all') {
        // Clear keyword search
        document.getElementById('keywordSearch').value = '';

        // Uncheck all filter checkboxes
        document.querySelectorAll('.filter-checkbox, .profession-parent-checkbox, .profession-sub-checkbox, .location-checkbox, .location-sub-checkbox').forEach(checkbox => {
            checkbox.checked = false;
            checkbox.classList.remove('indeterminate');
        });

        // Ensure All Jobs button gets active state
        document.getElementById('btn-all').classList.add('active');
    }

    applyFilters();
    scrollToTop();
};


        // Performance: Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Enhanced message handler
        window.addEventListener('message', function(event) {
            // Security check
            if (!isAllowedOrigin(event.origin)) {
                console.warn('Rejected message from unauthorized origin:', event.origin);
                return;
            }

            if (!event.data || typeof event.data !== 'object') return;

            switch (event.data.type) {
                case 'bmj-careers-config':
                    // Apply full configuration
                    if (event.data.styles) {
                        applyCustomStyles(event.data.styles);
                    }
                    if (event.data.categories) {
                        applyCustomCategories(event.data.categories);
                    }
                    if (event.data.tracking) {
                        initializeTracking(event.data);
                    }
                    break;

                case 'bmj-careers-styles':
                    applyCustomStyles(event.data.styles);
                    break;

                case 'bmj-careers-categories':
                    applyCustomCategories(event.data.categories);
                    break;

                case 'bmj-careers-command':
                    handleCommand(event.data.command, event.data.data);
                    break;

                case 'bmj-careers-tracking':
                    // Handle tracking data from parent
                    if (event.data.eventType === 'heartbeat') {
                        trackingData.timeOnPage = event.data.data.timeOnPage;
                    }
                    break;
            }
        });

        // Security: Validate message origin
        function isAllowedOrigin(origin) {
            if (ALLOWED_ORIGINS === '*') return true;
            return ALLOWED_ORIGINS.includes(origin);
        }

        // Keep existing applyCustomStyles function
        const applyCustomStyles = (function() {
            let styleElement = null;

            return function(styles) {
                // ... keep your existing style application code ...
                // This remains unchanged from your current implementation
            };
        })();

        // Handle commands
        function handleCommand(command, data) {
            switch(command) {
                case 'refresh':
                    location.reload();
                    break;
                case 'scrollToTop':
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    break;
                case 'requestConfig':
                    // Send current configuration back
                    window.parent.postMessage({
                        type: 'bmj-careers-current-config',
                        categories: customCategoryConfig,
                        tracking: trackingData
                    }, '*');
                    break;
            }
        }

        // Send ready message with enhanced capabilities
        function sendReadyMessage() {
            window.parent.postMessage({
                type: 'bmj-careers-ready',
                widgetId: WIDGET_CONFIG.widgetId,
                version: WIDGET_CONFIG.version,
                isInIframe: isInIframe,
                capabilities: {
                    customCategories: true,
                    enhancedTracking: true,
                    customStyles: true
                }
            }, '*');

            // Request configuration from parent
            if (isInIframe) {
                setTimeout(() => {
                    window.parent.postMessage({
                        type: 'bmj-careers-request-config',
                        widgetId: WIDGET_CONFIG.widgetId
                    }, '*');
                }, 100);
            }

            console.log('BMJ Careers Widget initialized with enhanced features v2.0');
        }

        // Send ready on load
        if (document.readyState === 'complete') {
            sendReadyMessage();
        } else {
            window.addEventListener('load', sendReadyMessage);
            document.addEventListener('DOMContentLoaded', sendReadyMessage);
        }

        // Export for debugging
        window.BMJWidgetTracking = {
            getData: () => trackingData,
            getConfig: () => customCategoryConfig,
            sendEvent: sendTrackingEvent
        };
    })();
</script>
<!-- End Cross-Origin Style Communication Script -->
</body>
</html>
