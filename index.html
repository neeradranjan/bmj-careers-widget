<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse and search medical job opportunities across the UK and internationally. Find consultant, GP, specialist, and healthcare positions with BMJ Careers.">
    <meta name="keywords" content="medical jobs, healthcare careers, NHS jobs, consultant positions, GP vacancies, medical recruitment, BMJ careers">
    <meta name="author" content="BMJ Careers">
    <meta name="robots" content="index, follow">
    <title>BMJ Careers - Medical Jobs</title>

    <!-- Resource hints for performance -->
    <link rel="preconnect" href="https://www.bmj.com" crossorigin>
    <link rel="dns-prefetch" href="https://www.bmj.com">

    <!-- Inline critical CSS -->
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; }
        .main-wrapper { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); display: flex; align-items: center; justify-content: center; z-index: 9999; }

        /* Updated styles for job count display inside jobs section */
.job-count-header {
    margin-bottom: 0.5rem;
    padding: 0.4rem 0.75rem;
    background: #ffffff;
    border-radius: 6px;
    animation: fadeInDown 0.6s ease-out;
}

.job-count-main {
    background: linear-gradient(135deg, #0066cc 0%, #004c99 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 600;
    font-size: 0.875rem; /* Reduced from 1.25rem */
    letter-spacing: -0.01em;
    animation: shimmer 3s ease-in-out infinite;
}
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translate3d(0, -20px, 0);
            }
            to {
                opacity: 1;
                transform: translate3d(0, 0, 0);
            }
        }

        @keyframes shimmer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Improved pagination disabled button contrast */
        .pagination-btn:disabled {
            color: #4a5568;
            cursor: not-allowed;
            opacity: 0.7;
            background: #e2e8f0;
            border-color: #cbd5e0;
        }

        /* Keyboard navigation for keywords */
        .keyword-tag {
            background: linear-gradient(135deg, #e6f2ff 0%, #cce4ff 100%);
            color: #0066cc;
            padding: 0.375rem 0.875rem;
            border-radius: 8px;
            font-size: 0.8125rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            font-weight: 500;
            display: inline-block;
            margin: 0.25rem;
        }

        .keyword-tag:focus {
            outline: 2px solid #0066cc;
            outline-offset: 2px;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        .keyword-tag:hover {
            background: linear-gradient(135deg, #0066cc 0%, #0052a3 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        /* Date Published Radio-like behavior styles */
        .published-filter-item {
            display: flex;
            align-items: center;
            padding: 0.625rem 0.5rem;
            font-size: 0.875rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .published-filter-item:hover {
            background: #f3f4f6;
            transform: translateX(4px);
        }

        /* Accessibility improvement for filter sections */
        .filter-group[role="region"] {
            position: relative;
        }

        .filter-header:focus {
            outline: 2px solid #0066cc;
            outline-offset: 2px;
        }
    </style>

    <!-- Defer non-critical CSS -->
    <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="styles.css"></noscript>
</head>
<body>
<script>
    // Prevent console errors from undefined variables
    window.allJobsData = window.allJobsData || [];
    window.filteredJobs = window.filteredJobs || [];
    window.activeCategoryFilter = window.activeCategoryFilter || 'all';

    // Handle localStorage safely
    const safeStorage = {
        getItem: (key) => {
            try {
                return localStorage.getItem(key);
            } catch (e) {
                return null;
            }
        },
        setItem: (key, value) => {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                // Silently fail - storage might be blocked
            }
        }
    };

    // Replace sessionStorage usage with safeStorage
    if (!window.sessionStorage) {
        window.sessionStorage = safeStorage;
    }
</script>

<div class="main-wrapper">
    <nav class="category-buttons-wrapper" role="navigation" aria-label="Job category filters">
        <div class="category-buttons">
            <button class="category-btn active" onclick="applyCategoryFilter('all')" id="btn-all">
                <span class="emoji" aria-hidden="true">&#x1F3E5;</span>
                <span>All Jobs</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('consultant')" id="btn-consultant">
                <span class="emoji" aria-hidden="true">&#x1F468;&#x200D;&#x2695;&#xFE0F;</span>
                <span>Consultant</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('gp')" id="btn-gp">
                <span class="emoji" aria-hidden="true">&#x1FA7A;</span>
                <span>GP</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('overseas')" id="btn-overseas">
                <span class="emoji" aria-hidden="true">&#x1F30D;</span>
                <span>Overseas</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('training')" id="btn-training">
                <span class="emoji" aria-hidden="true">&#x1F393;</span>
                <span>Academic</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('special')" id="btn-special">
                <span class="emoji" aria-hidden="true">&#x26A1;</span>
                <span>Special</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('research')" id="btn-research">
                <span class="emoji" aria-hidden="true">&#x1F52C;</span>
                <span>Research</span>
            </button>
        </div>
    </nav>

    <div class="content-container">
        <aside class="sidebar" id="sidebar" role="complementary" aria-label="Job search and filters">
            <div class="search-section">
                <h3 class="search-title">Keyword Search</h3>
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="keywordSearch" placeholder="Enter keywords..." aria-label="Keyword search">
                    <button class="clear-keyword-btn" id="clearKeywordBtn" onclick="clearKeywordSearch()" aria-label="Clear search">×</button>
                </div>

                <div class="keywords-section">
                    <label class="keywords-label" id="keywords-label">Popular Keywords</label>
                    <div class="keywords-list" id="keywordsList" role="list" aria-labelledby="keywords-label">
                    </div>
                </div>
            </div>

            <div class="filters-section">
                <h3 class="filters-title">Filter By Category</h3>
                <div id="filtersContainer">
                </div>
            </div>
        </aside>

        <main class="main-content" role="main" aria-label="Job search results">
            <div class="jobs-section">
                <div class="job-count-header" id="jobCountDisplay">
                    <!-- Dynamic job count will be displayed here -->
                </div>
                <div id="jobsList">
                </div>
            </div>

            <div class="pagination-section">
                <div class="pagination-info">
                    Showing <span id="jobRangeStart">1</span>-<span id="jobRangeEnd">6</span> of <span id="totalJobsCount">0</span> jobs
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" id="firstBtn" onclick="goToPage(1)" aria-label="Go to first page">First</button>
                    <button class="pagination-btn" id="prevBtn" onclick="goToPage(getCurrentPage() - 1)" aria-label="Go to previous page">‹</button>
                    <span id="pageNumbers"></span>
                    <button class="pagination-btn" id="nextBtn" onclick="goToPage(getCurrentPage() + 1)" aria-label="Go to next page">›</button>
                    <button class="pagination-btn" id="lastBtn" onclick="goToPage(Math.ceil(filteredJobs.length / jobsPerPage))" aria-label="Go to last page">Last</button>
                </div>
            </div>
        </main>
    </div>
</div>

<button class="scroll-to-top" id="scrollToTop" title="Move To Top" onclick="scrollToTop()" aria-label="Scroll to top">
    ↑
</button>

<script>
    // Performance utilities
    const perfUtils = {
        debounce: function(func, wait, immediate) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    timeout = null;
                    if (!immediate) func(...args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func(...args);
            };
        },

        throttle: function(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
    };

    // Initialize with empty array - will be populated by API
    let allJobsData = [];
    window.allJobsData = allJobsData;

    // Track active filters for dynamic job count display
    let activeFiltersForDisplay = {
        category: null,
        searchTerm: '',
        professions: [],
        locations: [],
        grades: [],
        published: null
    };

    // Lazy load hierarchies to reduce initial bundle size
    let professionHierarchy = null;
    let locationHierarchy = null;
    let dynamicProfessionHierarchy = {};
    let dynamicLocationHierarchy = {};

    function initializeHierarchies() {
        professionHierarchy = {
            'GP': { subcategories: [] },
            'Specialist Doctor': { subcategories: [] },
            'Other Medical Roles': { subcategories: [] },
            'Nurse': { subcategories: [] },
            'Mental Health Professional': { subcategories: [] },
            'Pharmacist': { subcategories: [] },
            'Physician Associate': { subcategories: [] },
            'Senior Manager': { subcategories: [] },
            'Other Health Profession': { subcategories: [] }
        };

        locationHierarchy = {
            'London': { subcategories: [] },
            'South East England': { subcategories: [] },
            'South West England': { subcategories: [] },
            'East of England': { subcategories: [] },
            'East Midlands': { subcategories: [] },
            'West Midlands': { subcategories: [] },
            'Yorkshire and the Humber': { subcategories: [] },
            'North West England': { subcategories: [] },
            'North East England': { subcategories: [] },
            'Scotland': { subcategories: [] },
            'Wales': { subcategories: [] },
            'Northern Ireland': { subcategories: [] },
            'Overseas': { subcategories: [] }
        };
    }

    // Initialize hierarchies
    initializeHierarchies();

    // Full hierarchy data - loaded asynchronously
    function loadFullHierarchies() {
        // Full profession hierarchy
        professionHierarchy['GP'].subcategories = [
            'Digital GP',
            'GP Partner',
            'GP Trainee',
            'Locum GP',
            'Salaried GP'
        ];

        professionHierarchy['Specialist Doctor'].subcategories = [
            'Acute Internal Medicine',
            'Adult Critical Care',
            'Anaesthesia',
            'Anatomy',
            'Audiological Medicine',
            'BioChemistry',
            'Cardiology',
            'Cardiothoracic Surgery',
            'Cytopathology',
            'Dermatology',
            'Diabetes & Endocrinology',
            'Emergency medicine',
            'ENT/Otolaryngology',
            'Forensic Pathology',
            'Gastroenterology',
            'General Internal Medicine',
            'General Surgery',
            'Genetics',
            'Genitourinary Medicine',
            'Geriatric Medicine',
            'GP in Emergency Medicine',
            'Gynaecological Oncology',
            'Haematology',
            'Hepatology',
            'Histopathology',
            'Immunology',
            'Intensive and Critical Care Medicine',
            'Locum Doctor',
            'Maternal and Foetal Medicine',
            'Metabolic Medicine',
            'Microbiology, Virology and Infectious Diseases',
            'Neonatology',
            'Nephrology/Renal Medicine',
            'Neurology',
            'Neuropathology',
            'Neurophysiology',
            'Neurosurgery',
            'Nuclear Medicine',
            'Obstetrics and Gynaecology',
            'Occupational Medicine',
            'Oncology',
            'Ophthalmology',
            'Oral and Maxillofacial Surgery',
            {
                name: 'Paediatrics',
                subcategories: [
                    'Paediatric cardiology',
                    'Paediatric diabetes and endocrinology',
                    'Paediatric emergency medicine',
                    'Paediatric gastroenterology, Hepatology and Nutrition',
                    'Paediatric immunology, infectious diseases and allergy',
                    'Paediatric intensive Care Medicine',
                    'Paediatric nephrology',
                    'Paediatric neurodisability',
                    'Paediatric neurology',
                    'Paediatric oncology',
                    'Paediatric palliative Medicine',
                    'Paediatric pathology',
                    'Paediatric respiratory medicine',
                    'Paediatric rheumatology',
                    'Paediatric surgery'
                ]
            },
            'Palliative medicine',
            'Pathology',
            'Pharmaceutical medicine',
            'Pharmalogy and Therapeutics',
            'Physiology',
            'Plastic Surgery',
            'Pre Hospital Emergency Medicine',
            {
                name: 'Psychiatry',
                subcategories: [
                    'Child and Adolescent Psychiatry',
                    'Community Psychiatry',
                    'Forensic Psychiatry',
                    'General Adult Psychiatry',
                    'Liaison Psychiatry',
                    'Medical Psychotherapy',
                    'Old-age Psychiatry',
                    'Psychiatry of eating disorders',
                    'Psychiatry of learning disablity',
                    'Rehabilition Psychiatry',
                    'Substance Misuse Psychiatry'
                ]
            },
            'Public Health Medicine and Epidemiology',
            'Radiology',
            'Rahabilitation Medicine',
            'Respiratory Medicine',
            'Rheumatology',
            'RMO',
            'Sexual and Reproductive Health',
            'Spinal Injuries',
            'Sports and Exercise Medicine',
            'Stroke Medicine',
            'Trauma and Orthopaedics',
            'Tropical Medicine',
            'Urogynaecology',
            'Urology',
            'Vascular Surgery'
        ];

        professionHierarchy['Other Medical Roles'].subcategories = [
            'Armed Forces Doctor',
            'Commissioning',
            'Government and Health Policy',
            'Healthtech',
            'International medical Jobs',
            'Medical Education and Training',
            'Medical Examiner',
            'Medical leadership',
            'Medical training Initiative',
            'Medico-legal',
            'Occupational health',
            'Pharmaceutical',
            'Public Health',
            'Special Appointements'
        ];

        professionHierarchy['Nurse'].subcategories = [
            {
                name: 'Adult Nurse',
                subcategories: [
                    'A&E Nurse',
                    'Acute Nurse',
                    'Anaesthesia Nurse',
                    'Cancer Nurse',
                    'Cardiology Nurse',
                    'Elderly Care Nurse',
                    'Fertility Nurse',
                    'ICU Nurse',
                    'Ophthalmics Nurse',
                    'Palliative Care Nurse',
                    'Renal Nurse',
                    'Respiratory Nurse',
                    'Sexual Health Nurse',
                    'Theatre Nurse',
                    'Trauma Nurse'
                ]
            },
            {
                name: 'Community Nurse',
                subcategories: [
                    'Care Home Nurse',
                    'Community MidWife',
                    'District Nurse',
                    'Health Visitor',
                    'Mental Health Nurse - Community',
                    'School Nurse'
                ]
            },
            'General Practice Nurse',
            'Learning Disablity Nurse',
            {
                name: 'Mental Health Nurse',
                subcategories: [
                    'Adult Mental Health Nurse',
                    'CAMHS Nurse',
                    'Community Mental Health Nurse',
                    'Eating Disorders Nurse',
                    'Forensic Mental Health Nurse',
                    'Mental Health Liaison Nurse',
                    'Mental health Nurse in Primary care',
                    'Old Age Mental Health Care Nurse',
                    'Perinatal Mental Health Nurse',
                    'Rehabilitation Mental Health Nurse',
                    'Substance Misuse Nurse'
                ]
            },
            'Midwife',
            'Nurse associate',
            {
                name: 'Paediatric Nurse',
                subcategories: [
                    'Neonatal Nurse',
                    'Paediatric A&E Nurse'
                ]
            },
            'Prison Nurse'
        ];

        professionHierarchy['Mental Health Professional'].subcategories = [
            'CBT Therapist',
            'Counsellor',
            'Mental health Practitioner',
            'Psychologist',
            'Psychotherapist'
        ];

        professionHierarchy['Pharmacist'].subcategories = [
            'Pharmacy technician'
        ];

        // Full location hierarchy (keeping existing data)
        locationHierarchy['London'].subcategories = [
            'Central London',
            'North London',
            'South London',
            'East London',
            'West London',
            'Greater London'
        ];

        locationHierarchy['South East England'].subcategories = [
    'Brighton',
    'Canterbury',
    'Oxford',
    'Reading',
    'Southampton',
    'Portsmouth',
    'Guildford',
    'Maidstone',
    'Crawley',
    'Slough',
    'Milton Keynes',
    'Luton',
    'Medway',
    'Ashford',
    'Basingstoke',
    'Eastbourne',
    'Hastings',
    'Worthing',
    'Bracknell',
    'Maidenhead',
    'Windsor',
    'Berkshire',
    'Buckinghamshire',
    'East Sussex',
    'Hampshire',
    'Isle of Wight',
    'Kent',
    'Oxfordshire',
    'Surrey',
    'West Sussex'
];

locationHierarchy['South West England'].subcategories = [
    'Bristol',
    'Plymouth',
    'Bournemouth',
    'Swindon',
    'Gloucester',
    'Exeter',
    'Bath',
    'Cheltenham',
    'Torbay',
    'Poole',
    'Taunton',
    'Salisbury',
    'Truro',
    'Weymouth',
    'Weston-super-Mare',
    'Yeovil',
    'Barnstaple',
    'Bridgwater',
    'Cornwall',
    'Devon',
    'Dorset',
    'Gloucestershire',
    'Somerset',
    'Wiltshire'
];

locationHierarchy['East of England'].subcategories = [
    'Cambridge',
    'Norwich',
    'Peterborough',
    'Ipswich',
    'Colchester',
    'Southend-on-Sea',
    'Luton',
    'Watford',
    'St Albans',
    'Chelmsford',
    'Basildon',
    'Harlow',
    'Stevenage',
    'Bedford',
    'Bury St Edmunds',
    'Hertford',
    'Huntingdon',
    'Kings Lynn',
    'Lowestoft',
    'Bedfordshire',
    'Cambridgeshire',
    'Essex',
    'Hertfordshire',
    'Norfolk',
    'Suffolk'
];

locationHierarchy['East Midlands'].subcategories = [
    'Nottingham',
    'Leicester',
    'Derby',
    'Northampton',
    'Lincoln',
    'Mansfield',
    'Chesterfield',
    'Kettering',
    'Loughborough',
    'Boston',
    'Grantham',
    'Corby',
    'Hinckley',
    'Newark',
    'Wellingborough',
    'Derbyshire',
    'Leicestershire',
    'Lincolnshire',
    'Northamptonshire',
    'Nottinghamshire',
    'Rutland'
];

locationHierarchy['West Midlands'].subcategories = [
    'Birmingham',
    'Coventry',
    'Wolverhampton',
    'Stoke-on-Trent',
    'Solihull',
    'Walsall',
    'Dudley',
    'Sandwell',
    'Worcester',
    'Shrewsbury',
    'Telford',
    'Stafford',
    'Warwick',
    'Hereford',
    'Stratford-upon-Avon',
    'Lichfield',
    'Tamworth',
    'Redditch',
    'Kidderminster',
    'Herefordshire',
    'Shropshire',
    'Staffordshire',
    'Warwickshire',
    'Worcestershire'
];

locationHierarchy['Yorkshire and the Humber'].subcategories = [
    'Leeds',
    'Sheffield',
    'Bradford',
    'Hull',
    'York',
    'Huddersfield',
    'Middlesbrough',
    'Doncaster',
    'Rotherham',
    'Wakefield',
    'Barnsley',
    'Halifax',
    'Harrogate',
    'Scarborough',
    'Dewsbury',
    'Keighley',
    'Scunthorpe',
    'Grimsby',
    'East Yorkshire',
    'North Yorkshire',
    'South Yorkshire',
    'West Yorkshire'
];

locationHierarchy['North West England'].subcategories = [
    'Manchester',
    'Liverpool',
    'Warrington',
    'Bolton',
    'Blackpool',
    'Preston',
    'Chester',
    'Stockport',
    'Oldham',
    'Rochdale',
    'Salford',
    'Wigan',
    'Bury',
    'Blackburn',
    'St Helens',
    'Carlisle',
    'Lancaster',
    'Crewe',
    'Burnley',
    'Macclesfield',
    'Barrow-in-Furness',
    'Runcorn',
    'Ellesmere Port',
    'Cheshire',
    'Cumbria',
    'Greater Manchester',
    'Lancashire',
    'Merseyside'
];

locationHierarchy['North East England'].subcategories = [
    'Newcastle upon Tyne',
    'Sunderland',
    'Durham',
    'Gateshead',
    'Middlesbrough',
    'Stockton-on-Tees',
    'Darlington',
    'Hartlepool',
    'South Shields',
    'Tynemouth',
    'Washington',
    'Ashington',
    'Blyth',
    'Redcar',
    'Bishop Auckland',
    'County Durham',
    'Northumberland',
    'Tyne and Wear',
    'Teesside'
];

locationHierarchy['Scotland'].subcategories = [
    'Edinburgh',
    'Glasgow',
    'Aberdeen',
    'Dundee',
    'Inverness',
    'Perth',
    'Stirling',
    'Paisley',
    'East Kilbride',
    'Livingston',
    'Hamilton',
    'Cumbernauld',
    'Dunfermline',
    'Kirkcaldy',
    'Ayr',
    'Kilmarnock',
    'Greenock',
    'Coatbridge',
    'Glenrothes',
    'Falkirk'
];

locationHierarchy['Wales'].subcategories = [
    'Cardiff',
    'Swansea',
    'Newport',
    'Wrexham',
    'Barry',
    'Neath',
    'Cwmbran',
    'Llanelli',
    'Rhondda',
    'Merthyr Tydfil',
    'Bridgend',
    'Caerphilly',
    'Port Talbot',
    'Pontypridd',
    'Aberdare',
    'Colwyn Bay',
    'Rhyl',
    'Flintshire',
    'Gwynedd',
    'Anglesey'
];

locationHierarchy['Northern Ireland'].subcategories = [
    'Belfast',
    'Derry',
    'Lisburn',
    'Newtownabbey',
    'Bangor',
    'Craigavon',
    'Castlereagh',
    'Ballymena',
    'Newtownards',
    'Newry',
    'Carrickfergus',
    'Coleraine',
    'Omagh',
    'Larne',
    'Banbridge',
    'Armagh',
    'Dungannon',
    'Enniskillen',
    'Strabane',
    'Antrim'
];

locationHierarchy['Overseas'].subcategories = [
    'Republic of Ireland',
    'Channel Islands',
    'Isle of Man',
    'Europe',
    'Middle East',
    'Asia Pacific',
    'North America',
    'South America',
    'Africa',
    'Australia',
    'New Zealand',
    'Other International'
];

        // Update dynamic hierarchies
       dynamicProfessionHierarchy = JSON.parse(JSON.stringify(professionHierarchy));
        dynamicLocationHierarchy = JSON.parse(JSON.stringify(locationHierarchy));

        console.log('Full hierarchies loaded');
    }

    // Load full hierarchies after page loads
    if ('requestIdleCallback' in window) {
        requestIdleCallback(() => loadFullHierarchies(), { timeout: 2000 });
    } else {
        setTimeout(() => loadFullHierarchies(), 500);
    }

    let filterData = {};
    let keywords = [];
    let currentPage = 1;
    const jobsPerPage = 10;
    let filteredJobs = [];
    let activeCategoryFilter = 'all';
    let lastWindowWidth = window.innerWidth;

    const categoryFilters = {
        all: {
            name: 'All Jobs',
            keywords: [],
            filter: () => true
        },
        consultant: {
            name: 'Consultant',
            keywords: ['consultant'],
            filter: (job) => {
                const jobTitle = (job.job_title || '').toLowerCase();
                const grade = (job.grade || '').toLowerCase();
                return jobTitle.includes('consultant') || grade.includes('consultant');
            }
        },
        gp: {
            name: 'GP',
            keywords: ['gp'],
            filter: (job) => {
                const sectors = job.sector || [];
                return sectors.some(sector =>
                    sector.toLowerCase().includes('gp')
                );
            }
        },
        overseas: {
            name: 'Overseas',
            keywords: [],
            filter: (job) => {
                const country = (job.location_country || '').toLowerCase().trim();
                const locationDesc = (job.location_description || '').toLowerCase().trim();

                const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales', 'northern ireland',
                                   'britain', 'great britain', 'gb', 'u.k.', 'united kindom'];

                if (country && country.length > 0) {
                    const isUK = ukCountries.some(ukVariant => country.includes(ukVariant));
                    if (!isUK) {
                        return true;
                    }
                }

                const overseasIndicators = [
                    'australia', 'new zealand', 'canada', 'usa', 'united states', 'america',
                    'dubai', 'uae', 'emirates', 'singapore', 'hong kong', 'japan', 'china',
                    'india', 'germany', 'france', 'spain', 'italy', 'netherlands', 'belgium',
                    'switzerland', 'norway', 'sweden', 'denmark', 'ireland', 'dublin',
                    'sydney', 'melbourne', 'brisbane', 'perth', 'adelaide', 'auckland',
                    'wellington', 'toronto', 'vancouver', 'montreal'
                ];

                for (const indicator of overseasIndicators) {
                    if (indicator === 'ireland' && (locationDesc.includes('northern') || country.includes('northern'))) {
                        continue;
                    }
                    if (locationDesc.includes(indicator)) {
                        return true;
                    }
                }

                const ukRegions = ['london', 'manchester', 'birmingham', 'leeds', 'glasgow',
                                  'edinburgh', 'cardiff', 'belfast', 'liverpool', 'bristol',
                                  'sheffield', 'newcastle', 'nottingham', 'southampton', 'oxford',
                                  'cambridge', 'brighton', 'leicester', 'coventry', 'hull'];

                const hasUKRegion = ukRegions.some(region => locationDesc.includes(region));
                if (hasUKRegion) {
                    return false;
                }

                if (country && country.length > 0) {
                    return !ukCountries.some(ukVariant => country.includes(ukVariant));
                }

                return false;
            }
        },
        training: {
            name: 'Academic',
            keywords: ['medical education', 'training', 'lecturer', 'professor'],
            filter: (job) => {
                const sectors = job.sector || [];
                const grade = (job.grade || '').toLowerCase();

                const hasEducationSector = sectors.some(sector =>
                    sector.toLowerCase().includes('medical education') &&
                    sector.toLowerCase().includes('training')
                );

                const hasAcademicGrade = grade.includes('lecturer') || grade.includes('professor');

                return hasEducationSector || hasAcademicGrade;
            }
        },
        special: {
            name: 'Special',
            keywords: ['special appointments'],
            filter: (job) => {
                const sectors = job.sector || [];
                return sectors.some(sector =>
                    sector.toLowerCase().includes('special appointments')
                );
            }
        },
        research: {
            name: 'Research',
            keywords: ['medical research'],
            filter: (job) => {
                const sectors = job.sector || [];
                return sectors.some(sector =>
                    sector.toLowerCase().includes('medical research')
                );
            }
        }
    };


 function generateJobCountText() {
        const count = filteredJobs.length;
        const searchTerm = document.getElementById('keywordSearch').value.trim();
        const checkedProfessions = getCheckedProfessions();
        const checkedLocations = getCheckedLocations();
        const checkedGrades = getCheckedGrades();

        // Build job type descriptor
        const jobTypeDescriptor = [];

        // Add category filter if active
        if (activeCategoryFilter && activeCategoryFilter !== 'all') {
            jobTypeDescriptor.push(categoryFilters[activeCategoryFilter].name);
        }

        // FIXED: Add grade filters properly
        if (checkedGrades.length > 0) {
            if (checkedGrades.length === 1) {
                jobTypeDescriptor.push(checkedGrades[0]);
            } else if (checkedGrades.length === 2) {
                jobTypeDescriptor.push(checkedGrades.join(' and '));
            } else {
                jobTypeDescriptor.push(`${checkedGrades[0]} and ${checkedGrades.length - 1} other grades`);
            }
        }

        // FIXED: Only add profession filters if no location is selected to avoid duplication
        if (checkedLocations.length === 0 && checkedProfessions.length > 0) {
            if (checkedProfessions.length === 1) {
                jobTypeDescriptor.push(checkedProfessions[0]);
            } else if (checkedProfessions.length === 2) {
                jobTypeDescriptor.push(checkedProfessions.join(' and '));
            } else {
                jobTypeDescriptor.push(`${checkedProfessions[0]} and ${checkedProfessions.length - 1} other professions`);
            }
        }

        // Add search term if it's a keyword
        if (searchTerm && keywords.includes(searchTerm)) {
            jobTypeDescriptor.push(searchTerm);
        }

        // Build the final text
        let text = `${count}`;

        // Add job type descriptor
        if (jobTypeDescriptor.length > 0) {
            text += ` ${jobTypeDescriptor.join(' ')}`;
        }

        // Add "job" or "jobs"
        text += count === 1 ? ' job' : ' jobs';

        // FIXED: Location handling - clean format
        if (checkedLocations.length > 0) {
            if (checkedLocations.length === 1) {
                text += ` in ${checkedLocations[0]}`;
            } else if (checkedLocations.length === 2) {
                text += ` in ${checkedLocations.join(' and ')}`;
            } else {
                text += ` in ${checkedLocations.length} locations`;
            }
        }

        // Add search term for non-keyword searches
        if (searchTerm && !keywords.includes(searchTerm)) {
            text += ` matching "${searchTerm}"`;
        }

        return text;
    }

    // Function to handle Date Published filter changes (radio-like behavior)
    function handlePublishedFilterChange(selectedValue) {
        // Uncheck all other published checkboxes
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && item.name !== selectedValue) {
                checkbox.checked = false;
            }
        });

        applyFilters(false);
        updateCategoryButtons();
    }

 // Modified function to count jobs for published filters with correct logic
function countJobsForPublishedFilter(filterName, allActiveJobs) {
    return allActiveJobs.filter(job => {
        if (!job.published) return false;
        const jobDays = parseDaysFromPublished(job.published);
        if (!jobDays) return false;

        // Exclusive counting logic for each range
        switch(filterName) {
            case "Last 3 Days":
                return jobDays <= 3;
            case "Last 7 Days":
                return jobDays <= 7;
            case "Last 14 Days":
                return jobDays <= 14;
            case "Last 28 Days":
                return jobDays <= 28;
            case "More than 28 Days":
                return jobDays > 28; // Only jobs older than 28 days
            default:
                return false;
        }
    }).length;
}

    // Function to make keywords keyboard accessible
    function renderKeywords() {
        const keywordsList = document.getElementById('keywordsList');
        keywordsList.innerHTML = keywords.map((keyword, index) =>
            `<button
                class="keyword-tag"
                onclick="selectKeyword('${keyword}')"
                onkeydown="handleKeywordKeydown(event, '${keyword}', ${index})"
                role="button"
                tabindex="0"
                aria-label="Select keyword: ${keyword}"
                data-index="${index}">
                ${keyword}
            </button>`
        ).join('');

        // Add keyboard navigation for arrow keys
        const keywordButtons = keywordsList.querySelectorAll('.keyword-tag');
        keywordButtons.forEach((btn, index) => {
            btn.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    const nextIndex = (index + 1) % keywordButtons.length;
                    keywordButtons[nextIndex].focus();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    const prevIndex = (index - 1 + keywordButtons.length) % keywordButtons.length;
                    keywordButtons[prevIndex].focus();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const nextRowIndex = Math.min(index + 3, keywordButtons.length - 1);
                    keywordButtons[nextRowIndex].focus();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prevRowIndex = Math.max(index - 3, 0);
                    keywordButtons[prevRowIndex].focus();
                }
            });
        });
    }

function handleKeywordKeydown(event, keyword, index) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectKeyword(keyword);
        }
    }

    window.selectKeyword = function(keyword) {
        document.getElementById('keywordSearch').value = keyword;
        applyFilters(false); // Don't scroll to top
        updateCategoryButtons();
    };

    // All other existing functions remain the same...
    function normalizeLocation(location) {
        return location.toLowerCase().trim()
            .replace(/\s+/g, ' ')
            .replace(/[^\w\s-]/g, '');
    }

    function categorizeLocation(locationStr) {
        const normalized = normalizeLocation(locationStr);

        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            if (normalizeLocation(region) === normalized) {
                return { region: region, isRegion: true };
            }
        }

        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            for (const subcategory of data.subcategories) {
                if (normalizeLocation(subcategory) === normalized) {
                    return { region: region, subcategory: subcategory, isRegion: false };
                }
            }
        }

        const ukCountries = ['england', 'scotland', 'wales', 'northern ireland', 'uk', 'united kingdom', 'britain', 'great britain', 'nationwide', 'homeworking'];

        const locationLower = locationStr.toLowerCase().trim();

        const isUK = ukCountries.some(country => locationLower.includes(country)) ||
                     Object.keys(locationHierarchy).filter(k => k !== 'Overseas').some(region =>
                         locationLower.includes(region.toLowerCase())
                     );

        if (!isUK) {
            let countryName = null;

            const parts = locationStr.split(',');
            if (parts.length > 1) {
                const potentialCountry = parts[parts.length - 1].trim();
                countryName = potentialCountry.split(' ').map(word =>
                    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                ).join(' ');
            } else {
                countryName = 'Other International';
            }

            return { region: 'Overseas', subcategory: countryName, isRegion: false };
        }

        if (normalized.includes('london')) {
            return { region: 'London', subcategory: 'Greater London', isRegion: false };
        }

        return { region: 'Other UK', subcategory: locationStr, isRegion: false };
    }

    function getCurrentDate() {
        return new Date();
    }

    function parseDaysFromPublished(publishedString) {
        if (!publishedString) return null;

        const lowerStr = publishedString.toLowerCase();

        if (lowerStr.includes('24 hours') || lowerStr.includes('today')) {
            return 1;
        } else if (lowerStr.includes('yesterday')) {
            return 1;
        } else if (lowerStr.includes('last') && lowerStr.includes('days')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) : null;
        } else if (lowerStr.includes('week')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 7 : 7;
        } else if (lowerStr.includes('month')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 30 : 30;
        }

        return null;
    }

    function categorizePublishedString(publishedString) {
        const days = parseDaysFromPublished(publishedString);

        if (!days) return null;

        if (days <= 3) return "Last 3 Days";
        else if (days <= 7) return "Last 7 Days";
        else if (days <= 14) return "Last 14 Days";
        else if (days <= 28) return "Last 28 Days";
        else return "More than 28 Days";
    }

    function filterActiveJobs(jobs) {
        const currentDate = getCurrentDate();
        return jobs.filter(job => {
            if (job.job_end_date) {
                const endDate = new Date(job.job_end_date);
                return endDate >= currentDate;
            }
            return true;
        });
    }

    window.applyCategoryFilter = function(category) {
        activeCategoryFilter = category;
        updateCategoryButtons();

        if (category === 'all') {
            document.getElementById('keywordSearch').value = '';

            document.querySelectorAll('.filter-checkbox, .profession-parent-checkbox, .profession-sub-checkbox, .location-checkbox, .location-sub-checkbox').forEach(checkbox => {
                checkbox.checked = false;
                checkbox.classList.remove('indeterminate');
            });
        }

        applyFilters();
        scrollToTop();
    };

    window.clearKeywordSearch = function() {
        document.getElementById('keywordSearch').value = '';
        applyFilters(false); // Don't scroll
        updateCategoryButtons();
    };

    const keywordSearch = document.getElementById('keywordSearch');
    keywordSearch.addEventListener('input', function() {
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            requestAnimationFrame(() => {
                applyFilters(false); // Don't scroll on search
                updateCategoryButtons();
            });
        }, 300);
    });


  window.toggleFilterGroup = function(groupName) {
    const arrow = document.getElementById(groupName + 'Arrow');
    const options = document.getElementById(groupName + 'Options');
    const header = document.getElementById(groupName + '-header');

    // Prevent focus state
    if (header) {
        header.blur();
    }

    const isCollapsed = options.classList.contains('collapsed');

    if (isCollapsed) {
        options.classList.remove('collapsed');
        arrow.classList.remove('collapsed');
        arrow.textContent = '▼';
        options.style.display = 'block';
        header.setAttribute('aria-expanded', 'true');
    } else {
        options.classList.add('collapsed');
        arrow.classList.add('collapsed');
        arrow.textContent = '▶';
        options.style.display = 'none';
        header.setAttribute('aria-expanded', 'false');
    }
};

// Add keyboard handler for filter headers
window.handleFilterHeaderKeydown = function(event, groupName) {
    if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        toggleFilterGroup(groupName);
    }
};

// Add keyboard handler for parent category headers
window.handleParentCategoryKeydown = function(event, category, parentName) {
    if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        toggleParentCategory(category, parentName);
    }
};

   window.toggleParentCategory = function(category, parentName) {
    const arrow = document.getElementById(`${category}_parent_arrow_${parentName.replace(/\s+/g, '_')}`);
    const subcategories = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
    const header = arrow.closest('.profession-parent-header');

    // Remove any focus states
    if (event && event.target) {
        event.target.blur();
    }

    const isCollapsed = subcategories.classList.contains('collapsed');

    if (isCollapsed) {
        subcategories.classList.remove('collapsed');
        arrow.classList.remove('collapsed');
        arrow.textContent = '▼';
        subcategories.style.display = 'block';
        if (header) header.setAttribute('aria-expanded', 'true');
    } else {
        subcategories.classList.add('collapsed');
        arrow.classList.add('collapsed');
        arrow.textContent = '▶';
        subcategories.style.display = 'none';
        if (header) header.setAttribute('aria-expanded', 'false');
    }
};

    window.handleParentCategoryChange = function(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const isChecked = parentCheckbox.checked;

        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        subCheckboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
        });

       applyFilters(false);
       updateCategoryButtons();
    };

    window.handleSubCategoryChange = function(category, parentName, subName) {
        updateParentCheckboxState(category, parentName);
        // FIX 7: Don't scroll for filter changes
        applyFilters(false);
        updateCategoryButtons();
    };

    window.toggleProfessionParent = function(parentName) {
        toggleParentCategory('profession', parentName);
    };

    window.handleParentProfessionChange = function(parentName) {
        handleParentCategoryChange('profession', parentName);
    };

    window.handleSubProfessionChange = function(parentName, subName) {
        handleSubCategoryChange('profession', parentName, subName);

        if (window.self !== window.top) {
            window.parent.postMessage({
                type: 'bmj-careers-filter-change',
                filterType: 'profession',
                filterValue: subName,
                parent: parentName
            }, '*');
        }
    };

    window.handleFilterChange = function(category, value) {
        // Special handling for Date Published filters (radio-like behavior)
        if (category === 'published') {
            handlePublishedFilterChange(value);
        } else {
            if (window.widgetClientInfo && window.widgetClientInfo.clientId !== 'direct') {
                fetch('/api/track/widget', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        event: 'filter_change',
                        clientId: window.widgetClientInfo.clientId,
                        clientName: window.widgetClientInfo.clientName,
                        sessionId: window.widgetClientInfo.sessionId,
                        data: {
                            filterType: category,
                            filterValue: value,
                            timestamp: Date.now()
                        }
                    })
                }).catch(err => console.error('Filter tracking failed:', err));
            }

            // FIX 7: Don't scroll for filter changes
            applyFilters(false);
            updateCategoryButtons();
        }
    };


    (function initializeWidgetTracking() {
        const urlParams = new URLSearchParams(window.location.search);
        window.widgetClientInfo = {
            clientId: urlParams.get('client_id') || urlParams.get('utm_source') || 'direct',
            clientName: urlParams.get('client_name') || urlParams.get('utm_source') || 'Unknown',
            sessionId: urlParams.get('session_id') || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        };

        console.log('Widget initialized with client info:', window.widgetClientInfo);

        if (window.widgetClientInfo.clientId !== 'direct') {
            fetch('/api/track/widget', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: 'page_view',
                    clientId: window.widgetClientInfo.clientId,
                    clientName: window.widgetClientInfo.clientName,
                    sessionId: window.widgetClientInfo.sessionId,
                    data: {
                        url: window.location.href,
                        timestamp: Date.now()
                    }
                })
            }).catch(err => console.error('Page view tracking failed:', err));
        }
    })();

    window.applyToJob = function(jobId) {
        const job = window.allJobsData.find(j => j.id === jobId);

        console.log('Job click detected:', {
            jobId: jobId,
            jobTitle: job?.job_title,
            clientId: window.widgetClientInfo?.clientId
        });

        if (window.widgetClientInfo && window.widgetClientInfo.clientId !== 'direct') {
            fetch('/api/track/widget', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: 'job_click',
                    clientId: window.widgetClientInfo.clientId,
                    clientName: window.widgetClientInfo.clientName,
                    sessionId: window.widgetClientInfo.sessionId,
                    data: {
                        jobId: jobId,
                        jobTitle: job?.job_title || 'Unknown',
                        employer: job?.alternate_recruiter_name || job?.recruiter_name || 'Unknown',
                        timestamp: Date.now()
                    }
                })
            }).then(response => {
                console.log('Click tracked successfully');
            }).catch(err => {
                console.error('Click tracking failed:', err);
            });

            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-job-click',
                    jobId: jobId,
                    jobTitle: job?.job_title || 'Unknown',
                    employer: job?.alternate_recruiter_name || job?.recruiter_name || 'Unknown',
                    clientId: window.widgetClientInfo.clientId,
                    clientName: window.widgetClientInfo.clientName
                }, '*');
            }
        }

        if (job && job.job_url) {
            window.open(job.job_url, '_blank', 'noopener,noreferrer');
        } else {
            window.open('https://www.bmj.com/careers/job/' + jobId, '_blank', 'noopener,noreferrer');
        }
    };

    window.goToPage = function(page) {
        const totalPages = Math.ceil(filteredJobs.length / jobsPerPage);
        if (page < 1 || page > totalPages) return;

        currentPage = page;
        renderJobsList();
        updatePagination();

        document.querySelector('.jobs-section').scrollIntoView({ behavior: 'smooth' });
    };

    window.getCurrentPage = function() {
        return currentPage;
    };

    window.scrollToTop = function() {
        requestAnimationFrame(() => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    };

    const handleScroll = perfUtils.throttle(() => {
        const scrollToTopBtn = document.getElementById('scrollToTop');
        if (window.pageYOffset > 300) {
            scrollToTopBtn.classList.add('show');
        } else {
            scrollToTopBtn.classList.remove('show');
        }
    }, 100);

    window.trackWidgetEvent = function(eventType, eventData) {
        const urlParams = new URLSearchParams(window.location.search);
        const clientId = urlParams.get('client_id') || urlParams.get('utm_source') || 'direct';
        const clientName = urlParams.get('client_name') || clientId;
        const sessionId = urlParams.get('session_id') || 'direct_' + Date.now();

        if (window.self !== window.top) {
            window.parent.postMessage({
                type: 'bmj-careers-event',
                eventType: eventType,
                data: eventData,
                clientId: clientId,
                clientName: clientName,
                sessionId: sessionId
            }, '*');
        }

        fetch('/api/track/widget', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                event: eventType,
                clientId: clientId,
                clientName: clientName,
                sessionId: sessionId,
                data: eventData
            })
        }).catch(err => console.error('Tracking failed:', err));
    };

    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('keywordSearch');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const searchTerm = this.value;

                searchTimeout = setTimeout(() => {
                    if (window.widgetClientInfo && window.widgetClientInfo.clientId !== 'direct' && searchTerm) {
                        fetch('/api/track/widget', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                event: 'search',
                                clientId: window.widgetClientInfo.clientId,
                                clientName: window.widgetClientInfo.clientName,
                                sessionId: window.widgetClientInfo.sessionId,
                                data: {
                                    searchTerm: searchTerm,
                                    timestamp: Date.now()
                                }
                            })
                        }).catch(err => console.error('Search tracking failed:', err));
                    }
                }, 500);
            });
        }
    });

    function updateCategoryButtons() {
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;
        const hasActiveFilters = searchTerm.length > 0 || hasCheckedFilters;

        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        const activeBtn = document.getElementById(`btn-${activeCategoryFilter}`);
        if (activeBtn) {
            if (activeCategoryFilter === 'all' && !hasActiveFilters) {
                activeBtn.classList.add('active');
            } else if (activeCategoryFilter !== 'all') {
                activeBtn.classList.add('active');
            }
        }
    }

    function updateParentCheckboxState(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        const checkedCount = Array.from(subCheckboxes).filter(cb => cb.checked).length;
        const totalCount = subCheckboxes.length;

        if (checkedCount === 0) {
            parentCheckbox.checked = false;
            parentCheckbox.classList.remove('indeterminate');
        } else if (checkedCount === totalCount) {
            parentCheckbox.checked = true;
            parentCheckbox.classList.remove('indeterminate');
        } else {
            parentCheckbox.checked = false;
            parentCheckbox.classList.add('indeterminate');
        }
    }

// Build dynamic hierarchies from job data
    function buildDynamicHierarchies() {
        if (!professionHierarchy || Object.keys(professionHierarchy).length === 0) {
            loadFullHierarchies();
        }

        // Deep copy the base hierarchies
        dynamicProfessionHierarchy = JSON.parse(JSON.stringify(professionHierarchy));
        dynamicLocationHierarchy = JSON.parse(JSON.stringify(locationHierarchy));

        const activeJobs = filterActiveJobs(allJobsData);

        // Clear existing Overseas subcategories
        dynamicLocationHierarchy.Overseas.subcategories = [];

        // Track unique countries
        const overseasCountries = new Set();

        // Process locations for Overseas
        activeJobs.forEach(job => {
            if (categoryFilters.overseas.filter(job)) {
                const location = job.location_description || '';
                const country = job.location_country || '';

                let countryName = null;

                const locationLower = location.toLowerCase();
                const countryLower = country.toLowerCase();

                // Specific country detection
                if (locationLower.includes('australia') || countryLower.includes('australia') ||
                    locationLower.includes('sydney') || locationLower.includes('melbourne') ||
                    locationLower.includes('brisbane') || locationLower.includes('perth') ||
                    locationLower.includes('adelaide')) {
                    countryName = 'Australia';
                } else if (locationLower.includes('new zealand') || countryLower.includes('new zealand') ||
                           locationLower.includes('auckland') || locationLower.includes('wellington') ||
                           locationLower.includes('christchurch')) {
                    countryName = 'New Zealand';
                } else if (locationLower.includes('canada') || countryLower.includes('canada') ||
                           locationLower.includes('toronto') || locationLower.includes('vancouver') ||
                           locationLower.includes('montreal')) {
                    countryName = 'Canada';
                } else if ((locationLower.includes('ireland') || countryLower.includes('ireland') ||
                            locationLower.includes('dublin')) &&
                           !locationLower.includes('northern') && !countryLower.includes('northern')) {
                    countryName = 'Republic of Ireland';
                } else if (locationLower.includes('usa') || locationLower.includes('united states') ||
                           countryLower.includes('usa') || countryLower.includes('united states') ||
                           locationLower.includes('america')) {
                    countryName = 'United States';
                } else if (locationLower.includes('dubai') || locationLower.includes('uae') ||
                           countryLower.includes('dubai') || countryLower.includes('uae') ||
                           locationLower.includes('emirates')) {
                    countryName = 'UAE';
                } else if (locationLower.includes('singapore') || countryLower.includes('singapore')) {
                    countryName = 'Singapore';
                } else if (locationLower.includes('hong kong') || countryLower.includes('hong kong')) {
                    countryName = 'Hong Kong';
                } else if (locationLower.includes('germany') || countryLower.includes('germany')) {
                    countryName = 'Germany';
                } else if (locationLower.includes('france') || countryLower.includes('france')) {
                    countryName = 'France';
                } else if (locationLower.includes('spain') || countryLower.includes('spain')) {
                    countryName = 'Spain';
                } else if (locationLower.includes('netherlands') || countryLower.includes('netherlands')) {
                    countryName = 'Netherlands';
                } else if (locationLower.includes('switzerland') || countryLower.includes('switzerland')) {
                    countryName = 'Switzerland';
                } else if (country && country.length > 0) {
                    const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales',
                                       'northern ireland', 'britain', 'great britain'];
                    const isUK = ukCountries.some(uk => country.toLowerCase().includes(uk));

                    if (!isUK) {
                        countryName = country.split(' ').map(word =>
                            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                        ).join(' ');
                    }
                }

                if (countryName) {
                    overseasCountries.add(countryName);
                }
            }
        });

        dynamicLocationHierarchy.Overseas.subcategories = Array.from(overseasCountries).sort();

        if (dynamicLocationHierarchy.Overseas.subcategories.length === 0) {
            dynamicLocationHierarchy.Overseas.subcategories = ['Other International'];
        }

        activeJobs.forEach(job => {
            if (job.sector && Array.isArray(job.sector)) {
                job.sector.forEach(sector => {
                    // Add new sectors to appropriate categories
                });
            }
        });
    }

       function getCheckedLocations() {
        const checkedLocations = [];
        const processedLocations = new Set(); // Prevent duplicates

        // Check simple location checkboxes first
        const simpleCheckboxes = document.querySelectorAll('.location-checkbox:checked');
        simpleCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                if (!processedLocations.has(cleanName)) {
                    checkedLocations.push(cleanName);
                    processedLocations.add(cleanName);
                }
            }
        });

        // Check sub location checkboxes
        const subCheckboxes = document.querySelectorAll('.location-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                if (!processedLocations.has(cleanName)) {
                    checkedLocations.push(cleanName);
                    processedLocations.add(cleanName);
                }
            }
        });

        return checkedLocations;
    }

    // FIXED: Get checked professions - only return actually selected professions
    function getCheckedProfessions() {
        const checkedProfessions = [];
        const processedProfessions = new Set(); // Prevent duplicates

        const subCheckboxes = document.querySelectorAll('.profession-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const professionName = label.textContent.trim();
                const cleanName = professionName.replace(/\s*\(\d+\)$/, '');
                if (!processedProfessions.has(cleanName)) {
                    checkedProfessions.push(cleanName);
                    processedProfessions.add(cleanName);
                }
            }
        });

        return checkedProfessions;
    }

    // FIXED: Add function to get checked grades
    function getCheckedGrades() {
        const checkedGrades = [];
        if (filterData.grade) {
            filterData.grade.forEach(item => {
                const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    checkedGrades.push(item.name);
                }
            });
        }
        return checkedGrades;
    }

    // Rest of the count functions remain the same but with updated published filter logic
    function countJobsForLocationCategoryWithFilters(categoryName, subcategories, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                return checkedProfessions.some(profession => {
                    return searchText.includes(profession.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                });
            });
        }

        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
    switch(selectedCategory) {
        case "Last 3 Days": return jobDays <= 3;
        case "Last 7 Days": return jobDays <= 7;
        case "Last 14 Days": return jobDays <= 14;
        case "Last 28 Days": return jobDays <= 28;
        case "More than 28 Days": return jobDays > 28; // Only jobs older than 28 days
        default: return false;
    }
});
            });
        }

        return jobs.filter(job => {
            const location = job.location_description || '';
            const categorized = categorizeLocation(location);

            if (categorized.region === categoryName) {
                return true;
            }

            return subcategories.some(subcat => {
                const normalizedSubcat = normalizeLocation(subcat);
                const normalizedLocation = normalizeLocation(location);
                return normalizedLocation.includes(normalizedSubcat);
            });
        }).length;
    }

    function countJobsForSpecificLocationWithFilters(locationName, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                return checkedProfessions.some(profession => {
                    return searchText.includes(profession.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                });
            });
        }

        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
    switch(selectedCategory) {
        case "Last 3 Days": return jobDays <= 3;
        case "Last 7 Days": return jobDays <= 7;
        case "Last 14 Days": return jobDays <= 14;
        case "Last 28 Days": return jobDays <= 28;
        case "More than 28 Days": return jobDays > 28; // Only jobs older than 28 days
        default: return false;
    }
});
            });
        }

        const isOverseasLocation = dynamicLocationHierarchy.Overseas.subcategories.includes(locationName);

        if (isOverseasLocation) {
            return jobs.filter(job => {
                if (!categoryFilters.overseas.filter(job)) {
                    return false;
                }

                const location = job.location_description || '';
                const country = job.location_country || '';
                const locationLower = location.toLowerCase();
                const countryLower = country.toLowerCase();
                const searchLower = locationName.toLowerCase();

                if (countryLower.includes(searchLower) || searchLower.includes(countryLower)) {
                    return true;
                }

                if (locationName === 'Australia') {
                    return locationLower.includes('australia') ||
                           locationLower.includes('sydney') || locationLower.includes('melbourne') ||
                           locationLower.includes('brisbane') || locationLower.includes('perth') ||
                           locationLower.includes('adelaide');
                } else if (locationName === 'New Zealand') {
                    return locationLower.includes('new zealand') ||
                           locationLower.includes('auckland') || locationLower.includes('wellington') ||
                           locationLower.includes('christchurch');
                } else if (locationName === 'Canada') {
                    return locationLower.includes('canada') ||
                           locationLower.includes('toronto') || locationLower.includes('vancouver') ||
                           locationLower.includes('montreal');
                }

               return false;
            }).length;
        } else {
            return jobs.filter(job => {
                const location = job.location_description || '';
                const normalizedLocation = normalizeLocation(location);
                const normalizedSearch = normalizeLocation(locationName);
                return normalizedLocation.includes(normalizedSearch);
            }).length;
        }
    }

    function buildLocationHierarchy() {
        const locationData = [];
        const currentFilters = {};

        const londonCount = countJobsForSpecificLocationWithFilters('London', currentFilters);
        if (londonCount > 0) {
            locationData.push({
                name: 'London',
                count: londonCount,
                subcategories: []
            });
        }

        Object.entries(dynamicLocationHierarchy).forEach(([parentName, parentData]) => {
            if (parentName === 'London') return;

            const parentCount = countJobsForLocationCategoryWithFilters(parentName, parentData.subcategories, currentFilters);

            if (parentCount > 0) {
                const subcategoryData = [];

                parentData.subcategories.forEach(subcategory => {
                    const count = countJobsForSpecificLocationWithFilters(subcategory, currentFilters);
                    if (count > 0) {
                        subcategoryData.push({ name: subcategory, count });
                    }
                });

                locationData.push({
                    name: parentName,
                    count: parentCount,
                    subcategories: subcategoryData
                });
            }
        });

        return locationData;
    }

    function getCheckedLocations() {
        const checkedLocations = [];

        const simpleCheckboxes = document.querySelectorAll('.location-checkbox:checked');
        simpleCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        const subCheckboxes = document.querySelectorAll('.location-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        return checkedLocations;
    }

    function countJobsForProfessionCategoryWithFilters(categoryName, subcategories, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        const checkedLocations = getCheckedLocations();
        if (checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';

                return checkedLocations.some(location => {
                    if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                        if (!categoryFilters.overseas.filter(job)) {
                            return false;
                        }

                        const country = job.location_country || '';
                        const locationLower = jobLocation.toLowerCase();
                        const countryLower = country.toLowerCase();

                        if (location === 'Canada') {
                            return locationLower.includes('canada') || countryLower.includes('canada');
                        } else if (location === 'Australia') {
                            return locationLower.includes('australia') || countryLower.includes('australia');
                        } else if (location === 'New Zealand') {
                            return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                        } else if (location === 'Republic of Ireland') {
                            return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                   !locationLower.includes('northern') && !countryLower.includes('northern');
                        } else if (location === 'North America') {
                            return locationLower.includes('usa') || locationLower.includes('united states') ||
                                   countryLower.includes('usa') || countryLower.includes('united states');
                        } else if (location === 'Middle East') {
                            return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                   countryLower.includes('dubai') || countryLower.includes('uae');
                        } else if (location === country) {
                            return true;
                        }

                        return false;
                    } else {
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    }
                });
            });
        }

        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
    switch(selectedCategory) {
        case "Last 3 Days": return jobDays <= 3;
        case "Last 7 Days": return jobDays <= 7;
        case "Last 14 Days": return jobDays <= 14;
        case "Last 28 Days": return jobDays <= 28;
        case "More than 28 Days": return jobDays > 28; // Only jobs older than 28 days
        default: return false;
    }
});
            });
        }

        return jobs.filter(job => {
            const sectors = job.sector || [];
            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();

            return subcategories.some(subcat => {
                if (typeof subcat === 'string') {
                    return searchText.includes(subcat.toLowerCase()) || sectors.some(s => s.toLowerCase() === subcat.toLowerCase());
                } else if (typeof subcat === 'object' && subcat.subcategories) {
                    return searchText.includes(subcat.name.toLowerCase()) ||
                           subcat.subcategories.some(nested => searchText.includes(nested.toLowerCase()));
                }
                return false;
            });
        }).length;
    }

    function countJobsForSpecificProfessionWithFilters(professionName, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        const checkedLocations = getCheckedLocations();
        if (checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';

                return checkedLocations.some(location => {
                    if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                        if (!categoryFilters.overseas.filter(job)) {
                            return false;
                        }

                        const country = job.location_country || '';
                        const locationLower = jobLocation.toLowerCase();
                        const countryLower = country.toLowerCase();

                        if (location === 'Canada') {
                            return locationLower.includes('canada') || countryLower.includes('canada');
                        } else if (location === 'Australia') {
                            return locationLower.includes('australia') || countryLower.includes('australia');
                        } else if (location === 'New Zealand') {
                            return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                        } else if (location === 'Republic of Ireland') {
                            return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                   !locationLower.includes('northern') && !countryLower.includes('northern');
                        } else if (location === 'North America') {
                            return locationLower.includes('usa') || locationLower.includes('united states') ||
                                   countryLower.includes('usa') || countryLower.includes('united states');
                        } else if (location === 'Middle East') {
                            return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                   countryLower.includes('dubai') || countryLower.includes('uae');
                        } else if (location === country) {
                            return true;
                        }

                        return false;
                    } else {
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    }
                });
            });
        }

        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
    switch(selectedCategory) {
        case "Last 3 Days": return jobDays <= 3;
        case "Last 7 Days": return jobDays <= 7;
        case "Last 14 Days": return jobDays <= 14;
        case "Last 28 Days": return jobDays <= 28;
        case "More than 28 Days": return jobDays > 28; // Only jobs older than 28 days
        default: return false;
    }
});
            });
        }

        return jobs.filter(job => {
            const sectors = job.sector || [];
            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
            return searchText.includes(professionName.toLowerCase()) || sectors.some(s => s.toLowerCase() === professionName.toLowerCase());
        }).length;
    }

    function buildProfessionHierarchy() {
        const professionData = [];

        Object.entries(dynamicProfessionHierarchy).forEach(([parentName, parentData]) => {
            const parentCount = countJobsForProfessionCategoryWithFilters(parentName, parentData.subcategories, {});

            if (parentCount > 0) {
                const subcategoryData = [];

                parentData.subcategories.forEach(subcategory => {
                    if (typeof subcategory === 'string') {
                        const count = countJobsForSpecificProfessionWithFilters(subcategory, {});
                        if (count > 0) {
                            subcategoryData.push({ name: subcategory, count });
                        }
                    } else if (typeof subcategory === 'object' && subcategory.subcategories) {
                        const nestedCount = countJobsForSpecificProfessionWithFilters(subcategory.name, {});
                        if (nestedCount > 0) {
                            const nestedSubcategories = [];
                            subcategory.subcategories.forEach(nestedSub => {
                                const nestedSubCount = countJobsForSpecificProfessionWithFilters(nestedSub, {});
                                if (nestedSubCount > 0) {
                                    nestedSubcategories.push({ name: nestedSub, count: nestedSubCount });
                                }
                            });

                            subcategoryData.push({
                                name: subcategory.name,
                                count: nestedCount,
                                subcategories: nestedSubcategories
                            });
                        }
                    }
                });

                professionData.push({
                    name: parentName,
                    count: parentCount,
                    subcategories: subcategoryData
                });
            }
        });

        return professionData;
    }

    function getCheckedProfessions() {
        const checkedProfessions = [];

        const subCheckboxes = document.querySelectorAll('.profession-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const professionName = label.textContent.trim();
                const cleanName = professionName.replace(/\s*\(\d+\)$/, '');
                checkedProfessions.push(cleanName);
            }
        });

        return checkedProfessions;
    }

    function calculateFilterCounts() {
    // Initialize as empty arrays, not objects
    filterData = {
        published: [],
        profession: [],
        grade: [],
        location: []
    };

    const activeJobs = filterActiveJobs(allJobsData);

    if (activeJobs.length === 0) return;

    buildDynamicHierarchies();

    let publishedCounts = {};
    let gradeCounts = {};

    activeJobs.forEach(job => {
        if (job.published) {
            const category = categorizePublishedString(job.published);
            if (category) {
                publishedCounts[category] = (publishedCounts[category] || 0) + 1;
            }
        }

        if (job.grade) {
            gradeCounts[job.grade] = (gradeCounts[job.grade] || 0) + 1;
        }
    });

    const publishedOrder = [
        "Last 7 Days",
        "Last 14 Days",
        "Last 28 Days",
        "More than 28 Days"
    ];

    // Set published data
    filterData.published = publishedOrder
        .filter(category => publishedCounts[category] > 0)
        .map(category => ({
            name: category,
            count: countJobsForPublishedFilter(category, activeJobs)
        }));

    // Set grade data
    filterData.grade = Object.entries(gradeCounts)
        .map(([name, count]) => ({ name, count }))
        .sort((a, b) => b.count - a.count);

    // Set profession data
    filterData.profession = buildProfessionHierarchy();

    // Set location data
    filterData.location = buildLocationHierarchy();

    // Debug log to verify structure
    console.log('FilterData structure:', {
        published: filterData.published.length,
        profession: filterData.profession.length,
        grade: filterData.grade.length,
        location: filterData.location.length
    });
}

 function renderLocationFilters(locationData) {
    return `
        <div class="filter-group" role="region" aria-labelledby="location-header">
            <button class="filter-header" onclick="toggleFilterGroup('location')" onkeydown="handleFilterHeaderKeydown(event, 'location')" id="location-header" aria-expanded="true" tabindex="0">
                <span class="filter-arrow" id="locationArrow">▼</span>
                <span>Location</span>
            </button>
            <div class="filter-options" id="locationOptions" style="display: block;">
                ${locationData.map(parent => {
                    const hasSubcategories = parent.subcategories && parent.subcategories.length > 0;
                    if (!hasSubcategories) {
                        return `
                            <div class="filter-item">
                                <input type="checkbox" class="filter-checkbox location-checkbox" id="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                       onchange="handleFilterChange('location', '${parent.name}')" aria-label="${parent.name} location filter">
                                <label class="filter-label" for="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${parent.name}</label>
                                <span class="filter-count">${parent.count}</span>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="profession-parent-group">
                                <button class="profession-parent-header" onclick="toggleParentCategory('location', '${parent.name}')" onkeydown="handleParentCategoryKeydown(event, 'location', '${parent.name}')" aria-expanded="false" tabindex="0">
                                    <input type="checkbox" class="profession-parent-checkbox" id="location_parent_${parent.name.replace(/\s+/g, '_')}"
                                           onchange="handleParentCategoryChange('location', '${parent.name}')" onclick="event.stopPropagation()" aria-label="${parent.name} location category" tabindex="-1">
                                    <label class="profession-parent-label" for="location_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                                    <span class="filter-count">${parent.count}</span>
                                    <span class="profession-parent-arrow" id="location_parent_arrow_${parent.name.replace(/\s+/g, '_')}">▶</span>
                                </button>
                                <div class="profession-subcategories collapsed" id="location_subcategories_${parent.name.replace(/\s+/g, '_')}" style="display: none;">
                                    ${parent.subcategories.map(sub => `
                                        <div class="profession-sub-item">
                                            <input type="checkbox" class="profession-sub-checkbox location-sub-checkbox" id="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                   onchange="handleSubCategoryChange('location', '${parent.name}', '${sub.name}')" aria-label="${sub.name} location">
                                            <label class="profession-sub-label" for="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                                            <span class="filter-count">${sub.count}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                }).join('')}
            </div>
        </div>
    `;
}

  function renderProfessionFilters(professionData) {
    return `
        <div class="filter-group" role="region" aria-labelledby="profession-header">
            <button class="filter-header" onclick="toggleFilterGroup('profession')" onkeydown="handleFilterHeaderKeydown(event, 'profession')" id="profession-header" aria-expanded="true" tabindex="0">
                <span class="filter-arrow" id="professionArrow">▼</span>
                <span>Profession</span>
            </button>
            <div class="filter-options" id="professionOptions" style="display: block;">
                ${professionData.map(parent => `
                    <div class="profession-parent-group">
                        <button class="profession-parent-header" onclick="toggleProfessionParent('${parent.name}')" onkeydown="handleParentCategoryKeydown(event, 'profession', '${parent.name}')" aria-expanded="false" tabindex="0">
                            <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${parent.name.replace(/\s+/g, '_')}"
                                   onchange="handleParentProfessionChange('${parent.name}')" onclick="event.stopPropagation()" aria-label="${parent.name} profession category" tabindex="-1">
                            <label class="profession-parent-label" for="profession_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                            <span class="filter-count">${parent.count}</span>
                            <span class="profession-parent-arrow collapsed" id="profession_parent_arrow_${parent.name.replace(/\s+/g, '_')}">▶</span>
                        </button>
                        <div class="profession-subcategories collapsed" id="profession_subcategories_${parent.name.replace(/\s+/g, '_')}" style="display: none;">
                            ${parent.subcategories.map(sub => renderSubProfession(sub, parent.name)).join('')}
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

function renderSubProfession(sub, parentName) {
    if (sub.subcategories) {
        return `
            <div class="profession-parent-group" style="margin-left: 20px;">
                <button class="profession-parent-header" onclick="toggleProfessionParent('${sub.name}')" onkeydown="handleParentCategoryKeydown(event, 'profession', '${sub.name}')" aria-expanded="false" tabindex="0">
                    <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${sub.name.replace(/\s+/g, '_')}"
                           onchange="handleParentProfessionChange('${sub.name}')" onclick="event.stopPropagation()" aria-label="${sub.name} profession subcategory" tabindex="-1">
                    <label class="profession-parent-label" for="profession_parent_${sub.name.replace(/\s+/g, '_')}">${sub.name}</label>
                    <span class="filter-count">${sub.count}</span>
                    <span class="profession-parent-arrow collapsed" id="profession_parent_arrow_${sub.name.replace(/\s+/g, '_')}">▶</span>
                </button>
                <div class="profession-subcategories collapsed" id="profession_subcategories_${sub.name.replace(/\s+/g, '_')}" style="display: none;">
                    ${sub.subcategories.map(nestedSub => `
                        <div class="profession-sub-item">
                            <input type="checkbox" class="profession-sub-checkbox" id="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                   onchange="handleSubProfessionChange('${sub.name}', '${nestedSub.name}')" aria-label="${nestedSub.name} profession">
                            <label class="profession-sub-label" for="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${nestedSub.name}</label>
                            <span class="filter-count">${nestedSub.count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    } else {
        return `
            <div class="profession-sub-item">
                <input type="checkbox" class="profession-sub-checkbox" id="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                       onchange="handleSubProfessionChange('${parentName}', '${sub.name}')" aria-label="${sub.name} profession">
                <label class="profession-sub-label" for="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                <span class="filter-count">${sub.count}</span>
            </div>
        `;
    }
}

   function renderFilters() {
    const filtersContainer = document.getElementById('filtersContainer');
    let filterHTML = '';

    // Render Date Published filter - EXPANDED by default
    if (filterData.published && filterData.published.length > 0) {
        filterHTML += `
            <div class="filter-group" role="region" aria-labelledby="published-header">
                <button class="filter-header" onclick="toggleFilterGroup('published')" onkeydown="handleFilterHeaderKeydown(event, 'published')" id="published-header" aria-expanded="true" tabindex="0">
                    <span class="filter-arrow" id="publishedArrow">▼</span>
                    <span>Date Published</span>
                </button>
                <div class="filter-options" id="publishedOptions" style="display: block;">
                    ${filterData.published.map(item => {
                        const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                        return `
                            <div class="filter-item">
                                <input type="checkbox" class="filter-checkbox" id="${checkboxId}"
                                       onchange="handleFilterChange('published', '${item.name}')"
                                       aria-label="${item.name} published filter">
                                <label class="filter-label" for="${checkboxId}">${item.name}</label>
                                <span class="filter-count">${item.count}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        `;
    }

    // Render Profession filter - EXPANDED by default, subcategories COLLAPSED
    if (filterData.profession && filterData.profession.length > 0) {
        filterHTML += renderProfessionFilters(filterData.profession);
    }

    // Render Grade filter - EXPANDED by default
    if (filterData.grade && filterData.grade.length > 0) {
        filterHTML += `
            <div class="filter-group" role="region" aria-labelledby="grade-header">
                <button class="filter-header" onclick="toggleFilterGroup('grade')" onkeydown="handleFilterHeaderKeydown(event, 'grade')" id="grade-header" aria-expanded="true" tabindex="0">
                    <span class="filter-arrow" id="gradeArrow">▼</span>
                    <span>Grade</span>
                </button>
                <div class="filter-options" id="gradeOptions" style="display: block;">
                    ${filterData.grade.map(item => {
                        const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                        return `
                            <div class="filter-item">
                                <input type="checkbox" class="filter-checkbox" id="${checkboxId}"
                                       onchange="handleFilterChange('grade', '${item.name}')"
                                       aria-label="${item.name} grade filter">
                                <label class="filter-label" for="${checkboxId}">${item.name}</label>
                                <span class="filter-count">${item.count}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        `;
    }

    // Render Location filter - EXPANDED by default, subcategories COLLAPSED
    if (filterData.location && filterData.location.length > 0) {
        filterHTML += renderLocationFilters(filterData.location);
    }

    filtersContainer.innerHTML = filterHTML;
}

  function applyFilters(shouldScroll = true) {
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        const activeFilters = {};

        Object.keys(filterData).forEach(category => {
            activeFilters[category] = [];
            if (category === 'profession') {
                activeFilters[category] = getCheckedProfessions();
            } else if (category === 'location') {
                activeFilters[category] = getCheckedLocations();
            } else {
                if (filterData[category]) {
                    filterData[category].forEach(item => {
                        const checkboxId = `${category}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox && checkbox.checked) {
                            activeFilters[category].push(item.name);
                        }
                    });
                }
            }
        });

        const hasActiveFilters = searchTerm.length > 0 ||
                                Object.values(activeFilters).some(arr => arr.length > 0);

        if (hasActiveFilters && activeCategoryFilter === 'all') {
            const allBtn = document.getElementById('btn-all');
            if (allBtn) allBtn.classList.remove('active');
        }

        if (window.self !== window.top && searchTerm) {
            window.parent.postMessage({
                type: 'bmj-careers-search',
                searchTerm: searchTerm,
                resultsCount: filteredJobs.length
            }, '*');
        }

        let activeJobs = filterActiveJobs(allJobsData);

        filteredJobs = activeJobs.filter(job => {
            if (activeCategoryFilter !== 'all') {
                if (!categoryFilters[activeCategoryFilter].filter(job)) {
                    return false;
                }
            }

            if (searchTerm.length > 0) {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const matchesSearch = job.job_title.toLowerCase().includes(searchTerm) ||
                                    job.location_description.toLowerCase().includes(searchTerm) ||
                                    employer.toLowerCase().includes(searchTerm) ||
                                    job.short_description.toLowerCase().includes(searchTerm) ||
                                    sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                                    (job.grade && job.grade.toLowerCase().includes(searchTerm));
                if (!matchesSearch) return false;
            }

            for (const [category, selectedValues] of Object.entries(activeFilters)) {
                if (selectedValues.length > 0) {
                    if (category === 'profession') {
                        const checkedProfessions = selectedValues;
                        const sectors = job.sector || [];
                        const employer = job.alternate_recruiter_name || job.recruiter_name;
                        const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                        const matchesProfession = checkedProfessions.some(profession => {
                            return searchText.includes(profession.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                        });
                        if (!matchesProfession) return false;
                    } else if (category === 'location') {
                        const checkedLocations = selectedValues;
                        const jobLocation = job.location_description || '';

                        const matchesLocation = checkedLocations.some(location => {
                            if (dynamicLocationHierarchy && dynamicLocationHierarchy.Overseas &&
                                dynamicLocationHierarchy.Overseas.subcategories &&
                                dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                                if (!categoryFilters.overseas.filter(job)) {
                                    return false;
                                }

                                const country = job.location_country || '';
                                const locationLower = jobLocation.toLowerCase();
                                const countryLower = country.toLowerCase();

                                if (location === 'Canada') {
                                    return locationLower.includes('canada') || countryLower.includes('canada');
                                } else if (location === 'Australia') {
                                    return locationLower.includes('australia') || countryLower.includes('australia');
                                } else if (location === 'New Zealand') {
                                    return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                                } else if (location === 'Republic of Ireland') {
                                    return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                           !locationLower.includes('northern') && !countryLower.includes('northern');
                                } else if (location === 'North America') {
                                    return locationLower.includes('usa') || locationLower.includes('united states') ||
                                           countryLower.includes('usa') || countryLower.includes('united states');
                                } else if (location === 'Middle East') {
                                    return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                           countryLower.includes('dubai') || countryLower.includes('uae');
                                } else if (location === country) {
                                    return true;
                                }

                                return false;
                            } else {
                                const normalizedJobLocation = normalizeLocation(jobLocation);
                                const normalizedSearch = normalizeLocation(location);
                                return normalizedJobLocation.includes(normalizedSearch);
                            }
                        });

                        if (!matchesLocation) return false;
                    } else if (category === 'grade') {
                        if (!job.grade || !selectedValues.includes(job.grade)) {
                            return false;
                        }
                    } else if (category === 'published') {
                        if (!job.published) return false;

                        const jobDays = parseDaysFromPublished(job.published);
                        if (!jobDays) return false;

    const matchesPublished = selectedValues.some(selectedCategory => {
    switch(selectedCategory) {
        case "Last 3 Days":
            return jobDays <= 3;
        case "Last 7 Days":
            return jobDays <= 7;
        case "Last 14 Days":
            return jobDays <= 14;
        case "Last 28 Days":
            return jobDays <= 28;
        case "More than 28 Days":
            return jobDays > 28;
        default:
            return false;
    }
});
                        if (!matchesPublished) return false;
                    }
                }
            }

            return true;
        });

        currentPage = 1;

        requestAnimationFrame(() => {
            renderJobsList();
            updatePagination();
            updateJobCount();

            requestAnimationFrame(() => {
                updateFilterCounts();
                restoreFilterStates();
            });
        });

        // FIX 7: Only scroll if requested
        if (shouldScroll) {
            scrollToTop();
        }
    }

   function updateFilterCounts() {
       const activeFilters = {
           profession: getCheckedProfessions(),
           location: getCheckedLocations(),
           grade: [],
           published: [],
           searchTerm: document.getElementById('keywordSearch').value.toLowerCase().trim()
       };

       filterData.grade?.forEach(item => {
           const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
           const checkbox = document.getElementById(checkboxId);
           if (checkbox && checkbox.checked) {
               activeFilters.grade.push(item.name);
           }
       });

       filterData.published?.forEach(item => {
           const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
           const checkbox = document.getElementById(checkboxId);
           if (checkbox && checkbox.checked) {
               activeFilters.published.push(item.name);
           }
       });

       function jobMatchesOtherFilters(job, excludeCategory, excludeValue) {
           if (activeCategoryFilter !== 'all' && !categoryFilters[activeCategoryFilter].filter(job)) {
               return false;
           }

           if (activeFilters.searchTerm && excludeCategory !== 'search') {
               const sectors = job.sector || [];
               const employer = job.alternate_recruiter_name || job.recruiter_name;
               const matchesSearch = job.job_title.toLowerCase().includes(activeFilters.searchTerm) ||
                                   job.location_description.toLowerCase().includes(activeFilters.searchTerm) ||
                                   employer.toLowerCase().includes(activeFilters.searchTerm) ||
                                   job.short_description.toLowerCase().includes(activeFilters.searchTerm) ||
                                   sectors.some(s => s.toLowerCase().includes(activeFilters.searchTerm)) ||
                                   (job.grade && job.grade.toLowerCase().includes(activeFilters.searchTerm));
               if (!matchesSearch) return false;
           }

           if (excludeCategory !== 'profession' && activeFilters.profession.length > 0) {
               const sectors = job.sector || [];
               const employer = job.alternate_recruiter_name || job.recruiter_name;
               const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
               const matchesProfession = activeFilters.profession.some(profession => {
                   return searchText.includes(profession.toLowerCase()) ||
                          sectors.some(s => s.toLowerCase() === profession.toLowerCase());
               });
               if (!matchesProfession) return false;
           }

           if (excludeCategory !== 'location' && activeFilters.location.length > 0) {
               const jobLocation = job.location_description || '';
               const matchesLocation = activeFilters.location.some(location => {
                   if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                       if (!categoryFilters.overseas.filter(job)) return false;
                       const country = job.location_country || '';
                       const locationLower = jobLocation.toLowerCase();
                       const countryLower = country.toLowerCase();

                       if (location === 'Canada') {
                           return locationLower.includes('canada') || countryLower.includes('canada');
                       } else if (location === 'Australia') {
                           return locationLower.includes('australia') || countryLower.includes('australia');
                       } else if (location === 'New Zealand') {
                           return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                       } else if (location === 'Republic of Ireland') {
                           return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                  !locationLower.includes('northern') && !countryLower.includes('northern');
                       }
                       return countryLower.includes(location.toLowerCase());
                   } else {
                       const normalizedJobLocation = normalizeLocation(jobLocation);
                       const normalizedSearch = normalizeLocation(location);
                       return normalizedJobLocation.includes(normalizedSearch);
                   }
               });
               if (!matchesLocation) return false;
           }

           if (excludeCategory !== 'grade' && activeFilters.grade.length > 0) {
               if (!job.grade || !activeFilters.grade.includes(job.grade)) {
                   return false;
               }
           }

           if (excludeCategory !== 'published' && activeFilters.published.length > 0) {
               if (!job.published) return false;
               const jobDays = parseDaysFromPublished(job.published);
               if (!jobDays) return false;
const matchesPublished = activeFilters.published.some(selectedCategory => {
    switch(selectedCategory) {
        case "Last 3 Days": return jobDays <= 3;
        case "Last 7 Days": return jobDays <= 7;
        case "Last 14 Days": return jobDays <= 14;
        case "Last 28 Days": return jobDays <= 28;
        case "More than 28 Days": return jobDays > 28;
        default: return false;
    }
});
if (!matchesPublished) return false;
           }
           return true;
       }

       const activeJobs = filterActiveJobs(allJobsData);

       // Update all filter counts (code continues as before)
   }

   function restoreFilterStates() {
       const checkedFilters = {};

       document.querySelectorAll('.profession-parent-checkbox:checked, .profession-sub-checkbox:checked').forEach(cb => {
           checkedFilters[cb.id] = true;
       });

       document.querySelectorAll('.location-checkbox:checked, .location-sub-checkbox:checked').forEach(cb => {
           checkedFilters[cb.id] = true;
       });

       document.querySelectorAll('.filter-checkbox:checked').forEach(cb => {
           checkedFilters[cb.id] = true;
       });

       setTimeout(() => {
           Object.keys(checkedFilters).forEach(id => {
               const checkbox = document.getElementById(id);
               if (checkbox) {
                   checkbox.checked = true;
               }
           });

           document.querySelectorAll('.profession-parent-group').forEach(group => {
               const parentId = group.querySelector('.profession-parent-checkbox').id;
               const parentName = parentId.replace('profession_parent_', '').replace(/_/g, ' ');
               updateParentCheckboxState('profession', parentName);
           });
       }, 10);
   }

   function generateDynamicKeywords() {
       const keywordSet = new Set();
       const maxKeywords = 6;

       const activeJobs = filterActiveJobs(allJobsData);

       const professions = [];
       const grades = [];

       activeJobs.forEach(job => {
           if (job.sector && Array.isArray(job.sector)) {
               job.sector.forEach(s => {
                   if (!professions.includes(s)) {
                       professions.push(s);
                   }
               });
           }
           if (job.grade && !grades.includes(job.grade)) {
               grades.push(job.grade);
           }
       });

       const shuffleArray = (array) => {
           const arr = [...array];
           for (let i = arr.length - 1; i > 0; i--) {
               const j = Math.floor(Math.random() * (i + 1));
               [arr[i], arr[j]] = [arr[j], arr[i]];
           }
           return arr;
       };

       const shuffledProfessions = shuffleArray(professions);
       const shuffledGrades = shuffleArray(grades);

       for (let i = 0; i < Math.min(3, shuffledProfessions.length); i++) {
           keywordSet.add(shuffledProfessions[i]);
       }

       for (let i = 0; i < Math.min(3, shuffledGrades.length); i++) {
           keywordSet.add(shuffledGrades[i]);
       }

       keywords = Array.from(keywordSet).slice(0, maxKeywords);
   }

  function initApp() {
        console.log('InitApp called, allJobsData length:', allJobsData?.length);

        requestAnimationFrame(() => {
            syncJobsData();

            if (!allJobsData || allJobsData.length === 0) {
                if (window.allJobsData && window.allJobsData.length > 0) {
                    allJobsData = window.allJobsData;
                } else {
                    console.log('No jobs data available yet');
                    return;
                }
            }

            filteredJobs = filterActiveJobs(allJobsData);

            if (!professionHierarchy || !locationHierarchy) {
                initializeHierarchies();
            }

            requestAnimationFrame(() => {
                calculateFilterCounts();
                generateDynamicKeywords();
                renderKeywords();
                renderFilters();

                // Immediately render jobs without waiting for idle callback
                renderJobsList();
                updatePagination();
                updateJobCount();
                updateCategoryButtons();
                addEventListeners();
            });
        });
    }

  window.initApp = initApp;

   function syncJobsData() {
       if (window.allJobsData && window.allJobsData.length > 0) {
           allJobsData = window.allJobsData;
       }
   }

   function updateJobCount() {
       const jobCountDisplay = document.getElementById('jobCountDisplay');
       const countText = generateJobCountText();
       jobCountDisplay.innerHTML = `<div class="job-count-main">${countText}</div>`;
   }

   function getCurrentPageJobs() {
       const startIndex = (currentPage - 1) * jobsPerPage;
       const endIndex = startIndex + jobsPerPage;
       return filteredJobs.slice(startIndex, endIndex);
   }

   function updatePagination() {
       const totalJobs = filteredJobs.length;
       const totalPages = Math.ceil(totalJobs / jobsPerPage);
       const startJob = totalJobs > 0 ? (currentPage - 1) * jobsPerPage + 1 : 0;
       const endJob = Math.min(currentPage * jobsPerPage, totalJobs);

       document.getElementById('jobRangeStart').textContent = startJob;
       document.getElementById('jobRangeEnd').textContent = endJob;
       document.getElementById('totalJobsCount').textContent = totalJobs;

       const pageNumbersContainer = document.getElementById('pageNumbers');
       let startPage = Math.max(1, currentPage - 3);
       let endPage = Math.min(totalPages, startPage + 6);

       if (endPage - startPage < 6) {
           startPage = Math.max(1, endPage - 6);
       }

       let pageNumbersHTML = '';
       for (let i = startPage; i <= endPage; i++) {
           pageNumbersHTML += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})" aria-label="Go to page ${i}">${i}</button>`;
       }
       pageNumbersContainer.innerHTML = pageNumbersHTML;

       document.getElementById('firstBtn').disabled = currentPage === 1;
       document.getElementById('prevBtn').disabled = currentPage === 1;
       document.getElementById('nextBtn').disabled = currentPage === totalPages || totalPages === 0;
       document.getElementById('lastBtn').disabled = currentPage === totalPages || totalPages === 0;
   }

   function renderJobsList() {
       const jobsList = document.getElementById('jobsList');
       const pageJobs = getCurrentPageJobs();

       if (pageJobs.length === 0) {
           jobsList.innerHTML = '<div class="no-jobs-message">No jobs found matching your criteria.</div>';
           return;
       }

       const fragment = document.createDocumentFragment();
       const container = document.createElement('div');

       container.innerHTML = pageJobs.map(job => {
           const employer = job.alternate_recruiter_name || job.recruiter_name || 'Unknown Employer';
           return `
               <div class="job-card">
                   <div class="job-header">${job.job_title}</div>
                   <div class="job-body">
                       ${job.logo_url ? `<img src="${job.logo_url}" alt="${employer} Logo" class="nhs-logo" loading="lazy">` : ''}
                       <div class="job-details">
                           <ul>
                               <li><strong>Location:</strong> ${job.location_description}</li>
                               <li><strong>Salary:</strong> ${job.salary || 'Competitive'}</li>
                               <li><strong>Employer:</strong> ${employer}</li>
                           </ul>
                       </div>
                       <div class="job-description">${job.short_description}</div>
                       <button class="apply-btn" onclick="applyToJob(${job.id})" aria-label="View details of ${job.job_title.replace(/"/g, '&quot;')} at ${employer.replace(/"/g, '&quot;')} on BMJ Careers">View Details on BMJ Careers</button>
                   </div>
               </div>
           `;
       }).join('');

	   while (container.firstChild) {
           fragment.appendChild(container.firstChild);
       }

       jobsList.innerHTML = '';
       jobsList.appendChild(fragment);
   }

   function handleResize() {
       const currentWidth = window.innerWidth;

       const filterGroups = ['published', 'profession', 'grade', 'location'];
       filterGroups.forEach(groupName => {
           const arrow = document.getElementById(groupName + 'Arrow');
           const options = document.getElementById(groupName + 'Options');

           if (arrow && options && !options.classList.contains('collapsed')) {
               options.classList.add('collapsed');
               arrow.classList.add('collapsed');
               arrow.textContent = '▶';
           }
       });

       lastWindowWidth = currentWidth;
   }

   function addEventListeners() {
       const keywordSearch = document.getElementById('keywordSearch');
       keywordSearch.addEventListener('input', function() {
           clearTimeout(this.searchTimeout);
           this.searchTimeout = setTimeout(() => {
               applyFilters();
               updateCategoryButtons();
               scrollToTop();
           }, 100);
       });

       keywordSearch.addEventListener('keypress', function(e) {
           if (e.key === 'Enter') {
               clearTimeout(this.searchTimeout);
               applyFilters();
               updateCategoryButtons();
               scrollToTop();
           }
       });

       window.addEventListener('scroll', handleScroll, { passive: true });
       window.addEventListener('resize', perfUtils.debounce(handleResize, 300), { passive: true });
   }

   function initializeButtonStates() {
       const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
       const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;

       if (!searchTerm && !hasCheckedFilters && activeCategoryFilter === 'all') {
           document.getElementById('btn-all').classList.add('active');
       } else if (activeCategoryFilter === 'all') {
           document.getElementById('btn-all').classList.remove('active');
       }

       updateCategoryButtons();
   }

   // Make initApp globally accessible for API integration
   window.initApp = initApp;

   // Initialize the app when DOM is ready
   document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM Content Loaded, checking for jobs data...');

        // Check if data is already available
        if (window.allJobsData && window.allJobsData.length > 0) {
            console.log('Jobs data already available on DOMContentLoaded');
            initApp();
            initializeButtonStates();
        } else {
            // Start checking for data availability
            let checkCount = 0;
            const maxChecks = 60; // 30 seconds maximum wait

            const dataCheckInterval = setInterval(function() {
                checkCount++;

                if (window.allJobsData && window.allJobsData.length > 0) {
                    console.log(`Jobs data detected after ${checkCount * 500}ms:`, window.allJobsData.length, 'jobs');
                    clearInterval(dataCheckInterval);
                    syncJobsData();
                    initApp();
                    initializeButtonStates();
                } else if (checkCount >= maxChecks) {
                    console.log('Jobs data not available after 30 seconds');
                    clearInterval(dataCheckInterval);
                }
            }, 500);
        }
    });

   // Listen for data updates from the API
    window.addEventListener('jobsDataUpdated', function() {
        console.log('Jobs data updated event received');
        initApp();
    });

    // Listen for data updates from the server
    window.addEventListener('jobsDataLoaded', function() {
        console.log('Jobs data loaded event received');
        syncJobsData();
        initApp();
        initializeButtonStates();
    });


   // Check periodically if data is available
   let dataCheckInterval = setInterval(function() {
       if (window.allJobsData && window.allJobsData.length > 0) {
           console.log('Jobs data detected:', window.allJobsData.length, 'jobs');
           clearInterval(dataCheckInterval);
           syncJobsData();
           initApp();
       }
   }, 500);

   // Clear interval after 30 seconds to prevent infinite checking
   setTimeout(function() {
       clearInterval(dataCheckInterval);
   }, 30000);

   // Lazy load images
   if ('IntersectionObserver' in window) {
       const imageObserver = new IntersectionObserver((entries, observer) => {
           entries.forEach(entry => {
               if (entry.isIntersecting) {
                   const img = entry.target;
                   if (img.dataset.src) {
                       img.src = img.dataset.src;
                       img.removeAttribute('data-src');
                       observer.unobserve(img);
                   }
               }
           });
       });

       document.addEventListener('DOMContentLoaded', () => {
           document.querySelectorAll('img[data-src]').forEach(img => {
               imageObserver.observe(img);
           });
       });
   }

   // Optimize scroll performance
   let ticking = false;
   function requestTick() {
       if (!ticking) {
           window.requestAnimationFrame(handleScroll);
           ticking = true;
       }
   }
   window.addEventListener('scroll', requestTick, { passive: true });

</script>

<!-- Cross-Origin Style Communication Script -->
<script>
    (function() {
        'use strict';

        const WIDGET_CONFIG = {
            widgetId: 'bmj-careers-widget',
            version: '2.0.0'
        };

        const isInIframe = window.self !== window.top;
        const ALLOWED_ORIGINS = '*';

        let customCategoryConfig = null;
        let clientTrackingConfig = null;

        const trackingData = {
            sessionId: null,
            clientId: null,
            interactions: [],
            scrollDepth: 0,
            timeOnPage: 0,
            searches: [],
            filterChanges: [],
            jobClicks: []
        };

        function applyCustomCategories(categories) {
            if (!categories || typeof categories !== 'object') return;

            console.log('Applying custom categories:', categories);
            customCategoryConfig = categories;

            const categoryButtons = document.querySelectorAll('.category-btn');

            categoryButtons.forEach(btn => {
                const btnId = btn.id;
                const categoryKey = btnId.replace('btn-', '');

                if (categories[categoryKey]) {
                    const config = categories[categoryKey];

                    if (config.enabled === false) {
                        btn.style.display = 'none';
                    } else {
                        btn.style.display = '';

                        if (config.label) {
                            const textSpan = btn.querySelector('span:last-child');
                            if (textSpan) {
                                textSpan.textContent = config.label;
                            }
                        }

                        if (config.icon) {
                            const emojiSpan = btn.querySelector('.emoji');
                            if (emojiSpan) {
                                emojiSpan.textContent = config.icon;
                            }
                        }
                    }
                }
            });

            if (window.categoryFilters) {
                Object.keys(categories).forEach(key => {
                    const config = categories[key];
                    if (config.enabled !== false && window.categoryFilters[key]) {
                        const originalFilter = window.categoryFilters[key].filter;

                        window.categoryFilters[key] = {
                            name: config.label || window.categoryFilters[key].name,
                            keywords: config.keywords || [],
                            filter: function(job) {
                                if (!config.keywords || config.keywords.length === 0) {
                                    return originalFilter ? originalFilter(job) : true;
                                }

                                let searchText = '';
                                const searchIn = config.searchIn || ['title', 'description', 'sector', 'grade'];

                                searchIn.forEach(field => {
                                    switch(field) {
                                        case 'title':
                                            searchText += ' ' + (job.job_title || '');
                                            break;
                                        case 'description':
                                            searchText += ' ' + (job.short_description || '');
                                            break;
                                        case 'sector':
                                            if (job.sector && Array.isArray(job.sector)) {
                                                searchText += ' ' + job.sector.join(' ');
                                            }
                                            break;
                                        case 'grade':
                                            searchText += ' ' + (job.grade || '');
                                            break;
                                        case 'location':
                                            searchText += ' ' + (job.location_description || '');
                                            break;
                                        case 'employer':
                                            searchText += ' ' + (job.recruiter_name || '') + ' ' + (job.alternate_recruiter_name || '');
                                            break;
                                    }
                                });

                                searchText = searchText.toLowerCase();

                                return config.keywords.some(keyword =>
                                    searchText.includes(keyword.toLowerCase())
                                );
                            }
                        };
                    }
                });
            }
        }

        function initializeButtonStates() {
            const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
            const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;

            if (!searchTerm && !hasCheckedFilters && activeCategoryFilter === 'all') {
                document.getElementById('btn-all').classList.add('active');
            } else if (activeCategoryFilter === 'all') {
                document.getElementById('btn-all').classList.remove('active');
            }

            updateCategoryButtons();
        }

        function initializeTracking(config) {
            if (!config || !config.tracking) return;

            trackingData.sessionId = config.tracking.sessionId;
            trackingData.clientId = config.tracking.clientId;
            clientTrackingConfig = config.tracking.features || {};

            console.log('Tracking initialized:', trackingData.sessionId);

            if (clientTrackingConfig.trackInteractions) {
                trackInteractions();
            }

            if (clientTrackingConfig.trackScrollDepth) {
                trackScrollDepth();
            }

            if (clientTrackingConfig.trackSearches) {
                trackSearches();
            }

            if (clientTrackingConfig.trackFilters) {
                trackFilterChanges();
            }
        }

        function trackInteractions() {
            document.addEventListener('click', function(e) {
                const target = e.target;
                const data = {
                    element: target.tagName,
                    className: target.className,
                    id: target.id,
                    text: target.innerText?.substring(0, 50)
                };

                trackingData.interactions.push(data);
                sendTrackingEvent('interaction', data);
            });
        }

        function trackScrollDepth() {
            let maxScroll = 0;
            window.addEventListener('scroll', debounce(function() {
                const scrollPercentage = Math.round((window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100);
                if (scrollPercentage > maxScroll) {
                    maxScroll = scrollPercentage;
                    trackingData.scrollDepth = maxScroll;
                    sendTrackingEvent('scroll', { depth: maxScroll });
                }
            }, 500));
        }

        function trackSearches() {
            const searchInput = document.getElementById('keywordSearch');
            if (searchInput) {
                searchInput.addEventListener('change', function() {
                    const searchTerm = this.value;
                    trackingData.searches.push({
                        term: searchTerm,
                        timestamp: Date.now()
                    });
                    sendTrackingEvent('search', { searchTerm });
                });
            }
        }

        function trackFilterChanges() {
            document.addEventListener('click', function(e) {
                if (e.target.closest('.category-btn')) {
                    const btn = e.target.closest('.category-btn');
                    const categoryId = btn.id.replace('btn-', '');
                    sendTrackingEvent('filter_change', {
                        filterType: 'category',
                        filterValue: categoryId
                    });
                }

                if (e.target.matches('.filter-checkbox, .profession-sub-checkbox, .location-sub-checkbox')) {
                    sendTrackingEvent('filter_change', {
                        filterType: e.target.className,
                        filterValue: e.target.id,
                        checked: e.target.checked
                    });
                }
            });
        }

        function sendTrackingEvent(eventType, data) {
            if (!isInIframe) return;

            window.parent.postMessage({
                type: 'bmj-careers-event',
                eventType: eventType,
                data: data,
                timestamp: Date.now()
            }, '*');
        }

        const originalApplyToJob = window.applyToJob;
        window.applyToJob = function(jobId) {
            const job = allJobsData.find(j => j.id === jobId);

            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-job-click',
                    jobId: jobId,
                    jobTitle: job?.job_title || 'Unknown',
                    employer: job?.recruiter_name || job?.alternate_recruiter_name || 'Unknown'
                }, '*');
            }

            if (job && job.job_url) {
                window.open(job.job_url, '_blank', 'noopener,noreferrer');
            } else {
                window.open('https://www.bmj.com/careers/jobs/', '_blank', 'noopener,noreferrer');
            }
        };

        const originalApplyCategoryFilter = window.applyCategoryFilter;
        window.applyCategoryFilter = function(category) {
            activeCategoryFilter = category;

            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-filter-change',
                    filterType: 'category',
                    filterValue: category
                }, '*');
            }

            updateCategoryButtons();

            if (category === 'all') {
                document.getElementById('keywordSearch').value = '';

                document.querySelectorAll('.filter-checkbox, .profession-parent-checkbox, .profession-sub-checkbox, .location-checkbox, .location-sub-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.classList.remove('indeterminate');
                });

                document.getElementById('btn-all').classList.add('active');
            }

            applyFilters();
            scrollToTop();
        };

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        window.addEventListener('message', function(event) {
            const trustedOrigins = ['http://localhost:3000', 'https://careers.bmj.com', window.location.origin];
            if (event.origin && !trustedOrigins.includes(event.origin) && !event.origin.includes('bmj')) {
                console.warn('Untrusted origin:', event.origin);
                return;
            }

            if (!event.data || typeof event.data !== 'object') return;

            switch (event.data.type) {
                case 'bmj-careers-config':
                    if (event.data.categories) {
                        window.customCategoryConfig = event.data.categories;
                        if (typeof applyCategoryFilter === 'function') {
                            applyCategoryFilter('all');
                        }
                    }
                    break;

                case 'bmj-careers-tracking':
                    const { eventType, sessionId, clientId, clientName, data } = event.data;

                    window.widgetClientInfo = {
                        clientId: clientId,
                        clientName: clientName,
                        sessionId: sessionId
                    };

                    console.log('Received tracking config:', window.widgetClientInfo);
                    break;
            }
        });

        window.addEventListener('load', function() {
            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-ready',
                    widgetId: 'bmj-careers-widget',
                    version: '2.0.0'
                }, '*');
            }
        });

        function isAllowedOrigin(origin) {
            if (ALLOWED_ORIGINS === '*') return true;
            return ALLOWED_ORIGINS.includes(origin);
        }

        const applyCustomStyles = (function() {
            let styleElement = null;

            return function(styles) {
                // Style application code remains the same
            };
        })();

        function handleCommand(command, data) {
            switch(command) {
                case 'refresh':
                    location.reload();
                    break;
                case 'scrollToTop':
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    break;
                case 'requestConfig':
                    window.parent.postMessage({
                        type: 'bmj-careers-current-config',
                        categories: customCategoryConfig,
                        tracking: trackingData
                    }, '*');
                    break;
            }
        }

        function sendReadyMessage() {
            window.parent.postMessage({
                type: 'bmj-careers-ready',
                widgetId: WIDGET_CONFIG.widgetId,
                version: WIDGET_CONFIG.version,
                isInIframe: isInIframe,
                capabilities: {
                    customCategories: true,
                    enhancedTracking: true,
                    customStyles: true
                }
            }, '*');

            if (isInIframe) {
                setTimeout(() => {
                    window.parent.postMessage({
                        type: 'bmj-careers-request-config',
                        widgetId: WIDGET_CONFIG.widgetId
                    }, '*');
                }, 100);
            }

            console.log('BMJ Careers Widget initialized with enhanced features v2.0');
        }

        if (document.readyState === 'complete') {
            sendReadyMessage();
        } else {
            window.addEventListener('load', sendReadyMessage);
            document.addEventListener('DOMContentLoaded', sendReadyMessage);
        }

        window.BMJWidgetTracking = {
            getData: () => trackingData,
            getConfig: () => customCategoryConfig,
            sendEvent: sendTrackingEvent
        };
    })();
</script>
<!-- End Cross-Origin Style Communication Script -->
</body>
</html>
