<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BMJ Careers - Medical Jobs</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="main-wrapper">
    <div class="job-count-header">
        <div class="job-count-main" id="jobCountDisplay">
            Found 0 jobs
        </div>
        <div class="job-count-subtitle">
            Browse through available medical positions
        </div>
    </div>

    <div class="category-buttons-wrapper">
        <div class="category-buttons">
            <button class="category-btn active" onclick="applyCategoryFilter('all')" id="btn-all">
                <span class="emoji">üè•</span>
                <span>All Jobs</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('consultant')" id="btn-consultant">
                <span class="emoji">üë®‚Äç‚öïÔ∏è</span>
                <span>Consultant</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('gp')" id="btn-gp">
                <span class="emoji">ü©∫</span>
                <span>GP Jobs</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('overseas')" id="btn-overseas">
                <span class="emoji">üåç</span>
                <span>Overseas</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('training')" id="btn-training">
                <span class="emoji">üéì</span>
                <span>Training</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('special')" id="btn-special">
                <span class="emoji">‚ö°</span>
                <span>Special</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('research')" id="btn-research">
                <span class="emoji">üî¨</span>
                <span>Research</span>
            </button>
        </div>
    </div>

    <div class="content-container">
        <div class="sidebar" id="sidebar">
            <div class="search-section">
                <h3 class="search-title">Keyword Search</h3>
                <input type="text" class="search-input" id="keywordSearch" placeholder="Enter keywords...">

                <div class="keywords-section">
                    <label class="keywords-label">Popular Keywords</label>
                    <div class="keywords-list" id="keywordsList">
                    </div>
                </div>
            </div>

            <div class="filters-section">
                <h3 class="filters-title">Filter By Category</h3>
                <div id="filtersContainer">
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="jobs-section">
                <div id="jobsList">
                </div>
            </div>

            <div class="pagination-section">
                <div class="pagination-info">
                    Showing <span id="jobRangeStart">1</span>-<span id="jobRangeEnd">6</span> of <span id="totalJobsCount">0</span> jobs
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" id="firstBtn" onclick="goToPage(1)">First</button>
                    <button class="pagination-btn" id="prevBtn" onclick="goToPage(getCurrentPage() - 1)">‚Äπ</button>
                    <span id="pageNumbers"></span>
                    <button class="pagination-btn" id="nextBtn" onclick="goToPage(getCurrentPage() + 1)">‚Ä∫</button>
                    <button class="pagination-btn" id="lastBtn" onclick="goToPage(Math.ceil(filteredJobs.length / jobsPerPage))">Last</button>
                </div>
            </div>
        </div>
    </div>
</div>

<button class="scroll-to-top" id="scrollToTop" title="Move To Top" onclick="scrollToTop()">
    ‚Üë
</button>

<script>
    // Initialize with empty array - will be populated by API
    let allJobsData = [];

    // Dynamic hierarchy objects that will be populated from data
    let dynamicProfessionHierarchy = {};
    let dynamicLocationHierarchy = {};

    const professionHierarchy = {
        'GP': {
            subcategories: [
                'Digital GP',
                'GP Partner',
                'GP Trainee',
                'Locum GP',
                'Salaried GP'
            ]
        },
        'Specialist Doctor': {
            subcategories: [
                'Acute Internal Medicine',
                'Adult Critical Care',
                'Anaesthesia',
                'Anatomy',
                'Audiological Medicine',
                'BioChemistry',
                'Cardiology',
                'Cardiothoracic Surgery',
                'Cytopathology',
                'Dermatology',
                'Diabetes & Endocrinology',
                'Emergency medicine',
                'ENT/Otolaryngology',
                'Forensic Pathology',
                'Gastroenterology',
                'General Internal Medicine',
                'General Surgery',
                'Genetics',
                'Genitourinary Medicine',
                'Geriatric Medicine',
                'GP in Emergency Medicine',
                'Gynaecological Oncology',
                'Haematology',
                'Hepatology',
                'Histopathology',
                'Immunology',
                'Intensive and Critical Care Medicine',
                'Locum Doctor',
                'Maternal and Foetal Medicine',
                'Metabolic Medicine',
                'Microbiology, Virology and Infectious Diseases',
                'Neonatology',
                'Nephrology/Renal Medicine',
                'Neurology',
                'Neuropathology',
                'Neurophysiology',
                'Neurosurgery',
                'Nuclear Medicine',
                'Obstetrics and Gynaecology',
                'Occupational Medicine',
                'Oncology',
                'Ophthalmology',
                'Oral and Maxillofacial Surgery',
                {
                    name: 'Paediatrics',
                    subcategories: [
                        'Paediatric cardiology',
                        'Paediatric diabetes and endocrinology',
                        'Paediatric emergency medicine',
                        'Paediatric gastroenterology, Hepatology and Nutrition',
                        'Paediatric immunology, infectious diseases and allergy',
                        'Paediatric intensive Care Medicine',
                        'Paediatric nephrology',
                        'Paediatric neurodisability',
                        'Paediatric neurology',
                        'Paediatric oncology',
                        'Paediatric palliative Medicine',
                        'Paediatric pathology',
                        'Paediatric respiratory medicine',
                        'Paediatric rheumatology',
                        'Paediatric surgery'
                    ]
                },
                'Palliative medicine',
                'Pathology',
                'Pharmaceutical medicine',
                'Pharmalogy and Therapeutics',
                'Physiology',
                'Plastic Surgery',
                'Pre Hospital Emergency Medicine',
                {
                    name: 'Psychiatry',
                    subcategories: [
                        'Child and Adolescent Psychiatry',
                        'Community Psychiatry',
                        'Forensic Psychiatry',
                        'General Adult Psychiatry',
                        'Liaison Psychiatry',
                        'Medical Psychotherapy',
                        'Old-age Psychiatry',
                        'Psychiatry of eating disorders',
                        'Psychiatry of learning disablity',
                        'Rehabilition Psychiatry',
                        'Substance Misuse Psychiatry'
                    ]
                },
                'Public Health Medicine and Epidemiology',
                'Radiology',
                'Rahabilitation Medicine',
                'Respiratory Medicine',
                'Rheumatology',
                'RMO',
                'Sexual and Reproductive Health',
                'Spinal Injuries',
                'Sports and Exercise Medicine',
                'Stroke Medicine',
                'Trauma and Orthopaedics',
                'Tropical Medicine',
                'Urogynaecology',
                'Urology',
                'Vascular Surgery'
            ]
        },
        'Other Medical Roles': {
            subcategories: [
                'Armed Forces Doctor',
                'Commissioning',
                'Government and Health Policy',
                'Healthtech',
                'International medical Jobs',
                'Medical Education and Training',
                'Medical Examiner',
                'Medical leadership',
                'Medical training Initiative',
                'Medico-legal',
                'Occupational health',
                'Pharmaceutical',
                'Public Health',
                'Special Appointements'
            ]
        },
        'Nurse': {
            subcategories: [
                {
                    name: 'Adult Nurse',
                    subcategories: [
                        'A&E Nurse',
                        'Acute Nurse',
                        'Anaesthesia Nurse',
                        'Cancer Nurse',
                        'Cardiology Nurse',
                        'Elderly Care Nurse',
                        'Fertility Nurse',
                        'ICU Nurse',
                        'Ophthalmics Nurse',
                        'Palliative Care Nurse',
                        'Renal Nurse',
                        'Respiratory Nurse',
                        'Sexual Health Nurse',
                        'Theatre Nurse',
                        'Trauma Nurse'
                    ]
                },
                {
                    name: 'Community Nurse',
                    subcategories: [
                        'Care Home Nurse',
                        'Community MidWife',
                        'District Nurse',
                        'Health Visitor',
                        'Mental Health Nurse - Community',
                        'School Nurse'
                    ]
                },
                'General Practice Nurse',
                'Learning Disablity Nurse',
                {
                    name: 'Mental Health Nurse',
                    subcategories: [
                        'Adult Mental Health Nurse',
                        'CAMHS Nurse',
                        'Community Mental Health Nurse',
                        'Eating Disorders Nurse',
                        'Forensic Mental Health Nurse',
                        'Mental Health Liaison Nurse',
                        'Mental health Nurse in Primary care',
                        'Old Age Mental Health Care Nurse',
                        'Perinatal Mental Health Nurse',
                        'Rehabilitation Mental Health Nurse',
                        'Substance Misuse Nurse'
                    ]
                },
                'Midwife',
                'Nurse associate',
                {
                    name: 'Paediatric Nurse',
                    subcategories: [
                        'Neonatal Nurse',
                        'Paediatric A&E Nurse'
                    ]
                },
                'Prison Nurse'
            ]
        },
        'Mental Health Professional': {
            subcategories: [
                'CBT Therapist',
                'Counsellor',
                'Mental health Practitioner',
                'Psychologist',
                'Psychotherapist'
            ]
        },
        'Pharmacist': {
            subcategories: [
                'Pharmacy technician'
            ]
        },
        'Physician Associate': {
            subcategories: []
        },
        'Senior Manager': {
            subcategories: []
        },
        'Other Health Profession': {
            subcategories: []
        }
    };

    const locationHierarchy = {
        'London': {
            subcategories: [
                'Central London',
                'North London',
                'South London',
                'East London',
                'West London',
                'Greater London'
            ]
        },
        'South East England': {
            subcategories: [
                'Brighton',
                'Canterbury',
                'Oxford',
                'Reading',
                'Southampton',
                'Portsmouth',
                'Guildford',
                'Maidstone',
                'Crawley',
                'Slough',
                'Milton Keynes',
                'Luton',
                'Medway',
                'Ashford',
                'Basingstoke',
                'Eastbourne',
                'Hastings',
                'Worthing',
                'Bracknell',
                'Maidenhead',
                'Windsor',
                'Berkshire',
                'Buckinghamshire',
                'East Sussex',
                'Hampshire',
                'Isle of Wight',
                'Kent',
                'Oxfordshire',
                'Surrey',
                'West Sussex'
            ]
        },
        'South West England': {
            subcategories: [
                'Bristol',
                'Plymouth',
                'Bournemouth',
                'Swindon',
                'Gloucester',
                'Exeter',
                'Bath',
                'Cheltenham',
                'Torbay',
                'Poole',
                'Taunton',
                'Salisbury',
                'Truro',
                'Weymouth',
                'Weston-super-Mare',
                'Yeovil',
                'Barnstaple',
                'Bridgwater',
                'Cornwall',
                'Devon',
                'Dorset',
                'Gloucestershire',
                'Somerset',
                'Wiltshire'
            ]
        },
        'East of England': {
            subcategories: [
                'Cambridge',
                'Norwich',
                'Peterborough',
                'Ipswich',
                'Colchester',
                'Southend-on-Sea',
                'Luton',
                'Watford',
                'St Albans',
                'Chelmsford',
                'Basildon',
                'Harlow',
                'Stevenage',
                'Bedford',
                'Bury St Edmunds',
                'Hertford',
                'Huntingdon',
                'Kings Lynn',
                'Lowestoft',
                'Bedfordshire',
                'Cambridgeshire',
                'Essex',
                'Hertfordshire',
                'Norfolk',
                'Suffolk'
            ]
        },
        'East Midlands': {
            subcategories: [
                'Nottingham',
                'Leicester',
                'Derby',
                'Northampton',
                'Lincoln',
                'Mansfield',
                'Chesterfield',
                'Kettering',
                'Loughborough',
                'Boston',
                'Grantham',
                'Corby',
                'Hinckley',
                'Newark',
                'Wellingborough',
                'Derbyshire',
                'Leicestershire',
                'Lincolnshire',
                'Northamptonshire',
                'Nottinghamshire',
                'Rutland'
            ]
        },
        'West Midlands': {
            subcategories: [
                'Birmingham',
                'Coventry',
                'Wolverhampton',
                'Stoke-on-Trent',
                'Solihull',
                'Walsall',
                'Dudley',
                'Sandwell',
                'Worcester',
                'Shrewsbury',
                'Telford',
                'Stafford',
                'Warwick',
                'Hereford',
                'Stratford-upon-Avon',
                'Lichfield',
                'Tamworth',
                'Redditch',
                'Kidderminster',
                'Herefordshire',
                'Shropshire',
                'Staffordshire',
                'Warwickshire',
                'Worcestershire'
            ]
        },
        'Yorkshire and the Humber': {
            subcategories: [
                'Leeds',
                'Sheffield',
                'Bradford',
                'Hull',
                'York',
                'Huddersfield',
                'Middlesbrough',
                'Doncaster',
                'Rotherham',
                'Wakefield',
                'Barnsley',
                'Halifax',
                'Harrogate',
                'Scarborough',
                'Dewsbury',
                'Keighley',
                'Scunthorpe',
                'Grimsby',
                'East Yorkshire',
                'North Yorkshire',
                'South Yorkshire',
                'West Yorkshire'
            ]
        },
        'North West England': {
            subcategories: [
                'Manchester',
                'Liverpool',
                'Warrington',
                'Bolton',
                'Blackpool',
                'Preston',
                'Chester',
                'Stockport',
                'Oldham',
                'Rochdale',
                'Salford',
                'Wigan',
                'Bury',
                'Blackburn',
                'St Helens',
                'Carlisle',
                'Lancaster',
                'Crewe',
                'Burnley',
                'Macclesfield',
                'Barrow-in-Furness',
                'Runcorn',
                'Ellesmere Port',
                'Cheshire',
                'Cumbria',
                'Greater Manchester',
                'Lancashire',
                'Merseyside'
            ]
        },
        'North East England': {
            subcategories: [
                'Newcastle upon Tyne',
                'Sunderland',
                'Durham',
                'Gateshead',
                'Middlesbrough',
                'Stockton-on-Tees',
                'Darlington',
                'Hartlepool',
                'South Shields',
                'Tynemouth',
                'Washington',
                'Ashington',
                'Blyth',
                'Redcar',
                'Bishop Auckland',
                'County Durham',
                'Northumberland',
                'Tyne and Wear',
                'Teesside'
            ]
        },
        'Scotland': {
            subcategories: [
                'Edinburgh',
                'Glasgow',
                'Aberdeen',
                'Dundee',
                'Inverness',
                'Perth',
                'Stirling',
                'Paisley',
                'East Kilbride',
                'Livingston',
                'Hamilton',
                'Cumbernauld',
                'Dunfermline',
                'Kirkcaldy',
                'Ayr',
                'Kilmarnock',
                'Greenock',
                'Coatbridge',
                'Glenrothes',
                'Falkirk'
            ]
        },
        'Wales': {
            subcategories: [
                'Cardiff',
                'Swansea',
                'Newport',
                'Wrexham',
                'Barry',
                'Neath',
                'Cwmbran',
                'Llanelli',
                'Rhondda',
                'Merthyr Tydfil',
                'Bridgend',
                'Caerphilly',
                'Port Talbot',
                'Pontypridd',
                'Aberdare',
                'Colwyn Bay',
                'Rhyl',
                'Flintshire',
                'Gwynedd',
                'Anglesey'
            ]
        },
        'Northern Ireland': {
            subcategories: [
                'Belfast',
                'Derry',
                'Lisburn',
                'Newtownabbey',
                'Bangor',
                'Craigavon',
                'Castlereagh',
                'Ballymena',
                'Newtownards',
                'Newry',
                'Carrickfergus',
                'Coleraine',
                'Omagh',
                'Larne',
                'Banbridge',
                'Armagh',
                'Dungannon',
                'Enniskillen',
                'Strabane',
                'Antrim'
            ]
        },
        'Overseas': {
            subcategories: [
                'Republic of Ireland',
                'Channel Islands',
                'Isle of Man',
                'Europe',
                'Middle East',
                'Asia Pacific',
                'North America',
                'South America',
                'Africa',
                'Australia',
                'New Zealand',
                'Other International'
            ]
        }
    };

    let filterData = {};
    let keywords = [];
    let currentPage = 1;
    const jobsPerPage = 10;
    let filteredJobs = [];
    let activeCategoryFilter = 'all';
    let lastWindowWidth = window.innerWidth;

    const categoryFilters = {
        all: {
            name: 'All Jobs',
            keywords: [],
            filter: () => true
        },
        consultant: {
            name: 'Consultant',
            keywords: ['consultant', 'specialist doctor', 'associate specialist'],
            filter: (job) => {
                const searchText = `${job.job_title} ${job.short_description} ${job.sector ? job.sector.join(' ') : ''} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                return categoryFilters.consultant.keywords.some(keyword =>
                    searchText.includes(keyword.toLowerCase())
                );
            }
        },
        gp: {
            name: 'GP Jobs',
            keywords: ['gp', 'general practitioner', 'family doctor', 'primary care'],
            filter: (job) => {
                const searchText = `${job.job_title} ${job.short_description} ${job.sector ? job.sector.join(' ') : ''} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                return categoryFilters.gp.keywords.some(keyword =>
                    searchText.includes(keyword.toLowerCase())
                );
            }
        },
        overseas: {
            name: 'Overseas',
            keywords: [],
            filter: (job) => {
                // Check if job is overseas (not in UK)
                const country = (job.location_country || '').toLowerCase();
                const locationDesc = (job.location_description || '').toLowerCase();
                const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales', 'northern ireland', 'britain', 'great britain'];
                const ukRegions = Object.keys(locationHierarchy).filter(k => k !== 'Overseas').map(k => k.toLowerCase());

                // First check if country explicitly says it's in UK
                if (country && ukCountries.some(uk => country.includes(uk))) {
                    return false;
                }

                // Check if location description contains any UK region names
                const hasUKRegion = ukRegions.some(region => {
                    const normalizedRegion = region.toLowerCase();
                    return locationDesc === normalizedRegion ||
                           locationDesc.includes(`, ${normalizedRegion}`) ||
                           locationDesc.includes(`${normalizedRegion},`) ||
                           locationDesc.startsWith(`${normalizedRegion} `);
                });

                if (hasUKRegion) {
                    return false;
                }

                // Check for UK cities from the hierarchy
                for (const [region, data] of Object.entries(locationHierarchy)) {
                    if (region !== 'Overseas') {
                        for (const city of data.subcategories) {
                            const normalizedCity = city.toLowerCase();
                            if (locationDesc === normalizedCity ||
                                locationDesc.includes(`, ${normalizedCity}`) ||
                                locationDesc.includes(`${normalizedCity},`) ||
                                locationDesc.startsWith(`${normalizedCity} `)) {
                                return false;
                            }
                        }
                    }
                }

                // Check for UK postcodes pattern
                const ukPostcodePattern = /\b[A-Z]{1,2}\d{1,2}[A-Z]?\s*\d[A-Z]{2}\b/i;
                if (ukPostcodePattern.test(job.location_description)) {
                    return false;
                }

                // If country is specified and it's not UK, it's overseas
                if (country && !ukCountries.some(uk => country.includes(uk))) {
                    return true;
                }

                // If we can't determine, assume it's UK
                return false;
            }
        },
        training: {
            name: 'Training',
            keywords: ['training', 'education', 'foundation', 'registrar', 'fellowship', 'residency', 'trainee'],
            filter: (job) => {
                const searchText = `${job.job_title} ${job.short_description} ${job.sector ? job.sector.join(' ') : ''} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                return categoryFilters.training.keywords.some(keyword =>
                    searchText.includes(keyword.toLowerCase())
                );
            }
        },
        special: {
            name: 'Special',
            keywords: ['locum', 'temporary', 'interim', 'contract', 'special', 'urgent', 'immediate'],
            filter: (job) => {
                const searchText = `${job.job_title} ${job.short_description} ${job.sector ? job.sector.join(' ') : ''} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                return categoryFilters.special.keywords.some(keyword =>
                    searchText.includes(keyword.toLowerCase())
                );
            }
        },
        research: {
            name: 'Research',
            keywords: ['research', 'clinical trial', 'study', 'academic', 'university', 'scientist', 'laboratory'],
            filter: (job) => {
                const searchText = `${job.job_title} ${job.short_description} ${job.sector ? job.sector.join(' ') : ''} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                return categoryFilters.research.keywords.some(keyword =>
                    searchText.includes(keyword.toLowerCase())
                );
            }
        }
    };

    // All function definitions remain the same
    function normalizeLocation(location) {
        return location.toLowerCase().trim()
            .replace(/\s+/g, ' ')
            .replace(/[^\w\s-]/g, '');
    }

    function categorizeLocation(locationStr) {
        const normalized = normalizeLocation(locationStr);

        // First check against dynamic hierarchy
        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            if (normalizeLocation(region) === normalized) {
                return { region: region, isRegion: true };
            }
        }

        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            for (const subcategory of data.subcategories) {
                if (normalizeLocation(subcategory) === normalized) {
                    return { region: region, subcategory: subcategory, isRegion: false };
                }
            }
        }

        const ukCountries = ['england', 'scotland', 'wales', 'northern ireland', 'uk', 'united kingdom', 'britain', 'great britain','Nationwide'
,'Homeworking'];

        // Extract country from location string
        const locationLower = locationStr.toLowerCase();
        const isUK = ukCountries.some(country => locationLower.includes(country));

        if (!isUK) {
            // Extract country name for overseas locations
            let countryName = 'Other International';

            // Common patterns for country extraction
            if (locationLower.includes('canada')) countryName = 'Canada';
            else if (locationLower.includes('australia')) countryName = 'Australia';
            else if (locationLower.includes('new zealand')) countryName = 'New Zealand';
            else if (locationLower.includes('ireland') && !locationLower.includes('northern')) countryName = 'Republic of Ireland';
            else if (locationLower.includes('usa') || locationLower.includes('united states')) countryName = 'North America';
            else if (locationLower.includes('dubai') || locationLower.includes('uae')) countryName = 'Middle East';

            return { region: 'Overseas', subcategory: countryName, isRegion: false };
        }

        if (normalized.includes('london')) {
            return { region: 'London', subcategory: 'Greater London', isRegion: false };
        }

        return { region: 'Other UK', subcategory: locationStr, isRegion: false };
    }

    function getCurrentDate() {
        return new Date();
    }

    function parseDaysFromPublished(publishedString) {
        if (!publishedString) return null;

        const lowerStr = publishedString.toLowerCase();

        if (lowerStr.includes('24 hours') || lowerStr.includes('today')) {
            return 1;
        } else if (lowerStr.includes('yesterday')) {
            return 1;
        } else if (lowerStr.includes('last') && lowerStr.includes('days')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) : null;
        } else if (lowerStr.includes('week')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 7 : 7;
        } else if (lowerStr.includes('month')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 30 : 30;
        }

        return null;
    }

    function categorizePublishedString(publishedString) {
        const days = parseDaysFromPublished(publishedString);

        if (!days) return null;

        if (days <= 3) return "Last 3 Days";
        else if (days <= 7) return "Last 7 Days";
        else if (days <= 14) return "Last 14 Days";
        else if (days <= 28) return "Last 28 Days";
        else return "More than 28 Days";
    }

    function filterActiveJobs(jobs) {
        const currentDate = getCurrentDate();
        return jobs.filter(job => {
            if (job.job_end_date) {
                const endDate = new Date(job.job_end_date);
                return endDate >= currentDate;
            }
            return true;
        });
    }

    window.applyCategoryFilter = function(category) {
        activeCategoryFilter = category;
        updateCategoryButtons();
        applyFilters();
        scrollToTop();
    };

    window.selectKeyword = function(keyword) {
        document.getElementById('keywordSearch').value = keyword;
        applyFilters();
        scrollToTop();
    };

    window.toggleFilterGroup = function(groupName) {
        const arrow = document.getElementById(groupName + 'Arrow');
        const options = document.getElementById(groupName + 'Options');

        if (options.classList.contains('collapsed')) {
            options.classList.remove('collapsed');
            arrow.classList.remove('collapsed');
            arrow.textContent = '‚ñº';
        } else {
            options.classList.add('collapsed');
            arrow.classList.add('collapsed');
            arrow.textContent = '‚ñ∂';
        }
    };

    window.toggleParentCategory = function(category, parentName) {
        const arrow = document.getElementById(`${category}_parent_arrow_${parentName.replace(/\s+/g, '_')}`);
        const subcategories = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);

        if (subcategories.classList.contains('collapsed')) {
            subcategories.classList.remove('collapsed');
            arrow.classList.remove('collapsed');
            arrow.textContent = '‚ñº';
        } else {
            subcategories.classList.add('collapsed');
            arrow.classList.add('collapsed');
            arrow.textContent = '‚ñ∂';
        }
    };

    window.handleParentCategoryChange = function(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const isChecked = parentCheckbox.checked;

        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        subCheckboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
        });

        applyFilters();
        scrollToTop();
    };

    window.handleSubCategoryChange = function(category, parentName, subName) {
        updateParentCheckboxState(category, parentName);
        applyFilters();
        scrollToTop();
    };

    window.toggleProfessionParent = function(parentName) {
        toggleParentCategory('profession', parentName);
    };

    window.handleParentProfessionChange = function(parentName) {
        handleParentCategoryChange('profession', parentName);
    };

    window.handleSubProfessionChange = function(parentName, subName) {
        handleSubCategoryChange('profession', parentName, subName);
    };

    window.handleFilterChange = function(category, value) {
        applyFilters();
        scrollToTop();
    };

window.applyToJob = function(jobId) {
    const job = allJobsData.find(j => j.id === jobId);
    if (job && job.job_url) {
        window.open(job.job_url, '_blank', 'noopener,noreferrer');
    } else {
        window.open('https://www.bmj.com/careers/jobs/', '_blank', 'noopener,noreferrer');
    }
};

    window.goToPage = function(page) {
        const totalPages = Math.ceil(filteredJobs.length / jobsPerPage);
        if (page < 1 || page > totalPages) return;

        currentPage = page;
        renderJobsList();
        updatePagination();

        document.querySelector('.jobs-section').scrollIntoView({ behavior: 'smooth' });
    };

    window.getCurrentPage = function() {
        return currentPage;
    };

    window.scrollToTop = function() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    };

    function handleScroll() {
        const scrollToTopBtn = document.getElementById('scrollToTop');
        if (window.pageYOffset > 300) {
            scrollToTopBtn.classList.add('show');
        } else {
            scrollToTopBtn.classList.remove('show');
        }
    }

    function updateCategoryButtons() {
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        const activeBtn = document.getElementById(`btn-${activeCategoryFilter}`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }
    }

    function updateParentCheckboxState(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        const checkedCount = Array.from(subCheckboxes).filter(cb => cb.checked).length;
        const totalCount = subCheckboxes.length;

        if (checkedCount === 0) {
            parentCheckbox.checked = false;
            parentCheckbox.classList.remove('indeterminate');
        } else if (checkedCount === totalCount) {
            parentCheckbox.checked = true;
            parentCheckbox.classList.remove('indeterminate');
        } else {
            parentCheckbox.checked = false;
            parentCheckbox.classList.add('indeterminate');
        }
    }

    // Build dynamic hierarchies from job data
    function buildDynamicHierarchies() {
        // Deep copy the base hierarchies
        dynamicProfessionHierarchy = JSON.parse(JSON.stringify(professionHierarchy));
        dynamicLocationHierarchy = JSON.parse(JSON.stringify(locationHierarchy));

        const activeJobs = filterActiveJobs(allJobsData);

        // Process locations for Overseas
        activeJobs.forEach(job => {
            const location = job.location_description || '';
            const country = job.location_country || '';

            // Check if it's an overseas job
            if (categoryFilters.overseas.filter(job)) {
                let countryName = 'Other International';

                // Extract country from location or country field
                const locationLower = location.toLowerCase();
                const countryLower = country.toLowerCase();

                if (locationLower.includes('canada') || countryLower.includes('canada')) {
                    countryName = 'Canada';
                } else if (locationLower.includes('australia') || countryLower.includes('australia')) {
                    countryName = 'Australia';
                } else if (locationLower.includes('new zealand') || countryLower.includes('new zealand')) {
                    countryName = 'New Zealand';
                } else if ((locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                          !locationLower.includes('northern') && !countryLower.includes('northern')) {
                    countryName = 'Republic of Ireland';
                } else if (locationLower.includes('usa') || locationLower.includes('united states') ||
                          countryLower.includes('usa') || countryLower.includes('united states')) {
                    countryName = 'North America';
                } else if (locationLower.includes('dubai') || locationLower.includes('uae') ||
                          countryLower.includes('dubai') || countryLower.includes('uae')) {
                    countryName = 'Middle East';
                } else if (countryLower && !countryLower.includes('kingdom')) {
                    // Use the country field if it's not UK
                    countryName = country;
                }

                // Add to Overseas subcategories if not already present
                if (!dynamicLocationHierarchy.Overseas.subcategories.includes(countryName)) {
                    dynamicLocationHierarchy.Overseas.subcategories.push(countryName);
                }
            }
        });

        // Sort Overseas subcategories alphabetically
        dynamicLocationHierarchy.Overseas.subcategories.sort();

        // Process professions from sectors
        activeJobs.forEach(job => {
            if (job.sector && Array.isArray(job.sector)) {
                job.sector.forEach(sector => {
                    // Add new sectors to appropriate categories
                    // This is where you would add logic to categorize new professions
                    // For now, we'll just ensure existing ones are included
                });
            }
        });
    }

    // Updated count functions to work with current filter state
    function countJobsForLocationCategoryWithFilters(categoryName, subcategories, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except location)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply profession filters
        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                return checkedProfessions.some(profession => {
                    return searchText.includes(profession.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Now count for this specific location category
        return jobs.filter(job => {
            const location = job.location_description || '';
            const categorized = categorizeLocation(location);

            if (categorized.region === categoryName) {
                return true;
            }

            return subcategories.some(subcat => {
                const normalizedSubcat = normalizeLocation(subcat);
                const normalizedLocation = normalizeLocation(location);
                return normalizedLocation.includes(normalizedSubcat);
            });
        }).length;
    }

    function countJobsForSpecificLocationWithFilters(locationName, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except location)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply profession filters
        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                return checkedProfessions.some(profession => {
                    return searchText.includes(profession.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Check if this location is Overseas subcategory
        const isOverseasLocation = dynamicLocationHierarchy.Overseas.subcategories.includes(locationName);

        if (isOverseasLocation) {
            // Special handling for overseas locations
            return jobs.filter(job => {
                // First check if it's an overseas job
                if (!categoryFilters.overseas.filter(job)) {
                    return false;
                }

                const location = job.location_description || '';
                const country = job.location_country || '';
                const locationLower = location.toLowerCase();
                const countryLower = country.toLowerCase();

                // Match specific country
                if (locationName === 'Canada') {
                    return locationLower.includes('canada') || countryLower.includes('canada');
                } else if (locationName === 'Australia') {
                    return locationLower.includes('australia') || countryLower.includes('australia');
                } else if (locationName === 'New Zealand') {
                    return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                } else if (locationName === 'Republic of Ireland') {
                    return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                           !locationLower.includes('northern') && !countryLower.includes('northern');
                } else if (locationName === 'North America') {
                    return locationLower.includes('usa') || locationLower.includes('united states') ||
                           countryLower.includes('usa') || countryLower.includes('united states');
                } else if (locationName === 'Middle East') {
                    return locationLower.includes('dubai') || locationLower.includes('uae') ||
                           countryLower.includes('dubai') || countryLower.includes('uae');
                } else if (locationName === country) {
                    return true;
                }

                return false;
            }).length;
        } else {
            // Regular location matching
            return jobs.filter(job => {
                const location = job.location_description || '';
                const normalizedLocation = normalizeLocation(location);
                const normalizedSearch = normalizeLocation(locationName);
                return normalizedLocation.includes(normalizedSearch);
            }).length;
        }
    }

    function buildLocationHierarchy() {
        const locationData = [];

        // Get current filter state
        const currentFilters = {};

        // Check if London has jobs
        const londonCount = countJobsForSpecificLocationWithFilters('London', currentFilters);
        if (londonCount > 0) {
            locationData.push({
                name: 'London',
                count: londonCount,
                subcategories: []
            });
        }

        Object.entries(dynamicLocationHierarchy).forEach(([parentName, parentData]) => {
            if (parentName === 'London') return;

            const parentCount = countJobsForLocationCategoryWithFilters(parentName, parentData.subcategories, currentFilters);

            if (parentCount > 0) {
                const subcategoryData = [];

                parentData.subcategories.forEach(subcategory => {
                    const count = countJobsForSpecificLocationWithFilters(subcategory, currentFilters);
                    if (count > 0) {
                        subcategoryData.push({ name: subcategory, count });
                    }
                });

                locationData.push({
                    name: parentName,
                    count: parentCount,
                    subcategories: subcategoryData
                });
            }
        });

        return locationData;
    }

    function getCheckedLocations() {
        const checkedLocations = [];

        const simpleCheckboxes = document.querySelectorAll('.location-checkbox:checked');
        simpleCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                // Remove the count from the location name
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        const subCheckboxes = document.querySelectorAll('.location-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                // Remove the count from the location name
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        return checkedLocations;
    }

    function countJobsForProfessionCategoryWithFilters(categoryName, subcategories, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except profession)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply location filters
        const checkedLocations = getCheckedLocations();
        if (checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';

                return checkedLocations.some(location => {
                    // Check if this is an Overseas location
                    if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                        // First check if it's an overseas job
                        if (!categoryFilters.overseas.filter(job)) {
                            return false;
                        }

                        const country = job.location_country || '';
                        const locationLower = jobLocation.toLowerCase();
                        const countryLower = country.toLowerCase();

                        // Match specific country
                        if (location === 'Canada') {
                            return locationLower.includes('canada') || countryLower.includes('canada');
                        } else if (location === 'Australia') {
                            return locationLower.includes('australia') || countryLower.includes('australia');
                        } else if (location === 'New Zealand') {
                            return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                        } else if (location === 'Republic of Ireland') {
                            return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                   !locationLower.includes('northern') && !countryLower.includes('northern');
                        } else if (location === 'North America') {
                            return locationLower.includes('usa') || locationLower.includes('united states') ||
                                   countryLower.includes('usa') || countryLower.includes('united states');
                        } else if (location === 'Middle East') {
                            return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                   countryLower.includes('dubai') || countryLower.includes('uae');
                        } else if (location === country) {
                            return true;
                        }

                        return false;
                    } else {
                        // Regular location matching
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    }
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Now count for this specific profession category
        return jobs.filter(job => {
            const sectors = job.sector || [];
            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();

            return subcategories.some(subcat => {
                if (typeof subcat === 'string') {
                    return searchText.includes(subcat.toLowerCase()) || sectors.some(s => s.toLowerCase() === subcat.toLowerCase());
                } else if (typeof subcat === 'object' && subcat.subcategories) {
                    return searchText.includes(subcat.name.toLowerCase()) ||
                           subcat.subcategories.some(nested => searchText.includes(nested.toLowerCase()));
                }
                return false;
            });
        }).length;
    }

    function countJobsForSpecificProfessionWithFilters(professionName, currentFilters) {
        let jobs = filterActiveJobs(allJobsData);

        // Apply category filter
        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        // Apply other active filters (except profession)
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply location filters
        const checkedLocations = getCheckedLocations();
        if (checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';

                return checkedLocations.some(location => {
                    // Check if this is an Overseas location
                    if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                        // First check if it's an overseas job
                        if (!categoryFilters.overseas.filter(job)) {
                            return false;
                        }

                        const country = job.location_country || '';
                        const locationLower = jobLocation.toLowerCase();
                        const countryLower = country.toLowerCase();

                        // Match specific country
                        if (location === 'Canada') {
                            return locationLower.includes('canada') || countryLower.includes('canada');
                        } else if (location === 'Australia') {
                            return locationLower.includes('australia') || countryLower.includes('australia');
                        } else if (location === 'New Zealand') {
                            return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                        } else if (location === 'Republic of Ireland') {
                            return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                   !locationLower.includes('northern') && !countryLower.includes('northern');
                        } else if (location === 'North America') {
                            return locationLower.includes('usa') || locationLower.includes('united states') ||
                                   countryLower.includes('usa') || countryLower.includes('united states');
                        } else if (location === 'Middle East') {
                            return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                   countryLower.includes('dubai') || countryLower.includes('uae');
                        } else if (location === country) {
                            return true;
                        }

                        return false;
                    } else {
                        // Regular location matching
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    }
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => job.grade && checkedGrades.includes(job.grade));
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        // Now count for this specific profession
        return jobs.filter(job => {
            const sectors = job.sector || [];
            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
            return searchText.includes(professionName.toLowerCase()) || sectors.some(s => s.toLowerCase() === professionName.toLowerCase());
        }).length;
    }

    function buildProfessionHierarchy() {
        const professionData = [];

        Object.entries(dynamicProfessionHierarchy).forEach(([parentName, parentData]) => {
            const parentCount = countJobsForProfessionCategoryWithFilters(parentName, parentData.subcategories, {});

            if (parentCount > 0) {
                const subcategoryData = [];

                parentData.subcategories.forEach(subcategory => {
                    if (typeof subcategory === 'string') {
                        const count = countJobsForSpecificProfessionWithFilters(subcategory, {});
                        if (count > 0) {
                            subcategoryData.push({ name: subcategory, count });
                        }
                    } else if (typeof subcategory === 'object' && subcategory.subcategories) {
                        const nestedCount = countJobsForSpecificProfessionWithFilters(subcategory.name, {});
                        if (nestedCount > 0) {
                            const nestedSubcategories = [];
                            subcategory.subcategories.forEach(nestedSub => {
                                const nestedSubCount = countJobsForSpecificProfessionWithFilters(nestedSub, {});
                                if (nestedSubCount > 0) {
                                    nestedSubcategories.push({ name: nestedSub, count: nestedSubCount });
                                }
                            });

                            subcategoryData.push({
                                name: subcategory.name,
                                count: nestedCount,
                                subcategories: nestedSubcategories
                            });
                        }
                    }
                });

                professionData.push({
                    name: parentName,
                    count: parentCount,
                    subcategories: subcategoryData
                });
            }
        });

        return professionData;
    }

    function getCheckedProfessions() {
        const checkedProfessions = [];

        const subCheckboxes = document.querySelectorAll('.profession-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const professionName = label.textContent.trim();
                // Remove the count from the profession name
                const cleanName = professionName.replace(/\s*\(\d+\)$/, '');
                checkedProfessions.push(cleanName);
            }
        });

        return checkedProfessions;
    }

    function calculateFilterCounts() {
        filterData = {
            published: {},
            profession: {},
            grade: {},
            location: {}
        };

        const activeJobs = filterActiveJobs(allJobsData);

        if (activeJobs.length === 0) return;

        // Build dynamic hierarchies first
        buildDynamicHierarchies();

        // Calculate counts for published and grade
        let publishedCounts = {};
        let gradeCounts = {};

        activeJobs.forEach(job => {
            if (job.published) {
                const category = categorizePublishedString(job.published);
                if (category) {
                    publishedCounts[category] = (publishedCounts[category] || 0) + 1;
                }
            }

            if (job.grade) {
                gradeCounts[job.grade] = (gradeCounts[job.grade] || 0) + 1;
            }
        });

        // Convert to array format
        const publishedOrder = [
           "Last 3 Days",
            "Last 7 Days",
            "Last 14 Days",
            "Last 28 Days",
            "More than 28 Days"
        ];

        filterData.published = publishedOrder
            .filter(category => publishedCounts[category] > 0)
            .map(category => ({
                name: category,
                count: publishedCounts[category]
            }));

        filterData.grade = Object.entries(gradeCounts)
            .map(([name, count]) => ({ name, count }))
            .sort((a, b) => b.count - a.count);

        // Build profession and location hierarchies with dynamic counts
        filterData.profession = buildProfessionHierarchy();
        filterData.location = buildLocationHierarchy();
    }

    function renderLocationFilters(locationData) {
        return `
            <div class="filter-group">
                <div class="filter-header" onclick="toggleFilterGroup('location')">
                    <span class="filter-arrow" id="locationArrow">‚ñº</span>
                    <span>Location</span>
                </div>
                <div class="filter-options" id="locationOptions">
                    ${locationData.map(parent => {
                        const hasSubcategories = parent.subcategories && parent.subcategories.length > 0;

                        if (!hasSubcategories) {
                            return `
                                <div class="filter-item">
                                    <input type="checkbox" class="filter-checkbox location-checkbox" id="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                           onchange="handleFilterChange('location', '${parent.name}')">
                                    <label class="filter-label" for="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${parent.name}</label>
                                    <span class="filter-count">${parent.count}</span>
                                </div>
                            `;
                        } else {
                            return `
                                <div class="profession-parent-group">
                                    <div class="profession-parent-header" onclick="toggleParentCategory('location', '${parent.name}')">
                                        <input type="checkbox" class="profession-parent-checkbox" id="location_parent_${parent.name.replace(/\s+/g, '_')}"
                                               onchange="handleParentCategoryChange('location', '${parent.name}')" onclick="event.stopPropagation()">
                                        <label class="profession-parent-label" for="location_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                                        <span class="filter-count">${parent.count}</span>
                                        <span class="profession-parent-arrow" id="location_parent_arrow_${parent.name.replace(/\s+/g, '_')}">‚ñº</span>
                                    </div>
                                    <div class="profession-subcategories" id="location_subcategories_${parent.name.replace(/\s+/g, '_')}">
                                        ${parent.subcategories.map(sub => `
                                            <div class="profession-sub-item">
                                                <input type="checkbox" class="profession-sub-checkbox location-sub-checkbox" id="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                       onchange="handleSubCategoryChange('location', '${parent.name}', '${sub.name}')">
                                                <label class="profession-sub-label" for="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                                                <span class="filter-count">${sub.count}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    }).join('')}
                </div>
            </div>
        `;
    }

    function renderProfessionFilters(professionData) {
        return `
            <div class="filter-group">
                <div class="filter-header" onclick="toggleFilterGroup('profession')">
                    <span class="filter-arrow" id="professionArrow">‚ñº</span>
                    <span>Profession</span>
                </div>
                <div class="filter-options" id="professionOptions">
                    ${professionData.map(parent => `
                        <div class="profession-parent-group">
                            <div class="profession-parent-header" onclick="toggleProfessionParent('${parent.name}')">
                                <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${parent.name.replace(/\s+/g, '_')}"
                                       onchange="handleParentProfessionChange('${parent.name}')" onclick="event.stopPropagation()">
                                <label class="profession-parent-label" for="profession_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                                <span class="filter-count">${parent.count}</span>
                                <span class="profession-parent-arrow" id="profession_parent_arrow_${parent.name.replace(/\s+/g, '_')}">‚ñº</span>
                            </div>
                            <div class="profession-subcategories" id="profession_subcategories_${parent.name.replace(/\s+/g, '_')}">
                                ${parent.subcategories.map(sub => {
                                    if (sub.subcategories) {
                                        return `
                                            <div class="profession-parent-group" style="margin-left: 20px; margin-bottom: 10px;">
                                                <div class="profession-parent-header" onclick="toggleProfessionParent('${sub.name}')">
                                                    <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${sub.name.replace(/\s+/g, '_')}"
                                                           onchange="handleParentProfessionChange('${sub.name}')" onclick="event.stopPropagation()">
                                                    <label class="profession-parent-label" for="profession_parent_${sub.name.replace(/\s+/g, '_')}">${sub.name}</label>
                                                    <span class="filter-count">${sub.count}</span>
                                                    <span class="profession-parent-arrow" id="profession_parent_arrow_${sub.name.replace(/\s+/g, '_')}">‚ñº</span>
                                                </div>
                                                <div class="profession-subcategories" id="profession_subcategories_${sub.name.replace(/\s+/g, '_')}">
                                                    ${sub.subcategories.map(nestedSub => `
                                                        <div class="profession-sub-item">
                                                            <input type="checkbox" class="profession-sub-checkbox" id="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                                   onchange="handleSubProfessionChange('${sub.name}', '${nestedSub.name}')">
                                                            <label class="profession-sub-label" for="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${nestedSub.name}</label>
                                                            <span class="filter-count">${nestedSub.count}</span>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            </div>
                                        `;
                                    } else {
                                        return `
                                            <div class="profession-sub-item">
                                                <input type="checkbox" class="profession-sub-checkbox" id="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                       onchange="handleSubProfessionChange('${parent.name}', '${sub.name}')">
                                                <label class="profession-sub-label" for="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                                                <span class="filter-count">${sub.count}</span>
                                            </div>
                                        `;
                                    }
                                }).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    function renderFilters() {
        const filtersContainer = document.getElementById('filtersContainer');

        const filterHTML = Object.entries(filterData).map(([category, items]) => {
            if (category === 'profession') {
                return renderProfessionFilters(items);
            } else if (category === 'location') {
                return renderLocationFilters(items);
            } else {
                const displayName = category === 'published' ? 'Date Published' : category.charAt(0).toUpperCase() + category.slice(1);
                return `
                    <div class="filter-group">
                        <div class="filter-header" onclick="toggleFilterGroup('${category}')">
                            <span class="filter-arrow" id="${category}Arrow">‚ñº</span>
                            <span>${displayName}</span>
                        </div>
                        <div class="filter-options" id="${category}Options">
                            ${items.map(item => {
                                const checkboxId = `${category}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                                return `
                                    <div class="filter-item">
                                        <input type="checkbox" class="filter-checkbox" id="${checkboxId}" onchange="handleFilterChange('${category}', '${item.name}')">
                                        <label class="filter-label" for="${checkboxId}">${item.name}</label>
                                        <span class="filter-count">${item.count}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
        }).join('');

        filtersContainer.innerHTML = filterHTML;
    }

    function applyFilters() {
        let activeJobs = filterActiveJobs(allJobsData);

        const activeFilters = {};

        Object.keys(filterData).forEach(category => {
            activeFilters[category] = [];
            if (category === 'profession') {
                activeFilters[category] = getCheckedProfessions();
            } else if (category === 'location') {
                activeFilters[category] = getCheckedLocations();
            } else {
                filterData[category].forEach(item => {
                    const checkboxId = `${category}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox && checkbox.checked) {
                        activeFilters[category].push(item.name);
                    }
                });
            }
        });

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();

        filteredJobs = activeJobs.filter(job => {
            if (activeCategoryFilter !== 'all') {
                if (!categoryFilters[activeCategoryFilter].filter(job)) {
                    return false;
                }
            }

            if (searchTerm.length > 0) {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                const matchesSearch = job.job_title.toLowerCase().includes(searchTerm) ||
                                    job.location_description.toLowerCase().includes(searchTerm) ||
                                    employer.toLowerCase().includes(searchTerm) ||
                                    job.short_description.toLowerCase().includes(searchTerm) ||
                                    sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                                    (job.grade && job.grade.toLowerCase().includes(searchTerm));
                if (!matchesSearch) return false;
            }

            for (const [category, selectedValues] of Object.entries(activeFilters)) {
                if (selectedValues.length > 0) {
                    if (category === 'profession') {
                        const checkedProfessions = selectedValues;
                        const sectors = job.sector || [];
                        const employer = job.alternate_recruiter_name || job.recruiter_name;
                        const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${employer}`.toLowerCase();
                        const matchesProfession = checkedProfessions.some(profession => {
                            return searchText.includes(profession.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                        });
                        if (!matchesProfession) return false;
                    } else if (category === 'location') {
                        const checkedLocations = selectedValues;
                        const jobLocation = job.location_description || '';

                        const matchesLocation = checkedLocations.some(location => {
                            // Check if this is an Overseas location
                            if (dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                                // First check if it's an overseas job
                                if (!categoryFilters.overseas.filter(job)) {
                                    return false;
                                }

                                const country = job.location_country || '';
                                const locationLower = jobLocation.toLowerCase();
                                const countryLower = country.toLowerCase();

                                // Match specific country
                                if (location === 'Canada') {
                                    return locationLower.includes('canada') || countryLower.includes('canada');
                                } else if (location === 'Australia') {
                                    return locationLower.includes('australia') || countryLower.includes('australia');
                                } else if (location === 'New Zealand') {
                                    return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                                } else if (location === 'Republic of Ireland') {
                                    return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                                           !locationLower.includes('northern') && !countryLower.includes('northern');
                                } else if (location === 'North America') {
                                    return locationLower.includes('usa') || locationLower.includes('united states') ||
                                           countryLower.includes('usa') || countryLower.includes('united states');
                                } else if (location === 'Middle East') {
                                    return locationLower.includes('dubai') || locationLower.includes('uae') ||
                                           countryLower.includes('dubai') || countryLower.includes('uae');
                                } else if (location === country) {
                                    return true;
                                }

                                return false;
                            } else {
                                // Regular location matching
                                const normalizedJobLocation = normalizeLocation(jobLocation);
                                const normalizedSearch = normalizeLocation(location);
                                return normalizedJobLocation.includes(normalizedSearch);
                            }
                        });

                        if (!matchesLocation) return false;
                    } else if (category === 'grade') {
                        if (!job.grade || !selectedValues.includes(job.grade)) {
                            return false;
                        }
                    } else if (category === 'published') {
                        if (!job.published) return false;

                        const jobDays = parseDaysFromPublished(job.published);
                        if (!jobDays) return false;

                        const matchesPublished = selectedValues.some(selectedCategory => {
                             switch(selectedCategory) {
                                case "Last 3 Days":
                                    return jobDays <= 3;
                                case "Last 7 Days":
                                    return jobDays <= 7;
                                case "Last 14 Days":
                                    return jobDays <= 14;
                                case "Last 28 Days":
                                    return jobDays <= 28;
                                case "More than 28 Days":
                                    return jobDays > 28;
                                default:
                                    return false;
                            }
                        });

                        if (!matchesPublished) return false;
                    }
                }
            }

            return true;
        });

        currentPage = 1;

        renderJobsList();
        updatePagination();
        updateJobCount();

        // Recalculate filter counts after applying filters
        calculateFilterCounts();
        renderFilters();
    }

    function generateDynamicKeywords() {
        const keywordSet = new Set();
        const maxKeywords = 6;

        const activeJobs = filterActiveJobs(allJobsData);

        const professions = [];
        const grades = [];

        activeJobs.forEach(job => {
            if (job.sector && Array.isArray(job.sector)) {
                job.sector.forEach(s => {
                    if (!professions.includes(s)) {
                        professions.push(s);
                    }
                });
            }
            if (job.grade && !grades.includes(job.grade)) {
                grades.push(job.grade);
            }
        });

        const shuffleArray = (array) => {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        const shuffledProfessions = shuffleArray(professions);
        const shuffledGrades = shuffleArray(grades);

        for (let i = 0; i < Math.min(3, shuffledProfessions.length); i++) {
            keywordSet.add(shuffledProfessions[i]);
        }

        for (let i = 0; i < Math.min(3, shuffledGrades.length); i++) {
            keywordSet.add(shuffledGrades[i]);
        }

        keywords = Array.from(keywordSet).slice(0, maxKeywords);
    }

    function initApp() {
        filteredJobs = filterActiveJobs(allJobsData);

        calculateFilterCounts();
        generateDynamicKeywords();
        renderKeywords();
        renderFilters();
        renderJobsList();
        updatePagination();
        updateJobCount();
        updateCategoryButtons();
        addEventListeners();
    }

    function updateJobCount() {
        const jobCountDisplay = document.getElementById('jobCountDisplay');
        const count = filteredJobs.length;
        jobCountDisplay.textContent = `Found ${count} job${count !== 1 ? 's' : ''}`;
    }

    function renderKeywords() {
        const keywordsList = document.getElementById('keywordsList');
        keywordsList.innerHTML = keywords.map(keyword =>
            `<span class="keyword-tag" onclick="selectKeyword('${keyword}')">${keyword}</span>`
        ).join('');
    }

    function getCurrentPageJobs() {
        const startIndex = (currentPage - 1) * jobsPerPage;
        const endIndex = startIndex + jobsPerPage;
        return filteredJobs.slice(startIndex, endIndex);
    }

    function updatePagination() {
        const totalJobs = filteredJobs.length;
        const totalPages = Math.ceil(totalJobs / jobsPerPage);
        const startJob = totalJobs > 0 ? (currentPage - 1) * jobsPerPage + 1 : 0;
        const endJob = Math.min(currentPage * jobsPerPage, totalJobs);

        document.getElementById('jobRangeStart').textContent = startJob;
        document.getElementById('jobRangeEnd').textContent = endJob;
        document.getElementById('totalJobsCount').textContent = totalJobs;

        const pageNumbersContainer = document.getElementById('pageNumbers');
        let startPage = Math.max(1, currentPage - 3);
        let endPage = Math.min(totalPages, startPage + 6);

        if (endPage - startPage < 6) {
            startPage = Math.max(1, endPage - 6);
        }

        let pageNumbersHTML = '';
        for (let i = startPage; i <= endPage; i++) {
            pageNumbersHTML += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i}</button>`;
        }
        pageNumbersContainer.innerHTML = pageNumbersHTML;

        document.getElementById('firstBtn').disabled = currentPage === 1;
        document.getElementById('prevBtn').disabled = currentPage === 1;
        document.getElementById('nextBtn').disabled = currentPage === totalPages || totalPages === 0;
        document.getElementById('lastBtn').disabled = currentPage === totalPages || totalPages === 0;
    }

    // FIXED renderJobsList function
    function renderJobsList() {
        const jobsList = document.getElementById('jobsList');
        const pageJobs = getCurrentPageJobs();

        if (pageJobs.length === 0) {
            jobsList.innerHTML = '<div class="no-jobs-message">No jobs found matching your criteria.</div>';
            return;
        }

        jobsList.innerHTML = pageJobs.map(job => {
            const employer = job.alternate_recruiter_name || job.recruiter_name || 'Unknown Employer';
            return `
                <div class="job-card">
                    <div class="job-header">${job.job_title}</div>
                    <div class="job-body">
                        ${job.logo_url ? `<img src="${job.logo_url}" alt="${employer} Logo" class="nhs-logo">` : ''}
                        <div class="job-details">
                            <ul>
                                <li><strong>Location:</strong> ${job.location_description}</li>
                                <li><strong>Salary:</strong> ${job.salary || 'Competitive'}</li>
                                <li><strong>Employer:</strong> ${employer}</li>
                            </ul>
                        </div>
                        <div class="job-description">${job.short_description}</div>
                        <button class="apply-btn" onclick="applyToJob(${job.id})">View Details on BMJ Careers</button>
                    </div>
                </div>
            `;
        }).join('');
    }

    // Auto-close dropdowns on window resize
    function handleResize() {
        const currentWidth = window.innerWidth;

        // Close all dropdowns on resize
        const filterGroups = ['published', 'profession', 'grade', 'location'];
        filterGroups.forEach(groupName => {
            const arrow = document.getElementById(groupName + 'Arrow');
            const options = document.getElementById(groupName + 'Options');

            if (arrow && options && !options.classList.contains('collapsed')) {
                options.classList.add('collapsed');
                arrow.classList.add('collapsed');
                arrow.textContent = '‚ñ∂';
            }
        });

        lastWindowWidth = currentWidth;
    }

    function addEventListeners() {
        const keywordSearch = document.getElementById('keywordSearch');
        keywordSearch.addEventListener('input', function() {
            clearTimeout(this.searchTimeout);
            this.searchTimeout = setTimeout(() => {
                applyFilters();
                scrollToTop();
            }, 300);
        });

        keywordSearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                clearTimeout(this.searchTimeout);
                applyFilters();
                scrollToTop();
            }
        });

        window.addEventListener('scroll', handleScroll);

        // Add resize event listener
        window.addEventListener('resize', handleResize);
    }

    // Make initApp globally accessible for API integration
    window.initApp = initApp;

    // Initialize the app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Only initialize if we already have data
        if (window.allJobsData && window.allJobsData.length > 0) {
            initApp();
        }
        // Otherwise, the API integration will call initApp when data is loaded
    });

    // Listen for data updates from the API
    window.addEventListener('jobsDataUpdated', function() {
        initApp();
    });
</script>
<!-- Cross-Origin Style Communication Script -->
<script>
    (function() {
        'use strict';

        // Widget configuration
        const WIDGET_CONFIG = {
            widgetId: 'bmj-careers-widget',
            version: '1.0.0'
        };

        // Detect if running in iframe
        const isInIframe = window.self !== window.top;

        // Security: Configure allowed origins (update for production)
        const ALLOWED_ORIGINS = '*'; // Change to ['https://client1.com', 'https://client2.com'] in production

        // Performance: Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Apply iframe-specific styles immediately
        if (isInIframe) {
            const iframeStyles = document.createElement('style');
            iframeStyles.id = 'bmj-iframe-styles';
            iframeStyles.textContent = `
                /* Remove ONLY the main page scrollbar for iframe mode */
                html, body {
                    overflow: visible !important;
                    height: auto !important;
                    min-height: 100% !important;
                }

                .main-wrapper {
                    min-height: auto !important;
                    height: auto !important;
                }

                /* Ensure sidebar doesn't stick in iframe mode */
                .sidebar {
                    position: relative !important;
                    top: auto !important;
                }
            `;
            document.head.appendChild(iframeStyles);
            document.body.classList.add('bmj-iframe-mode');
        }

        // Optimized height calculation
        let lastHeight = 0;
        function getDocumentHeight() {
            const body = document.body;
            const html = document.documentElement;
            return Math.max(
                body.scrollHeight,
                body.offsetHeight,
                html.clientHeight,
                html.scrollHeight,
                html.offsetHeight
            );
        }

        // Send height updates to parent
        const sendHeightUpdate = debounce(function() {
            if (!isInIframe) return;

            const height = getDocumentHeight();
            if (height !== lastHeight) {
                lastHeight = height;
                window.parent.postMessage({
                    type: 'bmj-careers-height-update',
                    widgetId: WIDGET_CONFIG.widgetId,
                    height: height
                }, '*');
            }
        }, 100);

        // Handle scroll detection for scroll-to-top button
        if (!isInIframe) {
            // Normal mode - use window scroll
            const handleScroll = debounce(function() {
                const scrollToTopBtn = document.getElementById('scrollToTop');
                if (scrollToTopBtn) {
                    if (window.pageYOffset > 300) {
                        scrollToTopBtn.classList.add('show');
                    } else {
                        scrollToTopBtn.classList.remove('show');
                    }
                }
            }, 50);

            window.addEventListener('scroll', handleScroll, { passive: true });
        } else {
            // Iframe mode - button visibility handled by existing handleScroll in index.html
            // But we need to ensure scroll-to-top works properly
            window.addEventListener('load', function() {
                const scrollToTopBtn = document.getElementById('scrollToTop');
                if (scrollToTopBtn) {
                    // Override the existing onclick to work in iframe
                    scrollToTopBtn.onclick = function(e) {
                        e.preventDefault();

                        // Try multiple methods to ensure scrolling works
                        try {
                            // Method 1: Scroll parent's iframe
                            window.parent.postMessage({
                                type: 'bmj-careers-scroll-to-top',
                                widgetId: WIDGET_CONFIG.widgetId
                            }, '*');
                        } catch (e) {}

                        // Method 2: Scroll own window
                        window.scrollTo({ top: 0, behavior: 'smooth' });

                        // Method 3: Scroll document element
                        document.documentElement.scrollTop = 0;
                        document.body.scrollTop = 0;

                        return false;
                    };
                }
            });
        }

        // Security: Validate message origin
        function isAllowedOrigin(origin) {
            if (ALLOWED_ORIGINS === '*') return true;
            return ALLOWED_ORIGINS.includes(origin);
        }

        // Optimized message handler
        window.addEventListener('message', function(event) {
            // Security check
            if (!isAllowedOrigin(event.origin)) {
                console.warn('Rejected message from unauthorized origin:', event.origin);
                return;
            }

            if (!event.data || typeof event.data !== 'object') return;

            switch (event.data.type) {
                case 'bmj-careers-styles':
                    applyCustomStyles(event.data.styles);
                    break;
                case 'bmj-careers-command':
                    handleCommand(event.data.command, event.data.data);
                    break;
            }
        });

        // Optimized style application
        const applyCustomStyles = (function() {
            let styleElement = null;

            return function(styles) {
                if (!styles || typeof styles !== 'object') return;

                // Create or reuse style element
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'bmj-custom-styles';
                    document.head.appendChild(styleElement);
                }

                // Build CSS efficiently
                const cssRules = [];

                // Primary color
                if (styles.primaryColor) {
                    cssRules.push(`
                        .job-header,
                        .category-btn.active,
                        .category-btn:hover,
                        .pagination-btn.active,
                        .scroll-to-top,
                        .scroll-to-top:hover {
                            background: ${styles.primaryColor} !important;
                            background-color: ${styles.primaryColor} !important;
                        }

                        .job-title,
                        .search-title,
                        .filters-title,
                        .jobs-title,
                        .job-count-main,
                        .category-btn,
                        .pagination-btn,
                        .filter-arrow,
                        .profession-parent-arrow {
                            color: ${styles.primaryColor} !important;
                            -webkit-text-fill-color: ${styles.primaryColor} !important;
                        }

                        .filter-checkbox:checked,
                        .profession-parent-checkbox:checked,
                        .profession-sub-checkbox:checked,
                        .location-checkbox:checked,
                        .location-sub-checkbox:checked,
                        input[type="checkbox"]:checked,
                        input[type="checkbox"]:checked::before {
                            background: ${styles.primaryColor} !important;
                            background-color: ${styles.primaryColor} !important;
                            border-color: ${styles.primaryColor} !important;
                        }

                        .search-input:focus,
                        .keyword-tag:hover {
                            border-color: ${styles.primaryColor} !important;
                            box-shadow: 0 0 0 4px ${styles.primaryColor}20 !important;
                        }

                        input[type="checkbox"]:not(:checked):hover {
                            border-color: ${styles.primaryColor} !important;
                            box-shadow: 0 0 0 4px ${styles.primaryColor}20 !important;
                        }

                        .job-details li::before {
                            color: ${styles.primaryColor} !important;
                        }
                    `);
                }

                // Secondary color
                if (styles.secondaryColor) {
                    cssRules.push(`
                        .apply-btn {
                            background: ${styles.secondaryColor} !important;
                            background-color: ${styles.secondaryColor} !important;
                            box-shadow: 0 4px 12px ${styles.secondaryColor}40 !important;
                        }

                        .apply-btn:hover {
                            background: ${styles.secondaryColorHover || styles.secondaryColor} !important;
                            background-color: ${styles.secondaryColorHover || styles.secondaryColor} !important;
                            filter: brightness(1.1);
                            box-shadow: 0 6px 20px ${styles.secondaryColor}50 !important;
                        }
                    `);
                }

                // Text color
                if (styles.textColor) {
                    cssRules.push(`
                        body,
                        .job-details,
                        .job-details li,
                        .job-details strong,
                        .filter-label,
                        .profession-parent-label,
                        .profession-sub-label,
                        .location-text,
                        .filter-header,
                        .job-description,
                        .pagination-info,
                        .job-count-subtitle,
                        .no-jobs-message {
                            color: ${styles.textColor} !important;
                        }
                    `);
                }

                // Background colors
                if (styles.backgroundColor) {
                    cssRules.push(`
                        body {
                            background: ${styles.backgroundColor} !important;
                        }
                    `);
                }

                if (styles.cardBackgroundColor) {
                    cssRules.push(`
                        .sidebar,
                        .main-content,
                        .job-card,
                        .search-section,
                        .filters-section,
                        .job-body,
                        .pagination-section,
                        .filter-checkbox:not(:checked),
                        .profession-parent-checkbox:not(:checked),
                        .profession-sub-checkbox:not(:checked),
                        .location-checkbox:not(:checked),
                        .location-sub-checkbox:not(:checked),
                        input[type="checkbox"]:not(:checked) {
                            background-color: ${styles.cardBackgroundColor} !important;
                            background: ${styles.cardBackgroundColor} !important;
                        }
                    `);
                }

                // Keyword tags
                if (styles.keywordBackgroundColor) {
                    cssRules.push(`
                        .keyword-tag {
                            background: ${styles.keywordBackgroundColor} !important;
                            color: ${styles.keywordTextColor || styles.primaryColor} !important;
                            border: 1px solid ${styles.keywordBorderColor || 'transparent'} !important;
                        }

                        .keyword-tag:hover {
                            background: ${styles.keywordHoverBackgroundColor || styles.primaryColor} !important;
                            color: ${styles.keywordHoverTextColor || '#FFFFFF'} !important;
                        }
                    `);
                }

                // Borders
                if (styles.borderColor) {
                    cssRules.push(`
                        .sidebar,
                        .main-content,
                        .job-card,
                        .filter-group,
                        .search-input,
                        .search-section,
                        .pagination-section,
                        .category-btn,
                        .filter-checkbox:not(:checked),
                        .profession-parent-checkbox:not(:checked),
                        .profession-sub-checkbox:not(:checked),
                        .location-checkbox:not(:checked),
                        .location-sub-checkbox:not(:checked) {
                            border-color: ${styles.borderColor} !important;
                        }
                    `);
                }

                // Typography
                if (styles.fontFamily) {
                    cssRules.push(`
                        body,
                        * {
                            font-family: ${styles.fontFamily} !important;
                        }
                    `);
                }

                if (styles.baseFontSize) {
                    cssRules.push(`
                        body {
                            font-size: ${styles.baseFontSize} !important;
                        }

                        .job-details,
                        .job-description,
                        .filter-label {
                            font-size: calc(${styles.baseFontSize} * 0.9375) !important;
                        }

                        .filter-count,
                        .keywords-label {
                            font-size: calc(${styles.baseFontSize} * 0.8125) !important;
                        }
                    `);
                }

                if (styles.headerFontSize) {
                    cssRules.push(`
                        .job-header {
                            font-size: ${styles.headerFontSize} !important;
                        }

                        .job-count-main {
                            font-size: calc(${styles.headerFontSize} * 1.5) !important;
                        }

                        .search-title,
                        .filters-title {
                            font-size: calc(${styles.headerFontSize} * 0.75) !important;
                        }
                    `);
                }

                // Shadows
                if (styles.shadowColor) {
                    cssRules.push(`
                        .sidebar,
                        .main-content,
                        .job-card {
                            box-shadow: 0 2px 8px ${styles.shadowColor}10 !important;
                        }

                        .sidebar:hover,
                        .main-content:hover {
                            box-shadow: 0 8px 24px ${styles.shadowColor}20 !important;
                        }

                        .job-card:hover {
                            box-shadow: 0 10px 30px ${styles.shadowColor}25 !important;
                        }

                        .category-btn:hover,
                        .pagination-btn:hover {
                            box-shadow: 0 6px 20px ${styles.shadowColor}40 !important;
                        }

                        .scroll-to-top {
                            box-shadow: 0 6px 20px ${styles.shadowColor}30 !important;
                        }

                        .scroll-to-top:hover {
                            box-shadow: 0 8px 25px ${styles.shadowColor}40 !important;
                        }
                    `);
                }

                // Button text colors
                if (styles.buttonTextColor) {
                    cssRules.push(`
                        .category-btn.active,
                        .category-btn:hover,
                        .pagination-btn.active,
                        .scroll-to-top {
                            color: ${styles.buttonTextColor} !important;
                        }
                    `);
                }

                if (styles.applyButtonTextColor) {
                    cssRules.push(`
                        .apply-btn,
                        .apply-btn:hover {
                            color: ${styles.applyButtonTextColor} !important;
                        }
                    `);
                }

                // Hover effects
                if (styles.hoverScale !== false) {
                    cssRules.push(`
                        .category-btn:hover,
                        .apply-btn:hover,
                        .keyword-tag:hover {
                            transform: translateY(-2px) scale(1.02);
                        }
                    `);
                }

                // Apply all styles at once
                styleElement.textContent = cssRules.join('\n');

                // Send confirmation
                window.parent.postMessage({
                    type: 'bmj-careers-styles-applied',
                    widgetId: WIDGET_CONFIG.widgetId,
                    stylesApplied: true
                }, '*');
            };
        })();

        // Handle commands
        function handleCommand(command, data) {
            switch(command) {
                case 'refresh':
                    location.reload();
                    break;
                case 'scrollToTop':
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    break;
            }
        }

        // Optimized content monitoring for iframe mode
        if (isInIframe) {
            // Initial height send
            setTimeout(sendHeightUpdate, 100);

            // Efficient mutation observer
            const observer = new MutationObserver(sendHeightUpdate);
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: false,
                characterData: false
            });

            // Window resize handler
            window.addEventListener('resize', sendHeightUpdate, { passive: true });

            // Content loaded handlers
            window.addEventListener('load', sendHeightUpdate);
            document.addEventListener('DOMContentLoaded', sendHeightUpdate);

            // Filter/pagination change handler
            document.addEventListener('click', function(e) {
                if (e.target.matches('.filter-checkbox, .category-btn, .pagination-btn, .filter-header, .profession-parent-header')) {
                    setTimeout(sendHeightUpdate, 300);
                }
            }, { passive: true });
        }

        // Send ready message efficiently
        function sendReadyMessage() {
            window.parent.postMessage({
                type: 'bmj-careers-ready',
                widgetId: WIDGET_CONFIG.widgetId,
                version: WIDGET_CONFIG.version,
                isInIframe: isInIframe
            }, '*');

            console.log('BMJ Careers Widget initialized and ready');

            if (isInIframe) {
                sendHeightUpdate();
            }
        }

        // Send ready on load
        if (document.readyState === 'complete') {
            sendReadyMessage();
        } else {
            window.addEventListener('load', sendReadyMessage);
            // Backup ready message
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(sendReadyMessage, 500);
            });
        }
    })();
</script>
<!-- End Cross-Origin Style Communication Script -->
</body>
</html>
