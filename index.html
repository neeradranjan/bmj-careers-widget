<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse and search medical job opportunities across the UK and internationally. Find consultant, GP, specialist, and healthcare positions with BMJ Careers.">
    <meta name="keywords" content="medical jobs, healthcare careers, NHS jobs, consultant positions, GP vacancies, medical recruitment, BMJ careers">
    <meta name="author" content="BMJ Careers">
    <meta name="robots" content="index, follow">
    <title>BMJ Careers - Medical Jobs</title>

    <!-- Resource hints for performance -->
    <link rel="preconnect" href="https://www.bmj.com" crossorigin>
    <link rel="dns-prefetch" href="https://www.bmj.com">

    <!-- Inline critical CSS -->
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; }
        .main-wrapper { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); display: flex; align-items: center; justify-content: center; z-index: 9999; }

        /* Updated styles for job count display inside jobs section */
.job-count-header {
    margin-bottom: 0.5rem;
    padding: 0.4rem 0.75rem;
    background: #ffffff;
    border-radius: 6px;
    animation: fadeInDown 0.6s ease-out;
}

.job-count-main {
    background: linear-gradient(135deg, #0066cc 0%, #004c99 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 600;
    font-size: 0.875rem; /* Reduced from 1.25rem */
    letter-spacing: -0.01em;
    animation: shimmer 3s ease-in-out infinite;
}
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translate3d(0, -20px, 0);
            }
            to {
                opacity: 1;
                transform: translate3d(0, 0, 0);
            }
        }

        @keyframes shimmer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Improved pagination disabled button contrast */
        .pagination-btn:disabled {
            color: #4a5568;
            cursor: not-allowed;
            opacity: 0.7;
            background: #e2e8f0;
            border-color: #cbd5e0;
        }

        /* Keyboard navigation for keywords */
        .keyword-tag {
            background: linear-gradient(135deg, #e6f2ff 0%, #cce4ff 100%);
            color: #0066cc;
            padding: 0.375rem 0.875rem;
            border-radius: 8px;
            font-size: 0.8125rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            font-weight: 500;
            display: inline-block;
            margin: 0.25rem;
        }

        .keyword-tag:focus {
            outline: 2px solid #0066cc;
            outline-offset: 2px;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        .keyword-tag:hover {
            background: linear-gradient(135deg, #0066cc 0%, #0052a3 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        /* Date Published Radio-like behavior styles */
        .published-filter-item {
            display: flex;
            align-items: center;
            padding: 0.625rem 0.5rem;
            font-size: 0.875rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .published-filter-item:hover {
            background: #f3f4f6;
            transform: translateX(4px);
        }

        /* Accessibility improvement for filter sections */
        .filter-group[role="region"] {
            position: relative;
        }

        .filter-header:focus {
            outline: 2px solid #0066cc;
            outline-offset: 2px;
        }
    </style>

    <!-- Defer non-critical CSS -->
    <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="styles.css"></noscript>
</head>
<body>
<!-- Add immediately after <body> -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div style="margin-top: 1rem; color: #666;">Loading jobs...</div>
</div>

<div class="jobs-skeleton" id="jobsSkeleton" style="display: none;">
    <div class="main-wrapper">
        <div class="skeleton-content" style="background: white; padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
            <div style="height: 24px; background: #e2e8f0; border-radius: 4px; width: 60%; margin-bottom: 1rem; animation: pulse 1.5s ease-in-out infinite;"></div>
            <div style="height: 16px; background: #e2e8f0; border-radius: 4px; width: 40%; margin-bottom: 2rem; animation: pulse 1.5s ease-in-out infinite;"></div>
            <div style="height: 120px; background: #e2e8f0; border-radius: 4px; margin-bottom: 1rem; animation: pulse 1.5s ease-in-out infinite;"></div>
            <div style="height: 120px; background: #e2e8f0; border-radius: 4px; margin-bottom: 1rem; animation: pulse 1.5s ease-in-out infinite;"></div>
            <div style="height: 120px; background: #e2e8f0; border-radius: 4px; animation: pulse 1.5s ease-in-out infinite;"></div>
        </div>
    </div>
</div>

<style>
    .loading-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #0066cc;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
<script>
    // Prevent console errors from undefined variables
    window.allJobsData = window.allJobsData || [];
    window.filteredJobs = window.filteredJobs || [];
    window.activeCategoryFilter = window.activeCategoryFilter || 'all';

    // Handle localStorage safely
    const safeStorage = {
        getItem: (key) => {
            try {
                return localStorage.getItem(key);
            } catch (e) {
                return null;
            }
        },
        setItem: (key, value) => {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                // Silently fail - storage might be blocked
            }
        }
    };

    // Replace sessionStorage usage with safeStorage
    if (!window.sessionStorage) {
        window.sessionStorage = safeStorage;
    }
</script>

<div class="main-wrapper">
    <nav class="category-buttons-wrapper" role="navigation" aria-label="Job category filters">
        <div class="category-buttons">
            <button class="category-btn active" onclick="applyCategoryFilter('all')" id="btn-all">
                <span class="emoji" aria-hidden="true">&#x1F3E5;</span>
                <span>All Jobs</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('consultant')" id="btn-consultant">
                <span class="emoji" aria-hidden="true">&#x1F468;&#x200D;&#x2695;&#xFE0F;</span>
                <span>Consultant</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('gp')" id="btn-gp">
                <span class="emoji" aria-hidden="true">&#x1FA7A;</span>
                <span>GP</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('overseas')" id="btn-overseas">
                <span class="emoji" aria-hidden="true">&#x1F30D;</span>
                <span>Overseas</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('training')" id="btn-training">
                <span class="emoji" aria-hidden="true">&#x1F393;</span>
                <span>Academic</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('special')" id="btn-special">
                <span class="emoji" aria-hidden="true">&#x26A1;</span>
                <span>Special</span>
            </button>
            <button class="category-btn" onclick="applyCategoryFilter('research')" id="btn-research">
                <span class="emoji" aria-hidden="true">&#x1F52C;</span>
                <span>Research</span>
            </button>
        </div>
    </nav>

    <div class="content-container">
        <aside class="sidebar" id="sidebar" role="complementary" aria-label="Job search and filters">
            <div class="search-section">
                <h3 class="search-title">Keyword Search</h3>
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="keywordSearch" placeholder="Enter keywords..." aria-label="Keyword search">
                    <button class="clear-keyword-btn" id="clearKeywordBtn" onclick="clearKeywordSearch()" aria-label="Clear search">×</button>
                </div>

                <div class="keywords-section">
                    <label class="keywords-label" id="keywords-label">Popular Keywords</label>
                    <div class="keywords-list" id="keywordsList" role="list" aria-labelledby="keywords-label">
                    </div>
                </div>
            </div>

            <div class="filters-section">
                <h3 class="filters-title">Filter By Category</h3>
                <div id="filtersContainer">
                </div>
            </div>
        </aside>

        <main class="main-content" role="main" aria-label="Job search results">
            <div class="jobs-section">
                <div class="job-count-header" id="jobCountDisplay">
                    <!-- Dynamic job count will be displayed here -->
                </div>
                <div id="jobsList">
                </div>
            </div>

            <div class="pagination-section">
                <div class="pagination-info">
                    Showing <span id="jobRangeStart">1</span>-<span id="jobRangeEnd">6</span> of <span id="totalJobsCount">0</span> jobs
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" id="firstBtn" onclick="goToPage(1)" aria-label="Go to first page">First</button>
                    <button class="pagination-btn" id="prevBtn" onclick="goToPage(getCurrentPage() - 1)" aria-label="Go to previous page">‹</button>
                    <span id="pageNumbers"></span>
                    <button class="pagination-btn" id="nextBtn" onclick="goToPage(getCurrentPage() + 1)" aria-label="Go to next page">›</button>
                    <button class="pagination-btn" id="lastBtn" onclick="goToPage(Math.ceil(filteredJobs.length / jobsPerPage))" aria-label="Go to last page">Last</button>
                </div>
            </div>
        </main>
    </div>
</div>

<button class="scroll-to-top" id="scrollToTop" title="Move To Top" onclick="scrollToTop()" aria-label="Scroll to top">
    ↑
</button>

<script>
    // Performance utilities
    const perfUtils = {
        debounce: function(func, wait, immediate) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    timeout = null;
                    if (!immediate) func(...args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func(...args);
            };
        },

        throttle: function(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
    };

    // Initialize with empty array - will be populated by API
    let allJobsData = [];
    window.allJobsData = allJobsData;

    // Track active filters for dynamic job count display
    let activeFiltersForDisplay = {
        category: null,
        searchTerm: '',
        professions: [],
        locations: [],
        grades: [],
        published: null
    };

    // Lazy load hierarchies to reduce initial bundle size
    let professionHierarchy = null;
    let locationHierarchy = null;
    let dynamicProfessionHierarchy = {};
    let dynamicLocationHierarchy = {};

    function initializeHierarchies() {
        professionHierarchy = {
            'GP': { subcategories: [] },
            'Specialist Doctor': { subcategories: [] },
            'Other Medical Roles': { subcategories: [] },
            'Nurse': { subcategories: [] },
            'Mental Health Professional': { subcategories: [] },
            'Pharmacist': { subcategories: [] },
            'Physician Associate': { subcategories: [] },
            'Senior Manager': { subcategories: [] },
            'Other Health Profession': { subcategories: [] }
        };

        locationHierarchy = {
            'London': { subcategories: [] },
            'South East England': { subcategories: [] },
            'South West England': { subcategories: [] },
            'East of England': { subcategories: [] },
            'East Midlands': { subcategories: [] },
            'West Midlands': { subcategories: [] },
            'Yorkshire and the Humber': { subcategories: [] },
            'North West England': { subcategories: [] },
            'North East England': { subcategories: [] },
            'Scotland': { subcategories: [] },
            'Wales': { subcategories: [] },
            'Northern Ireland': { subcategories: [] },
            'Overseas': { subcategories: [] }
        };
    }

    // Initialize hierarchies
    initializeHierarchies();

    // Full hierarchy data - loaded asynchronously
    function loadFullHierarchies() {
        // Full profession hierarchy
        professionHierarchy['GP'].subcategories = [
            'Digital GP',
            'GP Partner',
            'GP Trainee',
            'Locum GP',
            'Salaried GP'
        ];

        professionHierarchy['Specialist Doctor'].subcategories = [
            'Acute Internal Medicine',
            'Adult Critical Care',
            'Anaesthesia',
            'Anatomy',
            'Audiological Medicine',
            'BioChemistry',
            'Cardiology',
            'Cardiothoracic Surgery',
            'Cytopathology',
            'Dermatology',
            'Diabetes & Endocrinology',
            'Emergency medicine',
            'ENT/Otolaryngology',
            'Forensic Pathology',
            'Gastroenterology',
            'General Internal Medicine',
            'General Surgery',
            'Genetics',
            'Genitourinary Medicine',
            'Geriatric Medicine',
            'GP in Emergency Medicine',
            'Gynaecological Oncology',
            'Haematology',
            'Hepatology',
            'Histopathology',
            'Immunology',
            'Intensive and Critical Care Medicine',
            'Locum Doctor',
            'Maternal and Foetal Medicine',
            'Metabolic Medicine',
            'Microbiology, Virology and Infectious Diseases',
            'Neonatology',
            'Nephrology/Renal Medicine',
            'Neurology',
            'Neuropathology',
            'Neurophysiology',
            'Neurosurgery',
            'Nuclear Medicine',
            'Obstetrics and Gynaecology',
            'Occupational Medicine',
            'Oncology',
            'Ophthalmology',
            'Oral and Maxillofacial Surgery',
            {
                name: 'Paediatrics',
                subcategories: [
                    'Paediatric cardiology',
                    'Paediatric diabetes and endocrinology',
                    'Paediatric emergency medicine',
                    'Paediatric gastroenterology, Hepatology and Nutrition',
                    'Paediatric immunology, infectious diseases and allergy',
                    'Paediatric intensive Care Medicine',
                    'Paediatric nephrology',
                    'Paediatric neurodisability',
                    'Paediatric neurology',
                    'Paediatric oncology',
                    'Paediatric palliative Medicine',
                    'Paediatric pathology',
                    'Paediatric respiratory medicine',
                    'Paediatric rheumatology',
                    'Paediatric surgery'
                ]
            },
            'Palliative medicine',
            'Pathology',
            'Pharmaceutical medicine',
            'Pharmalogy and Therapeutics',
            'Physiology',
            'Plastic Surgery',
            'Pre Hospital Emergency Medicine',
            {
                name: 'Psychiatry',
                subcategories: [
                    'Child and Adolescent Psychiatry',
                    'Community Psychiatry',
                    'Forensic Psychiatry',
                    'General Adult Psychiatry',
                    'Liaison Psychiatry',
                    'Medical Psychotherapy',
                    'Old-age Psychiatry',
                    'Psychiatry of eating disorders',
                    'Psychiatry of learning disablity',
                    'Rehabilition Psychiatry',
                    'Substance Misuse Psychiatry'
                ]
            },
            'Public Health Medicine and Epidemiology',
            'Radiology',
            'Rahabilitation Medicine',
            'Respiratory Medicine',
            'Rheumatology',
            'RMO',
            'Sexual and Reproductive Health',
            'Spinal Injuries',
            'Sports and Exercise Medicine',
            'Stroke Medicine',
            'Trauma and Orthopaedics',
            'Tropical Medicine',
            'Urogynaecology',
            'Urology',
            'Vascular Surgery'
        ];

        professionHierarchy['Other Medical Roles'].subcategories = [
            'Armed Forces Doctor',
            'Commissioning',
            'Government and Health Policy',
            'Healthtech',
            'International medical Jobs',
            'Medical Education and Training',
            'Medical Examiner',
            'Medical leadership',
            'Medical training Initiative',
            'Medico-legal',
            'Occupational health',
            'Pharmaceutical',
            'Public Health',
            'Special Appointements'
        ];

        professionHierarchy['Nurse'].subcategories = [
            {
                name: 'Adult Nurse',
                subcategories: [
                    'A&E Nurse',
                    'Acute Nurse',
                    'Anaesthesia Nurse',
                    'Cancer Nurse',
                    'Cardiology Nurse',
                    'Elderly Care Nurse',
                    'Fertility Nurse',
                    'ICU Nurse',
                    'Ophthalmics Nurse',
                    'Palliative Care Nurse',
                    'Renal Nurse',
                    'Respiratory Nurse',
                    'Sexual Health Nurse',
                    'Theatre Nurse',
                    'Trauma Nurse'
                ]
            },
            {
                name: 'Community Nurse',
                subcategories: [
                    'Care Home Nurse',
                    'Community MidWife',
                    'District Nurse',
                    'Health Visitor',
                    'Mental Health Nurse - Community',
                    'School Nurse'
                ]
            },
            'General Practice Nurse',
            'Learning Disablity Nurse',
            {
                name: 'Mental Health Nurse',
                subcategories: [
                    'Adult Mental Health Nurse',
                    'CAMHS Nurse',
                    'Community Mental Health Nurse',
                    'Eating Disorders Nurse',
                    'Forensic Mental Health Nurse',
                    'Mental Health Liaison Nurse',
                    'Mental health Nurse in Primary care',
                    'Old Age Mental Health Care Nurse',
                    'Perinatal Mental Health Nurse',
                    'Rehabilitation Mental Health Nurse',
                    'Substance Misuse Nurse'
                ]
            },
            'Midwife',
            'Nurse associate',
            {
                name: 'Paediatric Nurse',
                subcategories: [
                    'Neonatal Nurse',
                    'Paediatric A&E Nurse'
                ]
            },
            'Prison Nurse'
        ];

        professionHierarchy['Mental Health Professional'].subcategories = [
            'CBT Therapist',
            'Counsellor',
            'Mental health Practitioner',
            'Psychologist',
            'Psychotherapist'
        ];

        professionHierarchy['Pharmacist'].subcategories = [
            'Pharmacy technician'
        ];

        // Full location hierarchy (keeping existing data)
        locationHierarchy['London'].subcategories = [
            'Central London',
            'North London',
            'South London',
            'East London',
            'West London',
            'Greater London'
        ];

        locationHierarchy['South East England'].subcategories = [
    'Brighton',
    'Canterbury',
    'Oxford',
    'Reading',
    'Southampton',
    'Portsmouth',
    'Guildford',
    'Maidstone',
    'Crawley',
    'Slough',
    'Milton Keynes',
    'Luton',
    'Medway',
    'Ashford',
    'Basingstoke',
    'Eastbourne',
    'Hastings',
    'Worthing',
    'Bracknell',
    'Maidenhead',
    'Windsor',
    'Berkshire',
    'Buckinghamshire',
    'East Sussex',
    'Hampshire',
    'Isle of Wight',
    'Kent',
    'Oxfordshire',
    'Surrey',
    'West Sussex'
];

locationHierarchy['South West England'].subcategories = [
    'Bristol',
    'Plymouth',
    'Bournemouth',
    'Swindon',
    'Gloucester',
    'Exeter',
    'Bath',
    'Cheltenham',
    'Torbay',
    'Poole',
    'Taunton',
    'Salisbury',
    'Truro',
    'Weymouth',
    'Weston-super-Mare',
    'Yeovil',
    'Barnstaple',
    'Bridgwater',
    'Cornwall',
    'Devon',
    'Dorset',
    'Gloucestershire',
    'Somerset',
    'Wiltshire'
];

locationHierarchy['East of England'].subcategories = [
    'Cambridge',
    'Norwich',
    'Peterborough',
    'Ipswich',
    'Colchester',
    'Southend-on-Sea',
    'Luton',
    'Watford',
    'St Albans',
    'Chelmsford',
    'Basildon',
    'Harlow',
    'Stevenage',
    'Bedford',
    'Bury St Edmunds',
    'Hertford',
    'Huntingdon',
    'Kings Lynn',
    'Lowestoft',
    'Bedfordshire',
    'Cambridgeshire',
    'Essex',
    'Hertfordshire',
    'Norfolk',
    'Suffolk'
];

locationHierarchy['East Midlands'].subcategories = [
    'Nottingham',
    'Leicester',
    'Derby',
    'Northampton',
    'Lincoln',
    'Mansfield',
    'Chesterfield',
    'Kettering',
    'Loughborough',
    'Boston',
    'Grantham',
    'Corby',
    'Hinckley',
    'Newark',
    'Wellingborough',
    'Derbyshire',
    'Leicestershire',
    'Lincolnshire',
    'Northamptonshire',
    'Nottinghamshire',
    'Rutland'
];

locationHierarchy['West Midlands'].subcategories = [
    'Birmingham',
    'Coventry',
    'Wolverhampton',
    'Stoke-on-Trent',
    'Solihull',
    'Walsall',
    'Dudley',
    'Sandwell',
    'Worcester',
    'Shrewsbury',
    'Telford',
    'Stafford',
    'Warwick',
    'Hereford',
    'Stratford-upon-Avon',
    'Lichfield',
    'Tamworth',
    'Redditch',
    'Kidderminster',
    'Herefordshire',
    'Shropshire',
    'Staffordshire',
    'Warwickshire',
    'Worcestershire'
];

locationHierarchy['Yorkshire and the Humber'].subcategories = [
    'Leeds',
    'Sheffield',
    'Bradford',
    'Hull',
    'York',
    'Huddersfield',
    'Middlesbrough',
    'Doncaster',
    'Rotherham',
    'Wakefield',
    'Barnsley',
    'Halifax',
    'Harrogate',
    'Scarborough',
    'Dewsbury',
    'Keighley',
    'Scunthorpe',
    'Grimsby',
    'East Yorkshire',
    'North Yorkshire',
    'South Yorkshire',
    'West Yorkshire'
];

locationHierarchy['North West England'].subcategories = [
    'Manchester',
    'Liverpool',
    'Warrington',
    'Bolton',
    'Blackpool',
    'Preston',
    'Chester',
    'Stockport',
    'Oldham',
    'Rochdale',
    'Salford',
    'Wigan',
    'Bury',
    'Blackburn',
    'St Helens',
    'Carlisle',
    'Lancaster',
    'Crewe',
    'Burnley',
    'Macclesfield',
    'Barrow-in-Furness',
    'Runcorn',
    'Ellesmere Port',
    'Cheshire',
    'Cumbria',
    'Greater Manchester',
    'Lancashire',
    'Merseyside'
];

locationHierarchy['North East England'].subcategories = [
    'Newcastle upon Tyne',
    'Sunderland',
    'Durham',
    'Gateshead',
    'Middlesbrough',
    'Stockton-on-Tees',
    'Darlington',
    'Hartlepool',
    'South Shields',
    'Tynemouth',
    'Washington',
    'Ashington',
    'Blyth',
    'Redcar',
    'Bishop Auckland',
    'County Durham',
    'Northumberland',
    'Tyne and Wear',
    'Teesside'
];

locationHierarchy['Scotland'].subcategories = [
    'Edinburgh',
    'Glasgow',
    'Aberdeen',
    'Dundee',
    'Inverness',
    'Perth',
    'Stirling',
    'Paisley',
    'East Kilbride',
    'Livingston',
    'Hamilton',
    'Cumbernauld',
    'Dunfermline',
    'Kirkcaldy',
    'Ayr',
    'Kilmarnock',
    'Greenock',
    'Coatbridge',
    'Glenrothes',
    'Falkirk'
];

locationHierarchy['Wales'].subcategories = [
    'Cardiff',
    'Swansea',
    'Newport',
    'Wrexham',
    'Barry',
    'Neath',
    'Cwmbran',
    'Llanelli',
    'Rhondda',
    'Merthyr Tydfil',
    'Bridgend',
    'Caerphilly',
    'Port Talbot',
    'Pontypridd',
    'Aberdare',
    'Colwyn Bay',
    'Rhyl',
    'Flintshire',
    'Gwynedd',
    'Anglesey'
];

locationHierarchy['Northern Ireland'].subcategories = [
    'Belfast',
    'Derry',
    'Lisburn',
    'Newtownabbey',
    'Bangor',
    'Craigavon',
    'Castlereagh',
    'Ballymena',
    'Newtownards',
    'Newry',
    'Carrickfergus',
    'Coleraine',
    'Omagh',
    'Larne',
    'Banbridge',
    'Armagh',
    'Dungannon',
    'Enniskillen',
    'Strabane',
    'Antrim'
];

locationHierarchy['Overseas'].subcategories = [
    'Republic of Ireland',
    'Channel Islands',
    'Isle of Man',
    'Europe',
    'Middle East',
    'Asia Pacific',
    'North America',
    'South America',
    'Africa',
    'Australia',
    'New Zealand',
    'Other International'
];

        // Update dynamic hierarchies
       dynamicProfessionHierarchy = JSON.parse(JSON.stringify(professionHierarchy));
        dynamicLocationHierarchy = JSON.parse(JSON.stringify(locationHierarchy));

        console.log('Full hierarchies loaded');
    }

    // Load full hierarchies after page loads
    if ('requestIdleCallback' in window) {
        requestIdleCallback(() => loadFullHierarchies(), { timeout: 2000 });
    } else {
        setTimeout(() => loadFullHierarchies(), 500);
    }

    let filterData = {};
    let keywords = [];
    let currentPage = 1;
    const jobsPerPage = 10;
    let filteredJobs = [];
    let activeCategoryFilter = 'all';
    let lastWindowWidth = window.innerWidth;

    const categoryFilters = {
        all: {
            name: 'All Jobs',
            keywords: [],
            filter: () => true
        },
        consultant: {
            name: 'Consultant',
            keywords: ['consultant'],
            filter: (job) => {
                const jobTitle = (job.job_title || '').toLowerCase();
                const grade = (job.grade || '').toLowerCase();
                return jobTitle.includes('consultant') || grade.includes('consultant');
            }
        },
gp: {
    name: 'GP',
    keywords: ['gp'],
    filter: (job) => {
        const sectors = job.sector || [];
        const jobTitle = (job.job_title || '').toLowerCase();
        const grade = (job.grade || '').toLowerCase();

        return sectors.some(sector => sector.toLowerCase().includes('gp')) ||
               jobTitle.includes('gp') ||
               grade.includes('gp');
    }
},
        overseas: {
            name: 'Overseas',
            keywords: [],
            filter: (job) => {
                const country = (job.location_country || '').toLowerCase().trim();
                const locationDesc = (job.location_description || '').toLowerCase().trim();

                const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales', 'northern ireland',
                                   'britain', 'great britain', 'gb', 'u.k.', 'united kindom'];

                if (country && country.length > 0) {
                    const isUK = ukCountries.some(ukVariant => country.includes(ukVariant));
                    if (!isUK) {
                        return true;
                    }
                }

                const overseasIndicators = [
                    'australia', 'new zealand', 'canada', 'usa', 'united states', 'america',
                    'dubai', 'uae', 'emirates', 'singapore', 'hong kong', 'japan', 'china',
                    'india', 'germany', 'france', 'spain', 'italy', 'netherlands', 'belgium',
                    'switzerland', 'norway', 'sweden', 'denmark', 'ireland', 'dublin',
                    'sydney', 'melbourne', 'brisbane', 'perth', 'adelaide', 'auckland',
                    'wellington', 'toronto', 'vancouver', 'montreal'
                ];

                for (const indicator of overseasIndicators) {
                    if (indicator === 'ireland' && (locationDesc.includes('northern') || country.includes('northern'))) {
                        continue;
                    }
                    if (locationDesc.includes(indicator)) {
                        return true;
                    }
                }

                const ukRegions = ['london', 'manchester', 'birmingham', 'leeds', 'glasgow',
                                  'edinburgh', 'cardiff', 'belfast', 'liverpool', 'bristol',
                                  'sheffield', 'newcastle', 'nottingham', 'southampton', 'oxford',
                                  'cambridge', 'brighton', 'leicester', 'coventry', 'hull'];

                const hasUKRegion = ukRegions.some(region => locationDesc.includes(region));
                if (hasUKRegion) {
                    return false;
                }

                if (country && country.length > 0) {
                    return !ukCountries.some(ukVariant => country.includes(ukVariant));
                }

                return false;
            }
        },
        training: {
            name: 'Academic',
            keywords: ['medical education', 'training', 'lecturer', 'professor'],
            filter: (job) => {
                const sectors = job.sector || [];
                const grade = (job.grade || '').toLowerCase();

                const hasEducationSector = sectors.some(sector =>
                    sector.toLowerCase().includes('medical education') &&
                    sector.toLowerCase().includes('training')
                );

                const hasAcademicGrade = grade.includes('lecturer') || grade.includes('professor');

                return hasEducationSector || hasAcademicGrade;
            }
        },
        special: {
            name: 'Special',
            keywords: ['special appointments'],
            filter: (job) => {
                const sectors = job.sector || [];
                return sectors.some(sector =>
                    sector.toLowerCase().includes('special appointments')
                );
            }
        },
        research: {
            name: 'Research',
            keywords: ['medical research'],
            filter: (job) => {
                const sectors = job.sector || [];
                return sectors.some(sector =>
                    sector.toLowerCase().includes('medical research')
                );
            }
        }
    };


 function generateJobCountText() {
        const count = filteredJobs.length;
        const searchTerm = document.getElementById('keywordSearch').value.trim();
        const checkedProfessions = getCheckedProfessions();
        const checkedLocations = getCheckedLocations();
        const checkedGrades = getCheckedGrades();

        // Build job type descriptor
        const jobTypeDescriptor = [];

        // Add category filter if active
        if (activeCategoryFilter && activeCategoryFilter !== 'all') {
            jobTypeDescriptor.push(categoryFilters[activeCategoryFilter].name);
        }

        // FIXED: Add grade filters properly
        if (checkedGrades.length > 0) {
            if (checkedGrades.length === 1) {
                jobTypeDescriptor.push(checkedGrades[0]);
            } else if (checkedGrades.length === 2) {
                jobTypeDescriptor.push(checkedGrades.join(' and '));
            } else {
                jobTypeDescriptor.push(`${checkedGrades[0]} and ${checkedGrades.length - 1} other grades`);
            }
        }

        // FIXED: Only add profession filters if no location is selected to avoid duplication
        if (checkedLocations.length === 0 && checkedProfessions.length > 0) {
            if (checkedProfessions.length === 1) {
                jobTypeDescriptor.push(checkedProfessions[0]);
            } else if (checkedProfessions.length === 2) {
                jobTypeDescriptor.push(checkedProfessions.join(' and '));
            } else {
                jobTypeDescriptor.push(`${checkedProfessions[0]} and ${checkedProfessions.length - 1} other professions`);
            }
        }

        // Add search term if it's a keyword
        if (searchTerm && keywords.includes(searchTerm)) {
            jobTypeDescriptor.push(searchTerm);
        }

        // Build the final text
        let text = `${count}`;

        // Add job type descriptor
        if (jobTypeDescriptor.length > 0) {
            text += ` ${jobTypeDescriptor.join(' ')}`;
        }

        // Add "job" or "jobs"
        text += count === 1 ? ' job' : ' jobs';

        // FIXED: Location handling - clean format
        if (checkedLocations.length > 0) {
            if (checkedLocations.length === 1) {
                text += ` in ${checkedLocations[0]}`;
            } else if (checkedLocations.length === 2) {
                text += ` in ${checkedLocations.join(' and ')}`;
            } else {
                text += ` in ${checkedLocations.length} locations`;
            }
        }

        // Add search term for non-keyword searches
        if (searchTerm && !keywords.includes(searchTerm)) {
            text += ` matching "${searchTerm}"`;
        }

        return text;
    }

    // Function to handle Date Published filter changes (radio-like behavior)
    function handlePublishedFilterChange(selectedValue) {
        // Uncheck all other published checkboxes
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && item.name !== selectedValue) {
                checkbox.checked = false;
            }
        });

        applyFilters(false);
        updateCategoryButtons();
    }

function countJobsForPublishedFilter(filterName, baseJobs) {
    return baseJobs.filter(job => {
        if (!job.published) return false;
        const jobDays = parseDaysFromPublished(job.published);
        if (!jobDays) return false;

        // Use the same logic as the actual filtering
        switch(filterName) {
            case "Last 7 Days":
                return jobDays <= 7;
            case "Last 14 Days":
                return jobDays <= 14;
            case "Last 28 Days":
                return jobDays <= 28;
            case "More than 28 Days":
                return jobDays > 28;
            default:
                return false;
        }
    }).length;
}


    // Function to make keywords keyboard accessible
    function renderKeywords() {
        const keywordsList = document.getElementById('keywordsList');
        keywordsList.innerHTML = keywords.map((keyword, index) =>
            `<button
                class="keyword-tag"
                onclick="selectKeyword('${keyword}')"
                onkeydown="handleKeywordKeydown(event, '${keyword}', ${index})"
                role="button"
                tabindex="0"
                aria-label="Select keyword: ${keyword}"
                data-index="${index}">
                ${keyword}
            </button>`
        ).join('');

        // Add keyboard navigation for arrow keys
        const keywordButtons = keywordsList.querySelectorAll('.keyword-tag');
        keywordButtons.forEach((btn, index) => {
            btn.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    const nextIndex = (index + 1) % keywordButtons.length;
                    keywordButtons[nextIndex].focus();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    const prevIndex = (index - 1 + keywordButtons.length) % keywordButtons.length;
                    keywordButtons[prevIndex].focus();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const nextRowIndex = Math.min(index + 3, keywordButtons.length - 1);
                    keywordButtons[nextRowIndex].focus();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prevRowIndex = Math.max(index - 3, 0);
                    keywordButtons[prevRowIndex].focus();
                }
            });
        });
    }

function handleKeywordKeydown(event, keyword, index) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectKeyword(keyword);
        }
    }

    window.selectKeyword = function(keyword) {
        document.getElementById('keywordSearch').value = keyword;
        applyFilters(false); // Don't scroll to top
        updateCategoryButtons();
    };

    // All other existing functions remain the same...
    function normalizeLocation(location) {
        return location.toLowerCase().trim()
            .replace(/\s+/g, ' ')
            .replace(/[^\w\s-]/g, '');
    }

    function categorizeLocation(locationStr) {
        const normalized = normalizeLocation(locationStr);

        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            if (normalizeLocation(region) === normalized) {
                return { region: region, isRegion: true };
            }
        }

        for (const [region, data] of Object.entries(dynamicLocationHierarchy)) {
            for (const subcategory of data.subcategories) {
                if (normalizeLocation(subcategory) === normalized) {
                    return { region: region, subcategory: subcategory, isRegion: false };
                }
            }
        }

        const ukCountries = ['england', 'scotland', 'wales', 'northern ireland', 'uk', 'united kingdom', 'britain', 'great britain', 'nationwide', 'homeworking'];

        const locationLower = locationStr.toLowerCase().trim();

        const isUK = ukCountries.some(country => locationLower.includes(country)) ||
                     Object.keys(locationHierarchy).filter(k => k !== 'Overseas').some(region =>
                         locationLower.includes(region.toLowerCase())
                     );

        if (!isUK) {
            let countryName = null;

            const parts = locationStr.split(',');
            if (parts.length > 1) {
                const potentialCountry = parts[parts.length - 1].trim();
                countryName = potentialCountry.split(' ').map(word =>
                    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                ).join(' ');
            } else {
                countryName = 'Other International';
            }

            return { region: 'Overseas', subcategory: countryName, isRegion: false };
        }

        if (normalized.includes('london')) {
            return { region: 'London', subcategory: 'Greater London', isRegion: false };
        }

        return { region: 'Other UK', subcategory: locationStr, isRegion: false };
    }

    function getCurrentDate() {
        return new Date();
    }

    function parseDaysFromPublished(publishedString) {
        if (!publishedString) return null;

        const lowerStr = publishedString.toLowerCase();

        if (lowerStr.includes('24 hours') || lowerStr.includes('today')) {
            return 1;
        } else if (lowerStr.includes('yesterday')) {
            return 1;
        } else if (lowerStr.includes('last') && lowerStr.includes('days')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) : null;
        } else if (lowerStr.includes('week')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 7 : 7;
        } else if (lowerStr.includes('month')) {
            const match = lowerStr.match(/(\d+)/);
            return match ? parseInt(match[1]) * 30 : 30;
        }

        return null;
    }

    function categorizePublishedString(publishedString) {
        const days = parseDaysFromPublished(publishedString);

        if (!days) return null;

        if (days <= 3) return "Last 3 Days";
        else if (days <= 7) return "Last 7 Days";
        else if (days <= 14) return "Last 14 Days";
        else if (days <= 28) return "Last 28 Days";
        else return "More than 28 Days";
    }

    function filterActiveJobs(jobs) {
        const currentDate = getCurrentDate();
        return jobs.filter(job => {
            if (job.job_end_date) {
                const endDate = new Date(job.job_end_date);
                return endDate >= currentDate;
            }
            return true;
        });
    }

    window.applyCategoryFilter = function(category) {
        activeCategoryFilter = category;
        updateCategoryButtons();

        if (category === 'all') {
            document.getElementById('keywordSearch').value = '';

            document.querySelectorAll('.filter-checkbox, .profession-parent-checkbox, .profession-sub-checkbox, .location-checkbox, .location-sub-checkbox').forEach(checkbox => {
                checkbox.checked = false;
                checkbox.classList.remove('indeterminate');
            });
        }

        applyFilters();
        scrollToTop();
    };

    window.clearKeywordSearch = function() {
        document.getElementById('keywordSearch').value = '';
        applyFilters(false); // Don't scroll
        updateCategoryButtons();
    };

    const keywordSearch = document.getElementById('keywordSearch');
    keywordSearch.addEventListener('input', function() {
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            requestAnimationFrame(() => {
                applyFilters(false); // Don't scroll on search
                updateCategoryButtons();
            });
        }, 300);
    });


  window.toggleFilterGroup = function(groupName) {
    const arrow = document.getElementById(groupName + 'Arrow');
    const options = document.getElementById(groupName + 'Options');
    const header = document.getElementById(groupName + '-header');

    // Prevent focus state
    if (header) {
        header.blur();
    }

    const isCollapsed = options.classList.contains('collapsed');

    if (isCollapsed) {
        options.classList.remove('collapsed');
        arrow.classList.remove('collapsed');
        arrow.textContent = '▼';
        options.style.display = 'block';
        header.setAttribute('aria-expanded', 'true');
    } else {
        options.classList.add('collapsed');
        arrow.classList.add('collapsed');
        arrow.textContent = '▶';
        options.style.display = 'none';
        header.setAttribute('aria-expanded', 'false');
    }
};

// Add keyboard handler for filter headers
window.handleFilterHeaderKeydown = function(event, groupName) {
    if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        toggleFilterGroup(groupName);
    }
};

// Add keyboard handler for parent category headers
window.handleParentCategoryKeydown = function(event, category, parentName) {
    if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        toggleParentCategory(category, parentName);
    }
};

   window.toggleParentCategory = function(category, parentName) {
    const arrow = document.getElementById(`${category}_parent_arrow_${parentName.replace(/\s+/g, '_')}`);
    const subcategories = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
    const header = arrow.closest('.profession-parent-header');

    // Remove any focus states
    if (event && event.target) {
        event.target.blur();
    }

    const isCollapsed = subcategories.classList.contains('collapsed');

    if (isCollapsed) {
        subcategories.classList.remove('collapsed');
        arrow.classList.remove('collapsed');
        arrow.textContent = '▼';
        subcategories.style.display = 'block';
        if (header) header.setAttribute('aria-expanded', 'true');
    } else {
        subcategories.classList.add('collapsed');
        arrow.classList.add('collapsed');
        arrow.textContent = '▶';
        subcategories.style.display = 'none';
        if (header) header.setAttribute('aria-expanded', 'false');
    }
};

    window.handleParentCategoryChange = function(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const isChecked = parentCheckbox.checked;

        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        subCheckboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
        });

       applyFilters(false);
       updateCategoryButtons();
    };

    window.handleSubCategoryChange = function(category, parentName, subName) {
        updateParentCheckboxState(category, parentName);
        // FIX 7: Don't scroll for filter changes
        applyFilters(false);
        updateCategoryButtons();
    };

    window.toggleProfessionParent = function(parentName) {
        toggleParentCategory('profession', parentName);
    };

    window.handleParentProfessionChange = function(parentName) {
        handleParentCategoryChange('profession', parentName);
    };

    window.handleSubProfessionChange = function(parentName, subName) {
        handleSubCategoryChange('profession', parentName, subName);

        if (window.self !== window.top) {
            window.parent.postMessage({
                type: 'bmj-careers-filter-change',
                filterType: 'profession',
                filterValue: subName,
                parent: parentName
            }, '*');
        }
    };

    window.handleFilterChange = function(category, value) {
        // Special handling for Date Published filters (radio-like behavior)
        if (category === 'published') {
            handlePublishedFilterChange(value);
        } else {
            if (window.widgetClientInfo && window.widgetClientInfo.clientId !== 'direct') {
                fetch('/api/track/widget', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        event: 'filter_change',
                        clientId: window.widgetClientInfo.clientId,
                        clientName: window.widgetClientInfo.clientName,
                        sessionId: window.widgetClientInfo.sessionId,
                        data: {
                            filterType: category,
                            filterValue: value,
                            timestamp: Date.now()
                        }
                    })
                }).catch(err => console.error('Filter tracking failed:', err));
            }

            // FIX 7: Don't scroll for filter changes
            applyFilters(false);
            updateCategoryButtons();
        }
    };


    (function initializeWidgetTracking() {
        const urlParams = new URLSearchParams(window.location.search);
        window.widgetClientInfo = {
            clientId: urlParams.get('client_id') || urlParams.get('utm_source') || 'direct',
            clientName: urlParams.get('client_name') || urlParams.get('utm_source') || 'Unknown',
            sessionId: urlParams.get('session_id') || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        };

        console.log('Widget initialized with client info:', window.widgetClientInfo);

        if (window.widgetClientInfo.clientId !== 'direct') {
            fetch('/api/track/widget', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: 'page_view',
                    clientId: window.widgetClientInfo.clientId,
                    clientName: window.widgetClientInfo.clientName,
                    sessionId: window.widgetClientInfo.sessionId,
                    data: {
                        url: window.location.href,
                        timestamp: Date.now()
                    }
                })
            }).catch(err => console.error('Page view tracking failed:', err));
        }
    })();

    window.applyToJob = function(jobId) {
        const job = window.allJobsData.find(j => j.id === jobId);

        console.log('Job click detected:', {
            jobId: jobId,
            jobTitle: job?.job_title,
            clientId: window.widgetClientInfo?.clientId
        });

        if (window.widgetClientInfo && window.widgetClientInfo.clientId !== 'direct') {
            fetch('/api/track/widget', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: 'job_click',
                    clientId: window.widgetClientInfo.clientId,
                    clientName: window.widgetClientInfo.clientName,
                    sessionId: window.widgetClientInfo.sessionId,
                    data: {
                        jobId: jobId,
                        jobTitle: job?.job_title || 'Unknown',
                        employer: job?.alternate_recruiter_name || job?.recruiter_name || 'Unknown',
                        timestamp: Date.now()
                    }
                })
            }).then(response => {
                console.log('Click tracked successfully');
            }).catch(err => {
                console.error('Click tracking failed:', err);
            });

            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-job-click',
                    jobId: jobId,
                    jobTitle: job?.job_title || 'Unknown',
                    employer: job?.alternate_recruiter_name || job?.recruiter_name || 'Unknown',
                    clientId: window.widgetClientInfo.clientId,
                    clientName: window.widgetClientInfo.clientName
                }, '*');
            }
        }

        if (job && job.job_url) {
            window.open(job.job_url, '_blank', 'noopener,noreferrer');
        } else {
            window.open('https://www.bmj.com/careers/job/' + jobId, '_blank', 'noopener,noreferrer');
        }
    };

    window.goToPage = function(page) {
        const totalPages = Math.ceil(filteredJobs.length / jobsPerPage);
        if (page < 1 || page > totalPages) return;

        currentPage = page;
        renderJobsList();
        updatePagination();

        document.querySelector('.jobs-section').scrollIntoView({ behavior: 'smooth' });
    };

    window.getCurrentPage = function() {
        return currentPage;
    };

    window.scrollToTop = function() {
        requestAnimationFrame(() => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    };

    const handleScroll = perfUtils.throttle(() => {
        const scrollToTopBtn = document.getElementById('scrollToTop');
        if (window.pageYOffset > 300) {
            scrollToTopBtn.classList.add('show');
        } else {
            scrollToTopBtn.classList.remove('show');
        }
    }, 100);

    window.trackWidgetEvent = function(eventType, eventData) {
        const urlParams = new URLSearchParams(window.location.search);
        const clientId = urlParams.get('client_id') || urlParams.get('utm_source') || 'direct';
        const clientName = urlParams.get('client_name') || clientId;
        const sessionId = urlParams.get('session_id') || 'direct_' + Date.now();

        if (window.self !== window.top) {
            window.parent.postMessage({
                type: 'bmj-careers-event',
                eventType: eventType,
                data: eventData,
                clientId: clientId,
                clientName: clientName,
                sessionId: sessionId
            }, '*');
        }

        fetch('/api/track/widget', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                event: eventType,
                clientId: clientId,
                clientName: clientName,
                sessionId: sessionId,
                data: eventData
            })
        }).catch(err => console.error('Tracking failed:', err));
    };

    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('keywordSearch');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const searchTerm = this.value;

                searchTimeout = setTimeout(() => {
                    if (window.widgetClientInfo && window.widgetClientInfo.clientId !== 'direct' && searchTerm) {
                        fetch('/api/track/widget', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                event: 'search',
                                clientId: window.widgetClientInfo.clientId,
                                clientName: window.widgetClientInfo.clientName,
                                sessionId: window.widgetClientInfo.sessionId,
                                data: {
                                    searchTerm: searchTerm,
                                    timestamp: Date.now()
                                }
                            })
                        }).catch(err => console.error('Search tracking failed:', err));
                    }
                }, 500);
            });
        }
    });

    function updateCategoryButtons() {
        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;
        const hasActiveFilters = searchTerm.length > 0 || hasCheckedFilters;

        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        const activeBtn = document.getElementById(`btn-${activeCategoryFilter}`);
        if (activeBtn) {
            if (activeCategoryFilter === 'all' && !hasActiveFilters) {
                activeBtn.classList.add('active');
            } else if (activeCategoryFilter !== 'all') {
                activeBtn.classList.add('active');
            }
        }
    }

    function updateParentCheckboxState(category, parentName) {
        const parentCheckbox = document.getElementById(`${category}_parent_${parentName.replace(/\s+/g, '_')}`);
        const subcategoryContainer = document.getElementById(`${category}_subcategories_${parentName.replace(/\s+/g, '_')}`);
        const subCheckboxes = subcategoryContainer.querySelectorAll(`.${category}-sub-checkbox`);

        const checkedCount = Array.from(subCheckboxes).filter(cb => cb.checked).length;
        const totalCount = subCheckboxes.length;

        if (checkedCount === 0) {
            parentCheckbox.checked = false;
            parentCheckbox.classList.remove('indeterminate');
        } else if (checkedCount === totalCount) {
            parentCheckbox.checked = true;
            parentCheckbox.classList.remove('indeterminate');
        } else {
            parentCheckbox.checked = false;
            parentCheckbox.classList.add('indeterminate');
        }
    }

// Build dynamic hierarchies from job data
    function buildDynamicHierarchies() {
        if (!professionHierarchy || Object.keys(professionHierarchy).length === 0) {
            loadFullHierarchies();
        }

        // Deep copy the base hierarchies
        dynamicProfessionHierarchy = JSON.parse(JSON.stringify(professionHierarchy));
        dynamicLocationHierarchy = JSON.parse(JSON.stringify(locationHierarchy));

        const activeJobs = filterActiveJobs(allJobsData);

        // Clear existing Overseas subcategories
        dynamicLocationHierarchy.Overseas.subcategories = [];

        // Track unique countries
        const overseasCountries = new Set();

        // Process locations for Overseas
        activeJobs.forEach(job => {
            if (categoryFilters.overseas.filter(job)) {
                const location = job.location_description || '';
                const country = job.location_country || '';

                let countryName = null;

                const locationLower = location.toLowerCase();
                const countryLower = country.toLowerCase();

                // Specific country detection
                if (locationLower.includes('australia') || countryLower.includes('australia') ||
                    locationLower.includes('sydney') || locationLower.includes('melbourne') ||
                    locationLower.includes('brisbane') || locationLower.includes('perth') ||
                    locationLower.includes('adelaide')) {
                    countryName = 'Australia';
                } else if (locationLower.includes('new zealand') || countryLower.includes('new zealand') ||
                           locationLower.includes('auckland') || locationLower.includes('wellington') ||
                           locationLower.includes('christchurch')) {
                    countryName = 'New Zealand';
                } else if (locationLower.includes('canada') || countryLower.includes('canada') ||
                           locationLower.includes('toronto') || locationLower.includes('vancouver') ||
                           locationLower.includes('montreal')) {
                    countryName = 'Canada';
                } else if ((locationLower.includes('ireland') || countryLower.includes('ireland') ||
                            locationLower.includes('dublin')) &&
                           !locationLower.includes('northern') && !countryLower.includes('northern')) {
                    countryName = 'Republic of Ireland';
                } else if (locationLower.includes('usa') || locationLower.includes('united states') ||
                           countryLower.includes('usa') || countryLower.includes('united states') ||
                           locationLower.includes('america')) {
                    countryName = 'United States';
                } else if (locationLower.includes('dubai') || locationLower.includes('uae') ||
                           countryLower.includes('dubai') || countryLower.includes('uae') ||
                           locationLower.includes('emirates')) {
                    countryName = 'UAE';
                } else if (locationLower.includes('singapore') || countryLower.includes('singapore')) {
                    countryName = 'Singapore';
                } else if (locationLower.includes('hong kong') || countryLower.includes('hong kong')) {
                    countryName = 'Hong Kong';
                } else if (locationLower.includes('germany') || countryLower.includes('germany')) {
                    countryName = 'Germany';
                } else if (locationLower.includes('france') || countryLower.includes('france')) {
                    countryName = 'France';
                } else if (locationLower.includes('spain') || countryLower.includes('spain')) {
                    countryName = 'Spain';
                } else if (locationLower.includes('netherlands') || countryLower.includes('netherlands')) {
                    countryName = 'Netherlands';
                } else if (locationLower.includes('switzerland') || countryLower.includes('switzerland')) {
                    countryName = 'Switzerland';
                } else if (country && country.length > 0) {
                    const ukCountries = ['united kingdom', 'uk', 'england', 'scotland', 'wales',
                                       'northern ireland', 'britain', 'great britain'];
                    const isUK = ukCountries.some(uk => country.toLowerCase().includes(uk));

                    if (!isUK) {
                        countryName = country.split(' ').map(word =>
                            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                        ).join(' ');
                    }
                }

                if (countryName) {
                    overseasCountries.add(countryName);
                }
            }
        });

        dynamicLocationHierarchy.Overseas.subcategories = Array.from(overseasCountries).sort();

        if (dynamicLocationHierarchy.Overseas.subcategories.length === 0) {
            dynamicLocationHierarchy.Overseas.subcategories = ['Other International'];
        }

        activeJobs.forEach(job => {
            if (job.sector && Array.isArray(job.sector)) {
                job.sector.forEach(sector => {
                    // Add new sectors to appropriate categories
                });
            }
        });
    }

       function getCheckedLocations() {
        const checkedLocations = [];
        const processedLocations = new Set(); // Prevent duplicates

        // Check simple location checkboxes first
        const simpleCheckboxes = document.querySelectorAll('.location-checkbox:checked');
        simpleCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                if (!processedLocations.has(cleanName)) {
                    checkedLocations.push(cleanName);
                    processedLocations.add(cleanName);
                }
            }
        });

        // Check sub location checkboxes
        const subCheckboxes = document.querySelectorAll('.location-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                if (!processedLocations.has(cleanName)) {
                    checkedLocations.push(cleanName);
                    processedLocations.add(cleanName);
                }
            }
        });

        return checkedLocations;
    }

    // FIXED: Get checked professions - only return actually selected professions
    function getCheckedProfessions() {
        const checkedProfessions = [];
        const processedProfessions = new Set(); // Prevent duplicates

        const subCheckboxes = document.querySelectorAll('.profession-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const professionName = label.textContent.trim();
                const cleanName = professionName.replace(/\s*\(\d+\)$/, '');
                if (!processedProfessions.has(cleanName)) {
                    checkedProfessions.push(cleanName);
                    processedProfessions.add(cleanName);
                }
            }
        });

        return checkedProfessions;
    }

    // FIXED: Add function to get checked grades
    function getCheckedGrades() {
        const checkedGrades = [];
        if (filterData.grade) {
            filterData.grade.forEach(item => {
                const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    checkedGrades.push(item.name);
                }
            });
        }
        return checkedGrades;
    }


    function buildLocationHierarchy() {
    const locationData = [];

    // Get base jobs for location counting (excluding location filters)
    const getBaseJobsForLocation = () => {
        let jobs = filterActiveJobs(allJobsData);

        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply profession filters
        const checkedProfessions = getCheckedProfessions();
        if (checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                return checkedProfessions.some(profession => {
                    if (profession.toLowerCase() === 'gp') {
                        return categoryFilters.gp.filter(job);
                    } else if (profession.toLowerCase().includes('consultant')) {
                        return categoryFilters.consultant.filter(job);
                    } else {
                        const sectors = job.sector || [];
                        const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''}`.toLowerCase();
                        return searchText.includes(profession.toLowerCase()) ||
                               sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                    }
                });
            });
        }

        // Apply grade filters
        const checkedGrades = [];
        filterData.grade?.forEach(item => {
            const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedGrades.push(item.name);
            }
        });
        if (checkedGrades.length > 0) {
            jobs = jobs.filter(job => {
                return checkedGrades.some(gradeName => {
                    if (gradeName.toLowerCase().includes('consultant')) {
                        return categoryFilters.consultant.filter(job);
                    } else {
                        return job.grade === gradeName;
                    }
                });
            });
        }

        // Apply published filters
        const checkedPublished = [];
        filterData.published?.forEach(item => {
            const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox && checkbox.checked) {
                checkedPublished.push(item.name);
            }
        });
        if (checkedPublished.length > 0) {
            jobs = jobs.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;
                return checkedPublished.some(selectedCategory => {
                    switch(selectedCategory) {
                        case "Last 3 Days": return jobDays <= 3;
                        case "Last 7 Days": return jobDays <= 7;
                        case "Last 14 Days": return jobDays <= 14;
                        case "Last 28 Days": return jobDays <= 28;
                        case "More than 28 Days": return jobDays > 28;
                        default: return false;
                    }
                });
            });
        }

        return jobs;
    };

    const baseJobs = getBaseJobsForLocation();

    // Count London jobs directly
    const londonCount = baseJobs.filter(job => {
        const location = job.location_description || '';
        const normalizedLocation = normalizeLocation(location);
        return normalizedLocation.includes('london');
    }).length;

    if (londonCount > 0) {
        locationData.push({
            name: 'London',
            count: londonCount,
            subcategories: []
        });
    }

    // Process other location categories
    Object.entries(dynamicLocationHierarchy).forEach(([parentName, parentData]) => {
        if (parentName === 'London') return; // Already handled above

        const subcategoryData = [];
        let parentCount = 0;

        parentData.subcategories.forEach(subcategory => {
            let subcategoryCount;

            if (parentName === 'Overseas') {
                // Special handling for overseas locations
                subcategoryCount = baseJobs.filter(job => {
                    if (!categoryFilters.overseas.filter(job)) {
                        return false;
                    }

                    const location = job.location_description || '';
                    const country = job.location_country || '';
                    const locationLower = location.toLowerCase();
                    const countryLower = country.toLowerCase();

                    if (subcategory === 'Canada') {
                        return locationLower.includes('canada') || countryLower.includes('canada');
                    } else if (subcategory === 'Australia') {
                        return locationLower.includes('australia') || countryLower.includes('australia');
                    } else if (subcategory === 'New Zealand') {
                        return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                    } else if (subcategory === 'Republic of Ireland') {
                        return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                               !locationLower.includes('northern') && !countryLower.includes('northern');
                    } else if (subcategory === 'United States') {
                        return locationLower.includes('usa') || locationLower.includes('united states') ||
                               countryLower.includes('usa') || countryLower.includes('united states');
                    } else if (subcategory === 'UAE') {
                        return locationLower.includes('dubai') || locationLower.includes('uae') ||
                               countryLower.includes('dubai') || countryLower.includes('uae');
                    } else if (subcategory === country) {
                        return true;
                    }
                    return false;
                }).length;
            } else {
                // Regular UK location matching
                subcategoryCount = baseJobs.filter(job => {
                    const location = job.location_description || '';
                    const normalizedLocation = normalizeLocation(location);
                    const normalizedSubcategory = normalizeLocation(subcategory);
                    return normalizedLocation.includes(normalizedSubcategory);
                }).length;
            }

            if (subcategoryCount > 0) {
                subcategoryData.push({ name: subcategory, count: subcategoryCount });
                parentCount += subcategoryCount;
            }
        });

        if (parentCount > 0) {
            locationData.push({
                name: parentName,
                count: parentCount,
                subcategories: subcategoryData
            });
        }
    });

    return locationData;
}

    function getCheckedLocations() {
        const checkedLocations = [];

        const simpleCheckboxes = document.querySelectorAll('.location-checkbox:checked');
        simpleCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        const subCheckboxes = document.querySelectorAll('.location-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const locationName = label.textContent.trim();
                const cleanName = locationName.replace(/\s*\(\d+\)$/, '');
                checkedLocations.push(cleanName);
            }
        });

        return checkedLocations;
    }


    function getCheckedProfessions() {
        const checkedProfessions = [];

        const subCheckboxes = document.querySelectorAll('.profession-sub-checkbox:checked');
        subCheckboxes.forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            if (label && label.textContent) {
                const professionName = label.textContent.trim();
                const cleanName = professionName.replace(/\s*\(\d+\)$/, '');
                checkedProfessions.push(cleanName);
            }
        });

        return checkedProfessions;
    }

   function calculateFilterCounts() {
    // Initialize as empty arrays
    filterData = {
        published: [],
        profession: [],
        grade: [],
        location: []
    };

    const activeJobs = filterActiveJobs(allJobsData);
    if (activeJobs.length === 0) return;

    buildDynamicHierarchies();

    // Get base jobs after applying current filters (excluding the filter type we're counting)
    const getBaseJobsExcluding = (excludeFilterType) => {
        let jobs = activeJobs;

        if (activeCategoryFilter !== 'all') {
            jobs = jobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
        }

        const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
        if (searchTerm) {
            jobs = jobs.filter(job => {
                const sectors = job.sector || [];
                const employer = job.alternate_recruiter_name || job.recruiter_name;
                return job.job_title.toLowerCase().includes(searchTerm) ||
                       job.location_description.toLowerCase().includes(searchTerm) ||
                       employer.toLowerCase().includes(searchTerm) ||
                       job.short_description.toLowerCase().includes(searchTerm) ||
                       sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                       (job.grade && job.grade.toLowerCase().includes(searchTerm));
            });
        }

        // Apply all other active filters except the one we're excluding
        const checkedProfessions = getCheckedProfessions();
        if (excludeFilterType !== 'profession' && checkedProfessions.length > 0) {
            jobs = jobs.filter(job => {
                return checkedProfessions.some(profession => {
                    if (profession.toLowerCase() === 'gp') {
                        return categoryFilters.gp.filter(job);
                    } else if (profession.toLowerCase().includes('consultant')) {
                        return categoryFilters.consultant.filter(job);
                    } else {
                        const sectors = job.sector || [];
                        const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description}`.toLowerCase();
                        return searchText.includes(profession.toLowerCase()) ||
                               sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                    }
                });
            });
        }

        const checkedLocations = getCheckedLocations();
        if (excludeFilterType !== 'location' && checkedLocations.length > 0) {
            jobs = jobs.filter(job => {
                const jobLocation = job.location_description || '';
                return checkedLocations.some(location => {
                    const normalizedJobLocation = normalizeLocation(jobLocation);
                    const normalizedSearch = normalizeLocation(location);
                    return normalizedJobLocation.includes(normalizedSearch);
                });
            });
        }

        const checkedGrades = [];
        if (excludeFilterType !== 'grade') {
            filterData.grade?.forEach(item => {
                const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    checkedGrades.push(item.name);
                }
            });
            if (checkedGrades.length > 0) {
                jobs = jobs.filter(job => {
                    return checkedGrades.some(gradeName => {
                        if (gradeName.toLowerCase().includes('consultant')) {
                            return categoryFilters.consultant.filter(job);
                        } else {
                            return job.grade === gradeName;
                        }
                    });
                });
            }
        }

        const checkedPublished = [];
        if (excludeFilterType !== 'published') {
            filterData.published?.forEach(item => {
                const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    checkedPublished.push(item.name);
                }
            });
            if (checkedPublished.length > 0) {
                jobs = jobs.filter(job => {
                    if (!job.published) return false;
                    const jobDays = parseDaysFromPublished(job.published);
                    if (!jobDays) return false;
                    return checkedPublished.some(selectedCategory => {
                        switch(selectedCategory) {
                            case "Last 3 Days": return jobDays <= 3;
                            case "Last 7 Days": return jobDays <= 7;
                            case "Last 14 Days": return jobDays <= 14;
                            case "Last 28 Days": return jobDays <= 28;
                            case "More than 28 Days": return jobDays > 28;
                            default: return false;
                        }
                    });
                });
            }
        }

        return jobs;
    };

   // Count published filters using the same logic as filtering
const baseJobsForPublished = getBaseJobsExcluding('published');

const publishedOrder = ["Last 7 Days", "Last 14 Days", "Last 28 Days", "More than 28 Days"];
filterData.published = publishedOrder
    .map(category => ({
        name: category,
        count: countJobsForPublishedFilter(category, baseJobsForPublished)
    }))
    .filter(item => item.count > 0);
    // Count grades
    const baseJobsForGrades = getBaseJobsExcluding('grade');
    let gradeCounts = {};
    baseJobsForGrades.forEach(job => {
        if (job.grade) {
            gradeCounts[job.grade] = (gradeCounts[job.grade] || 0) + 1;
        }
    });

    filterData.grade = Object.entries(gradeCounts)
        .map(([name, originalCount]) => {
            // Use category filter logic for Consultant grades
            let actualCount;
            if (name.toLowerCase().includes('consultant')) {
                actualCount = baseJobsForGrades.filter(job => categoryFilters.consultant.filter(job)).length;
            } else {
                actualCount = originalCount;
            }
            return { name, count: actualCount };
        })
        .filter(item => item.count > 0)
        .sort((a, b) => b.count - a.count);

    // Build profession hierarchy with correct counts
    const baseJobsForProfessions = getBaseJobsExcluding('profession');
    filterData.profession = buildProfessionHierarchyWithCorrectCounts(baseJobsForProfessions);

    // Build location hierarchy
    filterData.location = buildLocationHierarchy();

    console.log('FilterData rebuilt with consistent counts');
}


function buildProfessionHierarchyWithCorrectCounts(baseJobs) {
    const professionData = [];

    Object.entries(dynamicProfessionHierarchy).forEach(([parentName, parentData]) => {
        let actualParentCount = 0;
        const subcategoryData = [];

// SPECIAL HANDLING FOR GP - Use exact filtering logic for counts
if (parentName === 'GP') {
    const gpJobs = baseJobs.filter(job => categoryFilters.gp.filter(job));
    actualParentCount = gpJobs.length;

    // Count specific GP subcategories using the same logic as filtering
    const specificGPCounts = {};

    parentData.subcategories.forEach(subcategory => {
        const subJobs = gpJobs.filter(job => {
            const jobTitle = job.job_title.toLowerCase();
            const grade = (job.grade || '').toLowerCase();
            const searchText = `${jobTitle} ${job.short_description} ${grade}`.toLowerCase();
            const subcatLower = subcategory.toLowerCase();

            return searchText.includes(subcatLower) ||
                   jobTitle.includes(subcatLower) ||
                   grade.includes(subcatLower);
        });

        if (subJobs.length > 0) {
            specificGPCounts[subcategory] = subJobs.length;
            subcategoryData.push({ name: subcategory, count: subJobs.length });
        }
    });

    // Count generic GP jobs (GP jobs that don't match specific subcategories)
    const genericGPJobs = gpJobs.filter(job => {
        const jobTitle = job.job_title.toLowerCase();
        const grade = (job.grade || '').toLowerCase();
        const searchText = `${jobTitle} ${job.short_description} ${grade}`.toLowerCase();

        const isSpecificGPType = ['digital gp', 'gp partner', 'gp trainee', 'locum gp', 'salaried gp'].some(gpType =>
            searchText.includes(gpType) || jobTitle.includes(gpType) || grade.includes(gpType)
        );

        return !isSpecificGPType;
    });

    if (genericGPJobs.length > 0) {
        subcategoryData.unshift({
            name: 'GP',
            count: genericGPJobs.length
        });
    }
}
        // NORMAL HANDLING FOR OTHER PROFESSIONS
        else {
            const processedJobIds = new Set();

            parentData.subcategories.forEach(subcategory => {
                if (typeof subcategory === 'string') {
                    let matchingJobs;
                    if (subcategory.toLowerCase().includes('consultant')) {
                        matchingJobs = baseJobs.filter(job => categoryFilters.consultant.filter(job));
                    } else {
                        matchingJobs = baseJobs.filter(job => {
                            const sectors = job.sector || [];
                            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''}`.toLowerCase();
                            return searchText.includes(subcategory.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === subcategory.toLowerCase());
                        });
                    }

                    if (matchingJobs.length > 0) {
                        subcategoryData.push({ name: subcategory, count: matchingJobs.length });
                        matchingJobs.forEach(job => processedJobIds.add(job.id));
                    }
                } else if (typeof subcategory === 'object' && subcategory.subcategories) {
                    const nestedSubcategories = [];
                    let nestedParentCount = 0;
                    const nestedProcessedJobIds = new Set();

                    subcategory.subcategories.forEach(nestedSub => {
                        let matchingJobs;
                        if (nestedSub.toLowerCase().includes('consultant')) {
                            matchingJobs = baseJobs.filter(job => categoryFilters.consultant.filter(job));
                        } else {
                            matchingJobs = baseJobs.filter(job => {
                                const sectors = job.sector || [];
                                const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''}`.toLowerCase();
                                return searchText.includes(nestedSub.toLowerCase()) ||
                                       sectors.some(s => s.toLowerCase() === nestedSub.toLowerCase());
                            });
                        }

                        if (matchingJobs.length > 0) {
                            nestedSubcategories.push({ name: nestedSub, count: matchingJobs.length });
                            matchingJobs.forEach(job => {
                                if (!nestedProcessedJobIds.has(job.id)) {
                                    nestedProcessedJobIds.add(job.id);
                                    nestedParentCount++;
                                }
                            });
                        }
                    });

                    if (nestedParentCount > 0) {
                        subcategoryData.push({
                            name: subcategory.name,
                            count: nestedParentCount,
                            subcategories: nestedSubcategories
                        });
                        nestedProcessedJobIds.forEach(id => processedJobIds.add(id));
                    }
                }
            });

            actualParentCount = processedJobIds.size;
        }

        if (actualParentCount > 0) {
            professionData.push({
                name: parentName,
                count: actualParentCount,
                subcategories: subcategoryData
            });
        }
    });

    return professionData;
}


 function renderLocationFilters(locationData) {
    return `
        <div class="filter-group" role="region" aria-labelledby="location-header">
            <button class="filter-header" onclick="toggleFilterGroup('location')" onkeydown="handleFilterHeaderKeydown(event, 'location')" id="location-header" aria-expanded="true" tabindex="0">
                <span class="filter-arrow" id="locationArrow">▼</span>
                <span>Location</span>
            </button>
            <div class="filter-options" id="locationOptions" style="display: block;">
                ${locationData.map(parent => {
                    const hasSubcategories = parent.subcategories && parent.subcategories.length > 0;
                    if (!hasSubcategories) {
                        return `
                            <div class="filter-item">
                                <input type="checkbox" class="filter-checkbox location-checkbox" id="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                       onchange="handleFilterChange('location', '${parent.name}')" aria-label="${parent.name} location filter">
                                <label class="filter-label" for="location_${parent.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${parent.name}</label>
                                <span class="filter-count">${parent.count}</span>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="profession-parent-group">
                                <button class="profession-parent-header" onclick="toggleParentCategory('location', '${parent.name}')" onkeydown="handleParentCategoryKeydown(event, 'location', '${parent.name}')" aria-expanded="false" tabindex="0">
                                    <input type="checkbox" class="profession-parent-checkbox" id="location_parent_${parent.name.replace(/\s+/g, '_')}"
                                           onchange="handleParentCategoryChange('location', '${parent.name}')" onclick="event.stopPropagation()" aria-label="${parent.name} location category" tabindex="-1">
                                    <label class="profession-parent-label" for="location_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                                    <span class="filter-count">${parent.count}</span>
                                    <span class="profession-parent-arrow collapsed" id="location_parent_arrow_${parent.name.replace(/\s+/g, '_')}">▶</span>
                                </button>
                                <div class="profession-subcategories collapsed" id="location_subcategories_${parent.name.replace(/\s+/g, '_')}" style="display: none;">
                                    ${parent.subcategories.map(sub => `
                                        <div class="profession-sub-item">
                                            <input type="checkbox" class="profession-sub-checkbox location-sub-checkbox" id="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                                   onchange="handleSubCategoryChange('location', '${parent.name}', '${sub.name}')" aria-label="${sub.name} location">
                                            <label class="profession-sub-label" for="location_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                                            <span class="filter-count">${sub.count}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                }).join('')}
            </div>
        </div>
    `;
}

  function renderProfessionFilters(professionData) {
    return `
        <div class="filter-group" role="region" aria-labelledby="profession-header">
            <button class="filter-header" onclick="toggleFilterGroup('profession')" onkeydown="handleFilterHeaderKeydown(event, 'profession')" id="profession-header" aria-expanded="true" tabindex="0">
                <span class="filter-arrow" id="professionArrow">▼</span>
                <span>Profession</span>
            </button>
            <div class="filter-options" id="professionOptions" style="display: block;">
                ${professionData.map(parent => `
                    <div class="profession-parent-group">
                        <button class="profession-parent-header" onclick="toggleProfessionParent('${parent.name}')" onkeydown="handleParentCategoryKeydown(event, 'profession', '${parent.name}')" aria-expanded="false" tabindex="0">
                            <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${parent.name.replace(/\s+/g, '_')}"
                                   onchange="handleParentProfessionChange('${parent.name}')" onclick="event.stopPropagation()" aria-label="${parent.name} profession category" tabindex="-1">
                            <label class="profession-parent-label" for="profession_parent_${parent.name.replace(/\s+/g, '_')}">${parent.name}</label>
                            <span class="filter-count">${parent.count}</span>
                            <span class="profession-parent-arrow collapsed" id="profession_parent_arrow_${parent.name.replace(/\s+/g, '_')}">▶</span>
                        </button>
                        <div class="profession-subcategories collapsed" id="profession_subcategories_${parent.name.replace(/\s+/g, '_')}" style="display: none;">
                            ${parent.subcategories.map(sub => renderSubProfession(sub, parent.name)).join('')}
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

function renderSubProfession(sub, parentName) {
    if (sub.subcategories) {
        return `
            <div class="profession-parent-group" style="margin-left: 20px;">
                <button class="profession-parent-header" onclick="toggleProfessionParent('${sub.name}')" onkeydown="handleParentCategoryKeydown(event, 'profession', '${sub.name}')" aria-expanded="false" tabindex="0">
                    <input type="checkbox" class="profession-parent-checkbox" id="profession_parent_${sub.name.replace(/\s+/g, '_')}"
                           onchange="handleParentProfessionChange('${sub.name}')" onclick="event.stopPropagation()" aria-label="${sub.name} profession subcategory" tabindex="-1">
                    <label class="profession-parent-label" for="profession_parent_${sub.name.replace(/\s+/g, '_')}">${sub.name}</label>
                    <span class="filter-count">${sub.count}</span>
                    <span class="profession-parent-arrow collapsed" id="profession_parent_arrow_${sub.name.replace(/\s+/g, '_')}">▶</span>
                </button>
                <div class="profession-subcategories collapsed" id="profession_subcategories_${sub.name.replace(/\s+/g, '_')}" style="display: none;">
                    ${sub.subcategories.map(nestedSub => `
                        <div class="profession-sub-item">
                            <input type="checkbox" class="profession-sub-checkbox" id="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                                   onchange="handleSubProfessionChange('${sub.name}', '${nestedSub.name}')" aria-label="${nestedSub.name} profession">
                            <label class="profession-sub-label" for="profession_${nestedSub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${nestedSub.name}</label>
                            <span class="filter-count">${nestedSub.count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    } else {
        return `
            <div class="profession-sub-item">
                <input type="checkbox" class="profession-sub-checkbox" id="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}"
                       onchange="handleSubProfessionChange('${parentName}', '${sub.name}')" aria-label="${sub.name} profession">
                <label class="profession-sub-label" for="profession_${sub.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '').replace(/,/g, '')}">${sub.name}</label>
                <span class="filter-count">${sub.count}</span>
            </div>
        `;
    }
}

function renderFilters() {
    const filtersContainer = document.getElementById('filtersContainer');
    let filterHTML = '';

const renderFilterSection = (title, data, type, expanded = true) => {
    if (!data || data.length === 0) return '';

    const maxInitialItems = 20;
    const visibleItems = data.slice(0, maxInitialItems);
    const hasMore = data.length > maxInitialItems;

    return `
        <div class="filter-group" role="region" aria-labelledby="${type}-header">
            <button class="filter-header" onclick="toggleFilterGroup('${type}')" id="${type}-header" aria-expanded="${expanded}" tabindex="0">
                <span class="filter-arrow" id="${type}Arrow">${expanded ? '▼' : '▶'}</span>
                <span>${title}</span>
            </button>
            <div class="filter-options" id="${type}Options" style="display: ${expanded ? 'block' : 'none'};">
                ${visibleItems.map(item => renderFilterItem(item, type)).join('')}
                ${hasMore ? `<button class="load-more-btn" onclick="loadMoreFilters('${type}')" style="margin: 8px 0; padding: 4px 8px; border: 1px solid #ccc; background: #f9f9f9; border-radius: 4px; cursor: pointer;">Load More (${data.length - maxInitialItems} remaining)</button>` : ''}
            </div>
        </div>
    `;
};

  const renderFilterItem = (item, type) => {
    const checkboxId = `${type}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
    return `
        <div class="filter-item">
            <input type="checkbox" class="filter-checkbox" id="${checkboxId}" onchange="handleFilterChange('${type}', '${item.name}')">
            <label class="filter-label" for="${checkboxId}">${item.name}</label>
            <span class="filter-count">${item.count}</span>
        </div>
    `;
};

    // Render sections
    filterHTML += renderFilterSection('Date Published', filterData.published, 'published', true);
    filterHTML += renderFilterSection('Grade', filterData.grade, 'grade', true);

    // Profession and Location with hierarchy - simplified for performance
    if (filterData.profession && filterData.profession.length > 0) {
        filterHTML += renderProfessionFilters(filterData.profession);
    }

    if (filterData.location && filterData.location.length > 0) {
        filterHTML += renderLocationFilters(filterData.location);
    }

    filtersContainer.innerHTML = filterHTML;
}

window.loadMoreFilters = function(type) {
    const container = document.getElementById(`${type}Options`);
    const loadMoreBtn = container.querySelector('.load-more-btn');
    if (loadMoreBtn) {
        loadMoreBtn.style.display = 'none';
        // Load remaining items...
    }
};

function applyFilters(shouldScroll = true) {
    const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
    const activeFilters = {};

    // Get all active filter selections
    Object.keys(filterData).forEach(category => {
        activeFilters[category] = [];
        if (category === 'profession') {
            activeFilters[category] = getCheckedProfessions();
        } else if (category === 'location') {
            activeFilters[category] = getCheckedLocations();
        } else {
            if (filterData[category]) {
                filterData[category].forEach(item => {
                    const checkboxId = `${category}_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox && checkbox.checked) {
                        activeFilters[category].push(item.name);
                    }
                });
            }
        }
    });

    const hasActiveFilters = searchTerm.length > 0 || Object.values(activeFilters).some(arr => arr.length > 0);

    if (hasActiveFilters && activeCategoryFilter === 'all') {
        const allBtn = document.getElementById('btn-all');
        if (allBtn) allBtn.classList.remove('active');
    }

    let activeJobs = filterActiveJobs(allJobsData);

    // **CRITICAL FIX**: Use the EXACT same filtering logic as the count display
    filteredJobs = activeJobs.filter(job => {
        // Apply category filter first
        if (activeCategoryFilter !== 'all') {
            if (!categoryFilters[activeCategoryFilter].filter(job)) {
                return false;
            }
        }

        // Apply search filter
        if (searchTerm.length > 0) {
            const sectors = job.sector || [];
            const employer = job.alternate_recruiter_name || job.recruiter_name;
            const matchesSearch = job.job_title.toLowerCase().includes(searchTerm) ||
                                job.location_description.toLowerCase().includes(searchTerm) ||
                                employer.toLowerCase().includes(searchTerm) ||
                                job.short_description.toLowerCase().includes(searchTerm) ||
                                sectors.some(s => s.toLowerCase().includes(searchTerm)) ||
                                (job.grade && job.grade.toLowerCase().includes(searchTerm));
            if (!matchesSearch) return false;
        }

        // Apply profession filters - USE EXACT SAME LOGIC AS COUNT CALCULATION
        if (activeFilters.profession.length > 0) {
const matchesProfession = activeFilters.profession.some(profession => {
    // Handle GP subcategories specifically
    if (profession === 'GP') {
        // For main GP option, filter out jobs that match specific GP subcategories
        const isGPJob = categoryFilters.gp.filter(job);
        if (!isGPJob) return false;

        // Check if it's NOT a specific GP type
        const jobTitle = job.job_title.toLowerCase();
        const grade = (job.grade || '').toLowerCase();
        const searchText = `${jobTitle} ${job.short_description} ${grade}`.toLowerCase();

        const isSpecificGPType = ['digital gp', 'gp partner', 'gp trainee', 'locum gp', 'salaried gp'].some(gpType =>
            searchText.includes(gpType) || jobTitle.includes(gpType) || grade.includes(gpType)
        );

        return !isSpecificGPType; // Return jobs that are GP but not specific types
    } else if (profession.includes('GP') && profession !== 'GP') {
        // For specific GP subcategories, use specific matching
        const isGPJob = categoryFilters.gp.filter(job);
        if (!isGPJob) return false;

        const jobTitle = job.job_title.toLowerCase();
        const grade = (job.grade || '').toLowerCase();
        const searchText = `${jobTitle} ${job.short_description} ${grade}`.toLowerCase();
        const professionLower = profession.toLowerCase();

        return searchText.includes(professionLower) ||
               jobTitle.includes(professionLower) ||
               grade.includes(professionLower);
    } else if (profession.toLowerCase().includes('consultant')) {
        return categoryFilters.consultant.filter(job);
    } else {
        const sectors = job.sector || [];
        const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''}`.toLowerCase();
        return searchText.includes(profession.toLowerCase()) ||
               sectors.some(s => s.toLowerCase() === profession.toLowerCase());
    }
});
            if (!matchesProfession) return false;
        }

        // Apply location filters
        if (activeFilters.location.length > 0) {
            const matchesLocation = activeFilters.location.some(location => {
                if (dynamicLocationHierarchy.Overseas && dynamicLocationHierarchy.Overseas.subcategories.includes(location)) {
                    if (!categoryFilters.overseas.filter(job)) {
                        return false;
                    }
                    const country = job.location_country || '';
                    const jobLocation = job.location_description || '';
                    const locationLower = jobLocation.toLowerCase();
                    const countryLower = country.toLowerCase();

                    if (location === 'Canada') {
                        return locationLower.includes('canada') || countryLower.includes('canada');
                    } else if (location === 'Australia') {
                        return locationLower.includes('australia') || countryLower.includes('australia');
                    } else if (location === 'New Zealand') {
                        return locationLower.includes('new zealand') || countryLower.includes('new zealand');
                    } else if (location === 'Republic of Ireland') {
                        return (locationLower.includes('ireland') || countryLower.includes('ireland')) &&
                               !locationLower.includes('northern') && !countryLower.includes('northern');
                    }
                    return false;
                } else {
                    const jobLocation = job.location_description || '';
                    const normalizedJobLocation = normalizeLocation(jobLocation);
                    const normalizedSearch = normalizeLocation(location);
                    return normalizedJobLocation.includes(normalizedSearch);
                }
            });
            if (!matchesLocation) return false;
        }

        // Apply grade filters - USE EXACT SAME LOGIC AS COUNT CALCULATION
        if (activeFilters.grade.length > 0) {
            const matchesGrade = activeFilters.grade.some(gradeName => {
                if (gradeName.toLowerCase().includes('consultant')) {
                    return categoryFilters.consultant.filter(job);
                } else {
                    return job.grade === gradeName;
                }
            });
            if (!matchesGrade) return false;
        }

        // Apply published filters
        if (activeFilters.published.length > 0) {
            if (!job.published) return false;
            const jobDays = parseDaysFromPublished(job.published);
            if (!jobDays) return false;

            const matchesPublished = activeFilters.published.some(selectedCategory => {
                switch(selectedCategory) {
                    case "Last 3 Days": return jobDays <= 3;
                    case "Last 7 Days": return jobDays <= 7;
                    case "Last 14 Days": return jobDays <= 14;
                    case "Last 28 Days": return jobDays <= 28;
                    case "More than 28 Days": return jobDays > 28;
                    default: return false;
                }
            });
            if (!matchesPublished) return false;
        }

        return true;
    });

    currentPage = 1;
    renderJobsList();
    updatePagination();
    updateJobCount();

    if (shouldScroll) {
        scrollToTop();
    }

    // Refresh published counts dynamically (isolated from other functionality)
if (typeof updateFilterCounts === 'function') {
    setTimeout(() => {
        updateFilterCounts();
    }, 50);
}
}


   function updateFilterCounts() {
    const activeFilters = {
        profession: getCheckedProfessions(),
        location: getCheckedLocations(),
        grade: [],
        published: [],
        searchTerm: document.getElementById('keywordSearch').value.toLowerCase().trim()
    };

    filterData.grade?.forEach(item => {
        const checkboxId = `grade_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
        const checkbox = document.getElementById(checkboxId);
        if (checkbox && checkbox.checked) {
            activeFilters.grade.push(item.name);
        }
    });

    filterData.published?.forEach(item => {
        const checkboxId = `published_${item.name.replace(/\s+/g, '_').replace(/[()]/g, '').replace(/\./g, '')}`;
        const checkbox = document.getElementById(checkboxId);
        if (checkbox && checkbox.checked) {
            activeFilters.published.push(item.name);
        }
    });

    // Get base jobs after applying category filter and search
    let baseJobs = filterActiveJobs(allJobsData);

    if (activeCategoryFilter !== 'all') {
        baseJobs = baseJobs.filter(job => categoryFilters[activeCategoryFilter].filter(job));
    }

    if (activeFilters.searchTerm) {
        baseJobs = baseJobs.filter(job => {
            const sectors = job.sector || [];
            const employer = job.alternate_recruiter_name || job.recruiter_name;
            return job.job_title.toLowerCase().includes(activeFilters.searchTerm) ||
                   job.location_description.toLowerCase().includes(activeFilters.searchTerm) ||
                   employer.toLowerCase().includes(activeFilters.searchTerm) ||
                   job.short_description.toLowerCase().includes(activeFilters.searchTerm) ||
                   sectors.some(s => s.toLowerCase().includes(activeFilters.searchTerm)) ||
                   (job.grade && job.grade.toLowerCase().includes(activeFilters.searchTerm));
        });
    }

    // Update counts for each filter option
    function updateFilterOptionCounts() {
        // Update profession counts
        // Update profession counts
document.querySelectorAll('.profession-sub-item .filter-count').forEach(countElement => {
    const item = countElement.closest('.profession-sub-item');
    const checkbox = item.querySelector('.profession-sub-checkbox');
    if (checkbox) {
        const label = checkbox.nextElementSibling;
        if (label) {
            const professionName = label.textContent.trim().replace(/\s*\(\d+\)$/, '');

			if (professionName === 'GP' || professionName.includes('GP')) {
                return; // Skip this iteration
            }

            // Count jobs that would match if this profession was selected
            const jobsForThisProfession = baseJobs.filter(job => {
                // Apply all OTHER active filters except this profession
                let matchesOtherFilters = true;

                // Check locations
                if (activeFilters.location.length > 0) {
                    const jobLocation = job.location_description || '';
                    const matchesLocation = activeFilters.location.some(location => {
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    });
                    if (!matchesLocation) matchesOtherFilters = false;
                }

                // Check grades
                if (activeFilters.grade.length > 0) {
                    const matchesGrade = activeFilters.grade.some(gradeName => {
                        if (gradeName.toLowerCase().includes('consultant')) {
                            return categoryFilters.consultant.filter(job);
                        } else {
                            return job.grade === gradeName;
                        }
                    });
                    if (!matchesGrade) matchesOtherFilters = false;
                }

                // Check published
                if (activeFilters.published.length > 0) {
                    if (!job.published) return false;
                    const jobDays = parseDaysFromPublished(job.published);
                    if (!jobDays) return false;
                    const matchesPublished = activeFilters.published.some(selectedCategory => {
                        switch(selectedCategory) {
                            case "Last 3 Days": return jobDays <= 3;
                            case "Last 7 Days": return jobDays <= 7;
                            case "Last 14 Days": return jobDays <= 14;
                            case "Last 28 Days": return jobDays <= 28;
                            case "More than 28 Days": return jobDays > 28;
                            default: return false;
                        }
                    });
                    if (!matchesPublished) matchesOtherFilters = false;
                }

                if (!matchesOtherFilters) return false;

                // Use category filter logic for GP and Consultant
                if (professionName.toLowerCase() === 'gp' || professionName === 'GP') {
                    return categoryFilters.gp.filter(job);
                } else if (professionName.toLowerCase().includes('consultant') || professionName.includes('Consultant')) {
                    return categoryFilters.consultant.filter(job);
                } else {
                    // For other professions, use text matching
                    const sectors = job.sector || [];
                    const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                    return searchText.includes(professionName.toLowerCase()) ||
                           sectors.some(s => s.toLowerCase() === professionName.toLowerCase());
                }
            });

            countElement.textContent = jobsForThisProfession.length;
        }
    }
});

// Update published counts dynamically
document.querySelectorAll('.filter-item').forEach(item => {
    const checkbox = item.querySelector('.filter-checkbox');
    const countElement = item.querySelector('.filter-count');

    if (checkbox && countElement && checkbox.id.startsWith('published_')) {
        const label = checkbox.nextElementSibling;
        if (label) {
            const publishedCategory = label.textContent.trim().replace(/\s*\(\d+\)$/, '');

            // Apply all OTHER active filters except published
            let jobsForThisPublished = baseJobs.filter(job => {
                // Apply profession filters if any
                if (activeFilters.profession.length > 0) {
                    const matchesProfession = activeFilters.profession.some(profession => {
                        if (profession === 'GP') {
                            const isGPJob = categoryFilters.gp.filter(job);
                            if (!isGPJob) return false;

                            const jobTitle = job.job_title.toLowerCase();
                            const grade = (job.grade || '').toLowerCase();
                            const searchText = `${jobTitle} ${job.short_description} ${grade}`.toLowerCase();

                            const isSpecificGPType = ['digital gp', 'gp partner', 'gp trainee', 'locum gp', 'salaried gp'].some(gpType =>
                                searchText.includes(gpType) || jobTitle.includes(gpType) || grade.includes(gpType)
                            );

                            return !isSpecificGPType;
                        } else if (profession.includes('GP') && profession !== 'GP') {
                            const isGPJob = categoryFilters.gp.filter(job);
                            if (!isGPJob) return false;

                            const jobTitle = job.job_title.toLowerCase();
                            const grade = (job.grade || '').toLowerCase();
                            const searchText = `${jobTitle} ${job.short_description} ${grade}`.toLowerCase();
                            const professionLower = profession.toLowerCase();

                            return searchText.includes(professionLower) ||
                                   jobTitle.includes(professionLower) ||
                                   grade.includes(professionLower);
                        } else if (profession.toLowerCase().includes('consultant')) {
                            return categoryFilters.consultant.filter(job);
                        } else {
                            const sectors = job.sector || [];
                            const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''}`.toLowerCase();
                            return searchText.includes(profession.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                        }
                    });
                    if (!matchesProfession) return false;
                }

                // Apply location filters if any
                if (activeFilters.location.length > 0) {
                    const jobLocation = job.location_description || '';
                    const matchesLocation = activeFilters.location.some(location => {
                        const normalizedJobLocation = normalizeLocation(jobLocation);
                        const normalizedSearch = normalizeLocation(location);
                        return normalizedJobLocation.includes(normalizedSearch);
                    });
                    if (!matchesLocation) return false;
                }

                // Apply grade filters if any
                if (activeFilters.grade.length > 0) {
                    const matchesGrade = activeFilters.grade.some(gradeName => {
                        if (gradeName.toLowerCase().includes('consultant')) {
                            return categoryFilters.consultant.filter(job);
                        } else {
                            return job.grade === gradeName;
                        }
                    });
                    if (!matchesGrade) return false;
                }

                return true;
            });

            // Now check how many of these jobs match this specific published category
            const finalCount = jobsForThisPublished.filter(job => {
                if (!job.published) return false;
                const jobDays = parseDaysFromPublished(job.published);
                if (!jobDays) return false;

                switch(publishedCategory) {
                    case "Last 7 Days":
                        return jobDays <= 7;
                    case "Last 14 Days":
                        return jobDays <= 14;
                    case "Last 28 Days":
                        return jobDays <= 28;
                    case "More than 28 Days":
                        return jobDays > 28;
                    default:
                        return false;
                }
            }).length;

            countElement.textContent = finalCount;
        }
    }
});

        // Update location counts
        document.querySelectorAll('.location-sub-checkbox').forEach(checkbox => {
            const label = checkbox.nextElementSibling;
            const countElement = checkbox.closest('.profession-sub-item')?.querySelector('.filter-count');
            if (label && countElement) {
                const locationName = label.textContent.trim().replace(/\s*\(\d+\)$/, '');

                const jobsForThisLocation = baseJobs.filter(job => {
                    // Apply all OTHER active filters except this location
                    let matchesOtherFilters = true;

                    // Check professions
                    if (activeFilters.profession.length > 0) {
                        const sectors = job.sector || [];
                        const searchText = `${job.job_title} ${job.short_description} ${sectors.join(' ')} ${job.grade || ''} ${job.location_description} ${job.recruiter_name}`.toLowerCase();
                        const matchesProfession = activeFilters.profession.some(profession => {
                            return searchText.includes(profession.toLowerCase()) ||
                                   sectors.some(s => s.toLowerCase() === profession.toLowerCase());
                        });
                        if (!matchesProfession) matchesOtherFilters = false;
                    }

                    // Check grades
                    if (activeFilters.grade.length > 0) {
                        if (!job.grade || !activeFilters.grade.includes(job.grade)) {
                            matchesOtherFilters = false;
                        }
                    }

                    // Check published
                    if (activeFilters.published.length > 0) {
                        if (!job.published) return false;
                        const jobDays = parseDaysFromPublished(job.published);
                        if (!jobDays) return false;
                        const matchesPublished = activeFilters.published.some(selectedCategory => {
                            switch(selectedCategory) {
                                case "Last 3 Days": return jobDays <= 3;
                                case "Last 7 Days": return jobDays <= 7;
                                case "Last 14 Days": return jobDays <= 14;
                                case "Last 28 Days": return jobDays <= 28;
                                case "More than 28 Days": return jobDays > 28;
                                default: return false;
                            }
                        });
                        if (!matchesPublished) matchesOtherFilters = false;
                    }

                    if (!matchesOtherFilters) return false;

                    // Now check if this job matches the current location
                    const jobLocation = job.location_description || '';
                    const normalizedJobLocation = normalizeLocation(jobLocation);
                    const normalizedSearch = normalizeLocation(locationName);
                    return normalizedJobLocation.includes(normalizedSearch);
                });

                countElement.textContent = jobsForThisLocation.length;
            }
        });

// Update grade and published counts
document.querySelectorAll('.filter-checkbox').forEach(checkbox => {
    const item = checkbox.closest('.filter-item');
    const countElement = item?.querySelector('.filter-count');
    if (countElement) {
        const label = checkbox.nextElementSibling;
        if (label) {
            const filterValue = label.textContent.trim().replace(/\s*\(\d+\)$/, '');
            const filterType = checkbox.id.split('_')[0];

            if (filterType === 'grade') {
                const jobsForThisFilter = baseJobs.filter(job => {
                    if (filterValue.toLowerCase().includes('consultant')) {
                        return categoryFilters.consultant.filter(job);
                    } else {
                        return job.grade === filterValue;
                    }
                });
                countElement.textContent = jobsForThisFilter.length;
            } else if (filterType === 'published') {
                // Use the same counting function for dynamic updates
                const count = countJobsForPublishedFilter(filterValue, baseJobs);
                countElement.textContent = count;
            }
        }
    }
});
    }

    // Call the update function
    updateFilterOptionCounts();
}

function restoreFilterStates() {
       const checkedFilters = {};

       document.querySelectorAll('.profession-parent-checkbox:checked, .profession-sub-checkbox:checked').forEach(cb => {
           checkedFilters[cb.id] = true;
       });

       document.querySelectorAll('.location-checkbox:checked, .location-sub-checkbox:checked').forEach(cb => {
           checkedFilters[cb.id] = true;
       });

       document.querySelectorAll('.filter-checkbox:checked').forEach(cb => {
           checkedFilters[cb.id] = true;
       });

       setTimeout(() => {
           Object.keys(checkedFilters).forEach(id => {
               const checkbox = document.getElementById(id);
               if (checkbox) {
                   checkbox.checked = true;
               }
           });

           document.querySelectorAll('.profession-parent-group').forEach(group => {
               const parentId = group.querySelector('.profession-parent-checkbox').id;
               const parentName = parentId.replace('profession_parent_', '').replace(/_/g, ' ');
               updateParentCheckboxState('profession', parentName);
           });
       }, 10);
   }

   function generateDynamicKeywords() {
       const keywordSet = new Set();
       const maxKeywords = 6;

       const activeJobs = filterActiveJobs(allJobsData);

       const professions = [];
       const grades = [];

       activeJobs.forEach(job => {
           if (job.sector && Array.isArray(job.sector)) {
               job.sector.forEach(s => {
                   if (!professions.includes(s)) {
                       professions.push(s);
                   }
               });
           }
           if (job.grade && !grades.includes(job.grade)) {
               grades.push(job.grade);
           }
       });

       const shuffleArray = (array) => {
           const arr = [...array];
           for (let i = arr.length - 1; i > 0; i--) {
               const j = Math.floor(Math.random() * (i + 1));
               [arr[i], arr[j]] = [arr[j], arr[i]];
           }
           return arr;
       };

       const shuffledProfessions = shuffleArray(professions);
       const shuffledGrades = shuffleArray(grades);

       for (let i = 0; i < Math.min(3, shuffledProfessions.length); i++) {
           keywordSet.add(shuffledProfessions[i]);
       }

       for (let i = 0; i < Math.min(3, shuffledGrades.length); i++) {
           keywordSet.add(shuffledGrades[i]);
       }

       keywords = Array.from(keywordSet).slice(0, maxKeywords);
   }

  function initApp() {
        console.log('InitApp called, allJobsData length:', allJobsData?.length);

        requestAnimationFrame(() => {
            syncJobsData();

            if (!allJobsData || allJobsData.length === 0) {
                if (window.allJobsData && window.allJobsData.length > 0) {
                    allJobsData = window.allJobsData;
                } else {
                    console.log('No jobs data available yet');
                    return;
                }
            }

            filteredJobs = filterActiveJobs(allJobsData);

            if (!professionHierarchy || !locationHierarchy) {
                initializeHierarchies();
            }

            requestAnimationFrame(() => {
                calculateFilterCounts();
                generateDynamicKeywords();
                renderKeywords();
                renderFilters();

                // Immediately render jobs without waiting for idle callback
                renderJobsList();
                updatePagination();
                updateJobCount();
                updateCategoryButtons();
                addEventListeners();
            });
        });
    }

  window.initApp = initApp;

   function syncJobsData() {
       if (window.allJobsData && window.allJobsData.length > 0) {
           allJobsData = window.allJobsData;
       }
   }

   function updateJobCount() {
       const jobCountDisplay = document.getElementById('jobCountDisplay');
       const countText = generateJobCountText();
       jobCountDisplay.innerHTML = `<div class="job-count-main">${countText}</div>`;
   }

   function getCurrentPageJobs() {
       const startIndex = (currentPage - 1) * jobsPerPage;
       const endIndex = startIndex + jobsPerPage;
       return filteredJobs.slice(startIndex, endIndex);
   }

   function updatePagination() {
       const totalJobs = filteredJobs.length;
       const totalPages = Math.ceil(totalJobs / jobsPerPage);
       const startJob = totalJobs > 0 ? (currentPage - 1) * jobsPerPage + 1 : 0;
       const endJob = Math.min(currentPage * jobsPerPage, totalJobs);

       document.getElementById('jobRangeStart').textContent = startJob;
       document.getElementById('jobRangeEnd').textContent = endJob;
       document.getElementById('totalJobsCount').textContent = totalJobs;

       const pageNumbersContainer = document.getElementById('pageNumbers');
       let startPage = Math.max(1, currentPage - 3);
       let endPage = Math.min(totalPages, startPage + 6);

       if (endPage - startPage < 6) {
           startPage = Math.max(1, endPage - 6);
       }

       let pageNumbersHTML = '';
       for (let i = startPage; i <= endPage; i++) {
           pageNumbersHTML += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})" aria-label="Go to page ${i}">${i}</button>`;
       }
       pageNumbersContainer.innerHTML = pageNumbersHTML;

       document.getElementById('firstBtn').disabled = currentPage === 1;
       document.getElementById('prevBtn').disabled = currentPage === 1;
       document.getElementById('nextBtn').disabled = currentPage === totalPages || totalPages === 0;
       document.getElementById('lastBtn').disabled = currentPage === totalPages || totalPages === 0;
   }

   function renderJobsList() {
       const jobsList = document.getElementById('jobsList');
       const pageJobs = getCurrentPageJobs();

       if (pageJobs.length === 0) {
           jobsList.innerHTML = '<div class="no-jobs-message">No jobs found matching your criteria.</div>';
           return;
       }

       const fragment = document.createDocumentFragment();
       const container = document.createElement('div');

       container.innerHTML = pageJobs.map(job => {
           const employer = job.alternate_recruiter_name || job.recruiter_name || 'Unknown Employer';
           return `
               <div class="job-card">
                   <div class="job-header">${job.job_title}</div>
                   <div class="job-body">
                       ${job.logo_url ? `<img src="${job.logo_url}" alt="${employer} Logo" class="nhs-logo" loading="lazy">` : ''}
                       <div class="job-details">
                           <ul>
                               <li><strong>Location:</strong> ${job.location_description}</li>
                               <li><strong>Salary:</strong> ${job.salary || 'Competitive'}</li>
                               <li><strong>Employer:</strong> ${employer}</li>
                           </ul>
                       </div>
                       <div class="job-description">${job.short_description}</div>
                       <button class="apply-btn" onclick="applyToJob(${job.id})" aria-label="View details of ${job.job_title.replace(/"/g, '&quot;')} at ${employer.replace(/"/g, '&quot;')} on BMJ Careers">View Details on BMJ Careers</button>
                   </div>
               </div>
           `;
       }).join('');

	   while (container.firstChild) {
           fragment.appendChild(container.firstChild);
       }

       jobsList.innerHTML = '';
       jobsList.appendChild(fragment);
   }

   function handleResize() {
       const currentWidth = window.innerWidth;

       const filterGroups = ['published', 'profession', 'grade', 'location'];
       filterGroups.forEach(groupName => {
           const arrow = document.getElementById(groupName + 'Arrow');
           const options = document.getElementById(groupName + 'Options');

           if (arrow && options && !options.classList.contains('collapsed')) {
               options.classList.add('collapsed');
               arrow.classList.add('collapsed');
               arrow.textContent = '▶';
           }
       });

       lastWindowWidth = currentWidth;
   }

   function addEventListeners() {
       const keywordSearch = document.getElementById('keywordSearch');
       keywordSearch.addEventListener('input', function() {
           clearTimeout(this.searchTimeout);
           this.searchTimeout = setTimeout(() => {
               applyFilters();
               updateCategoryButtons();
               scrollToTop();
           }, 100);
       });

       keywordSearch.addEventListener('keypress', function(e) {
           if (e.key === 'Enter') {
               clearTimeout(this.searchTimeout);
               applyFilters();
               updateCategoryButtons();
               scrollToTop();
           }
       });

       window.addEventListener('scroll', handleScroll, { passive: true });
       window.addEventListener('resize', perfUtils.debounce(handleResize, 300), { passive: true });
   }

   function initializeButtonStates() {
       const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
       const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;

       if (!searchTerm && !hasCheckedFilters && activeCategoryFilter === 'all') {
           document.getElementById('btn-all').classList.add('active');
       } else if (activeCategoryFilter === 'all') {
           document.getElementById('btn-all').classList.remove('active');
       }

       updateCategoryButtons();
   }

   // Make initApp globally accessible for API integration
   window.initApp = initApp;

// Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded, initializing...');

    // Ensure all required elements exist
    const requiredElements = [
        'keywordSearch', 'jobsList', 'filtersContainer',
        'jobCountDisplay', 'pageNumbers'
    ];

    const missingElements = requiredElements.filter(id => !document.getElementById(id));
    if (missingElements.length > 0) {
        console.error('Missing required elements:', missingElements);
    }

    // Initialize with empty data first to show the interface
    if (!window.allJobsData || window.allJobsData.length === 0) {
        console.log('No jobs data available, initializing with empty array');
        window.allJobsData = [];

        // Show skeleton/loading state
        const jobsList = document.getElementById('jobsList');
        if (jobsList) {
            jobsList.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: #666;">
                    <div class="loading-spinner" style="margin: 0 auto 1rem auto;"></div>
                    <p>Loading jobs...</p>
                </div>
            `;
        }

        // Initialize app to show the interface
        if (typeof initApp === 'function') {
            initApp();
        }
    } else {
        console.log('Jobs data already available:', window.allJobsData.length, 'jobs');
        initApp();
    }

    initializeButtonStates();
});

// Listen for jobs data loaded event
window.addEventListener('jobsDataLoaded', function(event) {
    console.log('Jobs data loaded event received:', event.detail);
    if (typeof initApp === 'function') {
        initApp();
    }
    initializeButtonStates();
});

   // Listen for data updates from the API
    window.addEventListener('jobsDataUpdated', function() {
        console.log('Jobs data updated event received');
        initApp();
    });

   // Check periodically if data is available
   let dataCheckInterval = setInterval(function() {
       if (window.allJobsData && window.allJobsData.length > 0) {
           console.log('Jobs data detected:', window.allJobsData.length, 'jobs');
           clearInterval(dataCheckInterval);
           syncJobsData();
           initApp();
       }
   }, 500);

   // Clear interval after 30 seconds to prevent infinite checking
   setTimeout(function() {
       clearInterval(dataCheckInterval);
   }, 30000);

   // Lazy load images
   if ('IntersectionObserver' in window) {
       const imageObserver = new IntersectionObserver((entries, observer) => {
           entries.forEach(entry => {
               if (entry.isIntersecting) {
                   const img = entry.target;
                   if (img.dataset.src) {
                       img.src = img.dataset.src;
                       img.removeAttribute('data-src');
                       observer.unobserve(img);
                   }
               }
           });
       });

       document.addEventListener('DOMContentLoaded', () => {
           document.querySelectorAll('img[data-src]').forEach(img => {
               imageObserver.observe(img);
           });
       });
   }

   // Optimize scroll performance
   let ticking = false;
   function requestTick() {
       if (!ticking) {
           window.requestAnimationFrame(handleScroll);
           ticking = true;
       }
   }
   window.addEventListener('scroll', requestTick, { passive: true });

</script>

<!-- Cross-Origin Style Communication Script -->
<script>
    (function() {
        'use strict';

        const WIDGET_CONFIG = {
            widgetId: 'bmj-careers-widget',
            version: '2.0.0'
        };

        const isInIframe = window.self !== window.top;
        const ALLOWED_ORIGINS = '*';

        let customCategoryConfig = null;
        let clientTrackingConfig = null;

        const trackingData = {
            sessionId: null,
            clientId: null,
            interactions: [],
            scrollDepth: 0,
            timeOnPage: 0,
            searches: [],
            filterChanges: [],
            jobClicks: []
        };

        function applyCustomCategories(categories) {
            if (!categories || typeof categories !== 'object') return;

            console.log('Applying custom categories:', categories);
            customCategoryConfig = categories;

            const categoryButtons = document.querySelectorAll('.category-btn');

            categoryButtons.forEach(btn => {
                const btnId = btn.id;
                const categoryKey = btnId.replace('btn-', '');

                if (categories[categoryKey]) {
                    const config = categories[categoryKey];

                    if (config.enabled === false) {
                        btn.style.display = 'none';
                    } else {
                        btn.style.display = '';

                        if (config.label) {
                            const textSpan = btn.querySelector('span:last-child');
                            if (textSpan) {
                                textSpan.textContent = config.label;
                            }
                        }

                        if (config.icon) {
                            const emojiSpan = btn.querySelector('.emoji');
                            if (emojiSpan) {
                                emojiSpan.textContent = config.icon;
                            }
                        }
                    }
                }
            });

            if (window.categoryFilters) {
                Object.keys(categories).forEach(key => {
                    const config = categories[key];
                    if (config.enabled !== false && window.categoryFilters[key]) {
                        const originalFilter = window.categoryFilters[key].filter;

                        window.categoryFilters[key] = {
                            name: config.label || window.categoryFilters[key].name,
                            keywords: config.keywords || [],
                            filter: function(job) {
                                if (!config.keywords || config.keywords.length === 0) {
                                    return originalFilter ? originalFilter(job) : true;
                                }

                                let searchText = '';
                                const searchIn = config.searchIn || ['title', 'description', 'sector', 'grade'];

                                searchIn.forEach(field => {
                                    switch(field) {
                                        case 'title':
                                            searchText += ' ' + (job.job_title || '');
                                            break;
                                        case 'description':
                                            searchText += ' ' + (job.short_description || '');
                                            break;
                                        case 'sector':
                                            if (job.sector && Array.isArray(job.sector)) {
                                                searchText += ' ' + job.sector.join(' ');
                                            }
                                            break;
                                        case 'grade':
                                            searchText += ' ' + (job.grade || '');
                                            break;
                                        case 'location':
                                            searchText += ' ' + (job.location_description || '');
                                            break;
                                        case 'employer':
                                            searchText += ' ' + (job.recruiter_name || '') + ' ' + (job.alternate_recruiter_name || '');
                                            break;
                                    }
                                });

                                searchText = searchText.toLowerCase();

                                return config.keywords.some(keyword =>
                                    searchText.includes(keyword.toLowerCase())
                                );
                            }
                        };
                    }
                });
            }
        }

        function initializeButtonStates() {
            const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
            const hasCheckedFilters = document.querySelectorAll('.filter-checkbox:checked, .profession-parent-checkbox:checked, .profession-sub-checkbox:checked, .location-checkbox:checked, .location-sub-checkbox:checked').length > 0;

            if (!searchTerm && !hasCheckedFilters && activeCategoryFilter === 'all') {
                document.getElementById('btn-all').classList.add('active');
            } else if (activeCategoryFilter === 'all') {
                document.getElementById('btn-all').classList.remove('active');
            }

            updateCategoryButtons();
        }

        function initializeTracking(config) {
            if (!config || !config.tracking) return;

            trackingData.sessionId = config.tracking.sessionId;
            trackingData.clientId = config.tracking.clientId;
            clientTrackingConfig = config.tracking.features || {};

            console.log('Tracking initialized:', trackingData.sessionId);

            if (clientTrackingConfig.trackInteractions) {
                trackInteractions();
            }

            if (clientTrackingConfig.trackScrollDepth) {
                trackScrollDepth();
            }

            if (clientTrackingConfig.trackSearches) {
                trackSearches();
            }

            if (clientTrackingConfig.trackFilters) {
                trackFilterChanges();
            }
        }

        function trackInteractions() {
            document.addEventListener('click', function(e) {
                const target = e.target;
                const data = {
                    element: target.tagName,
                    className: target.className,
                    id: target.id,
                    text: target.innerText?.substring(0, 50)
                };

                trackingData.interactions.push(data);
                sendTrackingEvent('interaction', data);
            });
        }

        function trackScrollDepth() {
            let maxScroll = 0;
            window.addEventListener('scroll', debounce(function() {
                const scrollPercentage = Math.round((window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100);
                if (scrollPercentage > maxScroll) {
                    maxScroll = scrollPercentage;
                    trackingData.scrollDepth = maxScroll;
                    sendTrackingEvent('scroll', { depth: maxScroll });
                }
            }, 500));
        }

        function trackSearches() {
            const searchInput = document.getElementById('keywordSearch');
            if (searchInput) {
                searchInput.addEventListener('change', function() {
                    const searchTerm = this.value;
                    trackingData.searches.push({
                        term: searchTerm,
                        timestamp: Date.now()
                    });
                    sendTrackingEvent('search', { searchTerm });
                });
            }
        }

        function trackFilterChanges() {
            document.addEventListener('click', function(e) {
                if (e.target.closest('.category-btn')) {
                    const btn = e.target.closest('.category-btn');
                    const categoryId = btn.id.replace('btn-', '');
                    sendTrackingEvent('filter_change', {
                        filterType: 'category',
                        filterValue: categoryId
                    });
                }

                if (e.target.matches('.filter-checkbox, .profession-sub-checkbox, .location-sub-checkbox')) {
                    sendTrackingEvent('filter_change', {
                        filterType: e.target.className,
                        filterValue: e.target.id,
                        checked: e.target.checked
                    });
                }
            });
        }

        function sendTrackingEvent(eventType, data) {
            if (!isInIframe) return;

            window.parent.postMessage({
                type: 'bmj-careers-event',
                eventType: eventType,
                data: data,
                timestamp: Date.now()
            }, '*');
        }

        const originalApplyToJob = window.applyToJob;
        window.applyToJob = function(jobId) {
            const job = allJobsData.find(j => j.id === jobId);

            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-job-click',
                    jobId: jobId,
                    jobTitle: job?.job_title || 'Unknown',
                    employer: job?.recruiter_name || job?.alternate_recruiter_name || 'Unknown'
                }, '*');
            }

            if (job && job.job_url) {
                window.open(job.job_url, '_blank', 'noopener,noreferrer');
            } else {
                window.open('https://www.bmj.com/careers/jobs/', '_blank', 'noopener,noreferrer');
            }
        };

        const originalApplyCategoryFilter = window.applyCategoryFilter;
        window.applyCategoryFilter = function(category) {
            activeCategoryFilter = category;

            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-filter-change',
                    filterType: 'category',
                    filterValue: category
                }, '*');
            }

            updateCategoryButtons();

            if (category === 'all') {
                document.getElementById('keywordSearch').value = '';

                document.querySelectorAll('.filter-checkbox, .profession-parent-checkbox, .profession-sub-checkbox, .location-checkbox, .location-sub-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.classList.remove('indeterminate');
                });

                document.getElementById('btn-all').classList.add('active');
            }

            applyFilters();
            scrollToTop();
        };

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        window.addEventListener('message', function(event) {
            const trustedOrigins = ['http://localhost:3000', 'https://careers.bmj.com', window.location.origin];
            if (event.origin && !trustedOrigins.includes(event.origin) && !event.origin.includes('bmj')) {
                console.warn('Untrusted origin:', event.origin);
                return;
            }

            if (!event.data || typeof event.data !== 'object') return;

            switch (event.data.type) {
                case 'bmj-careers-config':
                    if (event.data.categories) {
                        window.customCategoryConfig = event.data.categories;
                        if (typeof applyCategoryFilter === 'function') {
                            applyCategoryFilter('all');
                        }
                    }
                    break;

                case 'bmj-careers-tracking':
                    const { eventType, sessionId, clientId, clientName, data } = event.data;

                    window.widgetClientInfo = {
                        clientId: clientId,
                        clientName: clientName,
                        sessionId: sessionId
                    };

                    console.log('Received tracking config:', window.widgetClientInfo);
                    break;
            }
        });

        window.addEventListener('load', function() {
            if (window.self !== window.top) {
                window.parent.postMessage({
                    type: 'bmj-careers-ready',
                    widgetId: 'bmj-careers-widget',
                    version: '2.0.0'
                }, '*');
            }
        });

        function isAllowedOrigin(origin) {
            if (ALLOWED_ORIGINS === '*') return true;
            return ALLOWED_ORIGINS.includes(origin);
        }

        const applyCustomStyles = (function() {
            let styleElement = null;

            return function(styles) {
                // Style application code remains the same
            };
        })();

        function handleCommand(command, data) {
            switch(command) {
                case 'refresh':
                    location.reload();
                    break;
                case 'scrollToTop':
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    break;
                case 'requestConfig':
                    window.parent.postMessage({
                        type: 'bmj-careers-current-config',
                        categories: customCategoryConfig,
                        tracking: trackingData
                    }, '*');
                    break;
            }
        }

        function sendReadyMessage() {
            window.parent.postMessage({
                type: 'bmj-careers-ready',
                widgetId: WIDGET_CONFIG.widgetId,
                version: WIDGET_CONFIG.version,
                isInIframe: isInIframe,
                capabilities: {
                    customCategories: true,
                    enhancedTracking: true,
                    customStyles: true
                }
            }, '*');

            if (isInIframe) {
                setTimeout(() => {
                    window.parent.postMessage({
                        type: 'bmj-careers-request-config',
                        widgetId: WIDGET_CONFIG.widgetId
                    }, '*');
                }, 100);
            }

            console.log('BMJ Careers Widget initialized with enhanced features v2.0');
        }

        if (document.readyState === 'complete') {
            sendReadyMessage();
        } else {
            window.addEventListener('load', sendReadyMessage);
            document.addEventListener('DOMContentLoaded', sendReadyMessage);
        }

        window.BMJWidgetTracking = {
            getData: () => trackingData,
            getConfig: () => customCategoryConfig,
            sendEvent: sendTrackingEvent
        };
    })();
</script>
<!-- End Cross-Origin Style Communication Script -->
<script>
    // Enhanced Cross-Origin Communication & Custom Category Fix - v3.1
    (function() {
        'use strict';

        const WIDGET_CONFIG = {
            widgetId: 'bmj-careers-widget',
            version: '3.1.0'
        };

        const isInIframe = window.self !== window.top;
        let customConfig = null;
        let configReceived = false;

        function waitForElement(selector, callback, maxAttempts = 20) {
            let attempts = 0;
            const checkElement = () => {
                const element = document.querySelector(selector);
                if (element) {
                    callback(element);
                } else if (attempts < maxAttempts) {
                    attempts++;
                    setTimeout(checkElement, 500);
                } else {
                    console.warn('[Widget] Element not found after max attempts:', selector);
                }
            };
            checkElement();
        }

        function applyCustomCategories(categories) {
            if (!categories || typeof categories !== 'object') return;

            customConfig = categories;
            configReceived = true;
            console.log('[Widget] Received custom categories:', Object.keys(categories));

            // Wait for category buttons container to be available
            waitForElement('.category-buttons', (categoryButtonsWrapper) => {
                console.log('[Widget] Category buttons wrapper found, creating buttons...');

                // Handle existing category buttons first
                Object.entries(categories).forEach(([key, config]) => {
                    const btnId = `btn-${key}`;
                    const btn = document.getElementById(btnId);

                    if (btn) {
                        if (config.enabled === false) {
                            btn.style.display = 'none';
                            console.log('[Widget] Disabled existing button:', key);
                        } else {
                            btn.style.display = '';
                            if (config.label) {
                                const textSpan = btn.querySelector('span:last-child');
                                if (textSpan) {
                                    textSpan.textContent = config.label;
                                    console.log('[Widget] Updated label for button:', key, config.label);
                                }
                            }
                            if (config.icon !== undefined) {
                                const emojiSpan = btn.querySelector('.emoji');
                                if (emojiSpan) {
                                    if (config.icon === null) {
                                        emojiSpan.style.display = 'none';
                                    } else {
                                        emojiSpan.innerHTML = config.icon;
                                        emojiSpan.style.display = '';
                                    }
                                    console.log('[Widget] Updated icon for button:', key);
                                }
                            }
                        }
                    }
                });

                // Create new custom category buttons
                Object.entries(categories).forEach(([key, config]) => {
                    const btnId = `btn-${key}`;

                    if (!document.getElementById(btnId) && config.enabled !== false) {
                        console.log('[Widget] Creating new button for:', key, config);

                        const newButton = document.createElement('button');
                        newButton.className = 'category-btn';
                        newButton.id = btnId;

                        // Create click handler function
                        newButton.addEventListener('click', function() {
                            console.log('[Widget] Custom category button clicked:', key);

                            // Wait for applyCategoryFilter to be available
                            if (window.applyCategoryFilter) {
                                window.applyCategoryFilter(key);
                            } else {
                                console.warn('[Widget] applyCategoryFilter not available yet');
                            }
                        });

                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'emoji';
                        iconSpan.setAttribute('aria-hidden', 'true');
                        if (config.icon && config.icon !== null) {
                            iconSpan.innerHTML = config.icon;
                        } else {
                            iconSpan.style.display = 'none';
                        }

                        const textSpan = document.createElement('span');
                        textSpan.textContent = config.label || key;

                        newButton.appendChild(iconSpan);
                        newButton.appendChild(textSpan);
                        categoryButtonsWrapper.appendChild(newButton);

                        console.log('[Widget] Successfully created button:', key);
                    }
                });

                // Setup the filtering system
                setupCustomFiltering(categories);
            });
        }

        function setupCustomFiltering(categories) {
            console.log('[Widget] Setting up custom filtering...');

            // Wait for the widget's filtering system to be ready
            const setupFilters = () => {
                if (!window.categoryFilters || !window.applyCategoryFilter) {
                    setTimeout(setupFilters, 500);
                    return;
                }

                console.log('[Widget] Adding custom filters to categoryFilters...');

                // Add custom filters to categoryFilters
                Object.entries(categories).forEach(([key, config]) => {
                    if (config.enabled !== false && config.keywords && config.keywords.length > 0) {
                        window.categoryFilters[key] = {
                            name: config.label || key,
                            keywords: config.keywords,
                            filter: function(job) {
                                let searchText = '';
                                const searchIn = config.searchIn || ['title', 'description', 'sector', 'grade'];

                                searchIn.forEach(field => {
                                    switch(field) {
                                        case 'title':
                                            searchText += ' ' + (job.job_title || '');
                                            break;
                                        case 'description':
                                            searchText += ' ' + (job.short_description || '');
                                            break;
                                        case 'sector':
                                            if (job.sector && Array.isArray(job.sector)) {
                                                searchText += ' ' + job.sector.join(' ');
                                            }
                                            break;
                                        case 'grade':
                                            searchText += ' ' + (job.grade || '');
                                            break;
                                        case 'location':
                                            searchText += ' ' + (job.location_description || '');
                                            break;
                                        case 'employer':
                                            searchText += ' ' + (job.recruiter_name || '') + ' ' + (job.alternate_recruiter_name || '');
                                            break;
                                    }
                                });

                                searchText = searchText.toLowerCase().trim();

                                return config.keywords.some(keyword => {
                                    const keywordLower = keyword.toLowerCase().trim();
                                    return searchText.includes(keywordLower);
                                });
                            }
                        };

                        console.log(`[Widget] Added custom filter: ${key} with keywords:`, config.keywords);
                    }
                });

                console.log('[Widget] Custom filtering setup complete');
            };

            setupFilters();
        }

        function generateCustomCSS(styles) {
            return `
                :root {
                    --bmj-primary: ${styles.primaryColor || '#0066cc'};
                    --bmj-secondary: ${styles.secondaryColor || '#FFC000'};
                    --bmj-bg: ${styles.backgroundColor || '#f0f4f8'};
                    --bmj-card-bg: ${styles.cardBackgroundColor || '#ffffff'};
                    --bmj-text: ${styles.textColor || '#1d1d1b'};
                }

                .category-btn {
                    background: ${styles.categoryButtonInactiveColor || '#ffffff'} !important;
                    color: ${styles.primaryColor || '#0066cc'} !important;
                    border: 2px solid ${styles.borderColor || '#e5e7eb'} !important;
                }
                .category-btn:hover {
                    background: ${styles.categoryButtonHoverColor || '#0066cc'} !important;
                    color: ${styles.buttonTextColor || '#ffffff'} !important;
                }
                .category-btn.active {
                    background: ${styles.categoryButtonActiveColor || '#0066cc'} !important;
                    color: ${styles.buttonTextColor || '#ffffff'} !important;
                }
                .job-header {
                    background: ${styles.jobCardHeaderColor || '#0066cc'} !important;
                    color: ${styles.jobCardHeaderTextColor || '#ffffff'} !important;
                }
            `;
        }

        function applyCustomStyles(styles) {
            if (!styles || typeof styles !== 'object') return;

            let styleSheet = document.getElementById('bmj-custom-styles');
            if (!styleSheet) {
                styleSheet = document.createElement('style');
                styleSheet.id = 'bmj-custom-styles';
                document.head.appendChild(styleSheet);
            }

            const css = generateCustomCSS(styles);
            styleSheet.textContent = css;
            console.log('[Widget] Custom styles applied');
        }

        // Message handler
        window.addEventListener('message', function(event) {
            if (!event.data || typeof event.data !== 'object') return;

            switch (event.data.type) {
                case 'bmj-careers-config':
                    console.log('[Widget] Received configuration:', event.data);
                    if (event.data.styles) applyCustomStyles(event.data.styles);
                    if (event.data.categories) applyCustomCategories(event.data.categories);
                    break;
                case 'bmj-careers-request-config':
                    break;
            }
        });

        // Send ready message
        function sendReadyMessage() {
            if (isInIframe) {
                window.parent.postMessage({
                    type: 'bmj-careers-ready',
                    widgetId: WIDGET_CONFIG.widgetId,
                    version: WIDGET_CONFIG.version
                }, '*');

                // Request configuration
                setTimeout(() => {
                    window.parent.postMessage({
                        type: 'bmj-careers-request-config',
                        widgetId: WIDGET_CONFIG.widgetId
                    }, '*');
                }, 100);
            }
        }

        // Initialize when ready
        if (document.readyState === 'complete') {
            sendReadyMessage();
        } else {
            window.addEventListener('load', sendReadyMessage);
            document.addEventListener('DOMContentLoaded', sendReadyMessage);
        }

        // Debug function
        window.debugCustomCategories = function() {
            console.log('=== CUSTOM CATEGORIES DEBUG ===');
            console.log('Config received:', configReceived);
            console.log('customConfig:', customConfig);
            console.log('categoryFilters:', window.categoryFilters);
            console.log('Category buttons:', document.querySelectorAll('.category-btn'));
            console.log('=== END DEBUG ===');
        };

        console.log('[Widget] Enhanced BMJ Careers Widget v3.1 initialized');
    })();
</script>
</body>
</html>

